diff --git a/base/BUILD.gn b/base/BUILD.gn
index 9247e9b3f4c92..eacd7f76564df 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1085,6 +1085,7 @@ component("base") {
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
     "//third_party/abseil-cpp:absl",
+    "//ui/base:buildflags",
   ]
 
   if (build_rust_base_conversions) {
@@ -2532,6 +2533,7 @@ buildflag_header("debugging_buildflags") {
     "ENABLE_ALLOCATION_STACK_TRACE_RECORDER=$build_allocation_stack_trace_recorder",
     "ENABLE_ALLOCATION_TRACE_RECORDER_FULL_REPORTING=$build_allocation_trace_recorder_full_reporting",
     "PRINT_UNSYMBOLIZED_STACK_TRACES=$print_unsymbolized_stack_traces",
+    "THORIUM_DEBUG=$thorium_debug",
   ]
 }
 
diff --git a/base/check.cc b/base/check.cc
index bd63d5a88e34e..1bed253cb50ee 100644
--- a/base/check.cc
+++ b/base/check.cc
@@ -323,6 +323,7 @@ std::ostream& CheckError::stream() {
 }
 
 CheckError::~CheckError() {
+#if !BUILDFLAG(THORIUM_DEBUG)
   // TODO(crbug.com/40254046): Consider splitting out CHECK from DCHECK so that
   // the destructor can be marked [[noreturn]] and we don't need to check
   // severity in the destructor.
@@ -340,6 +341,7 @@ CheckError::~CheckError() {
   if (is_fatal) {
     base::ImmediateCrash();
   }
+#endif // !BUILDFLAG(THORIUM_DEBUG)
 }
 
 CheckError::CheckError(LogMessage* log_message) : log_message_(log_message) {}
diff --git a/base/debug/debug.gni b/base/debug/debug.gni
index 1d236d210a16f..b5059c81559ec 100644
--- a/base/debug/debug.gni
+++ b/base/debug/debug.gni
@@ -26,6 +26,13 @@ declare_args() {
   # Even if it's disabled we still collect some data, i.e. total number of
   # allocations. All other data will be set to a default value.
   build_allocation_trace_recorder_full_reporting = false
+
+  # A special build flag for the Thorium debug builds.
+  #
+  # This enables stack traces in logs and non-fatalizes DCHECKs.
+  # Ultimately, it should help users collect necessary data for browser issues
+  # without setting up a dedicated debugger.
+  thorium_debug = is_debug
 }
 
 assert(!(build_allocation_stack_trace_recorder && is_fuchsia),
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index 7cda11126e61e..fe82b35a1a5d1 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -883,8 +883,9 @@ bool IsLink(const FilePath& file_path) {
 }
 
 bool GetFileInfo(const FilePath& file_path, File::Info* results) {
+#if !BUILDFLAG(THORIUM_DEBUG)
   ScopedBlockingCall scoped_blocking_call(FROM_HERE, BlockingType::MAY_BLOCK);
-
+#endif
   WIN32_FILE_ATTRIBUTE_DATA attr;
   if (!GetFileAttributesEx(file_path.value().c_str(), GetFileExInfoStandard,
                            &attr)) {
diff --git a/base/logging.cc b/base/logging.cc
index 0d93ca4713624..3815fe60b4776 100644
--- a/base/logging.cc
+++ b/base/logging.cc
@@ -8,6 +8,7 @@
 #endif
 
 #include "base/logging.h"
+#include "base/environment.h"
 
 #ifdef BASE_CHECK_H_
 #error "logging.h should not include check.h"
@@ -62,6 +63,7 @@
 #include "build/chromeos_buildflags.h"
 #include "third_party/abseil-cpp/absl/base/internal/raw_logging.h"
 #include "third_party/abseil-cpp/absl/cleanup/cleanup.h"
+#include "ui/base/ui_base_features.h"
 
 #if !BUILDFLAG(IS_NACL)
 #include "base/auto_reset.h"
@@ -457,6 +459,7 @@ void WriteToFd(int fd, const char* data, size_t length) {
   }
 }
 
+#if !BUILDFLAG(THORIUM_DEBUG)
 void SetLogFatalCrashKey(LogMessage* log_message) {
 #if !BUILDFLAG(IS_NACL)
   // In case of an out-of-memory condition, this code could be reentered when
@@ -477,6 +480,7 @@ void SetLogFatalCrashKey(LogMessage* log_message) {
 
 #endif  // !BUILDFLAG(IS_NACL)
 }
+#endif
 
 std::string BuildCrashString(const char* file,
                              int line,
@@ -585,9 +589,24 @@ int GetMinLogLevel() {
   return g_min_log_level;
 }
 
+bool IsVerbose() {
+  const char* const env = getenv("THORIUM_DEBUG");
+  const std::string_view env_str =
+      env ? std::string_view(env) : std::string_view();
+  if (env_str == "1" || env_str == "true") {
+    return true;
+  } else {
+    return false;
+  }
+}
+
 bool ShouldCreateLogMessage(int severity) {
-  if (severity < g_min_log_level)
+  if (severity < g_min_log_level) {
     return false;
+  }
+  if (IsVerbose()) {
+    return true;
+  }
 
   // Return true here unless we know ~LogMessage won't do anything.
   return g_logging_destination != LOG_NONE || g_log_message_handler ||
@@ -599,8 +618,12 @@ bool ShouldCreateLogMessage(int severity) {
 // set, or only LOG_TO_FILE is set, since that is useful for local development
 // and debugging.
 bool ShouldLogToStderr(int severity) {
-  if (g_logging_destination & LOG_TO_STDERR)
+  if (g_logging_destination & LOG_TO_STDERR) {
+    return true;
+  }
+  if (IsVerbose()) {
     return true;
+  }
 
 #if BUILDFLAG(IS_FUCHSIA)
   // Fuchsia will persist data logged to stdio by a component, so do not emit
@@ -731,9 +754,11 @@ void LogMessage::Flush() {
   // Don't let actions from this method affect the system error after returning.
   base::ScopedClearLastError scoped_clear_last_error;
 
+#if !BUILDFLAG(THORIUM_DEBUG)
   size_t stack_start = stream_.str().length();
+#endif
 #if !defined(OFFICIAL_BUILD) && !BUILDFLAG(IS_NACL) && !defined(__UCLIBC__) && \
-    !BUILDFLAG(IS_AIX)
+    !BUILDFLAG(IS_AIX) || BUILDFLAG(THORIUM_DEBUG)
   // Include a stack trace on a fatal, unless a debugger is attached.
   if (severity_ == LOGGING_FATAL && !base::debug::BeingDebugged()) {
     base::debug::StackTrace stack_trace;
@@ -766,6 +791,7 @@ void LogMessage::Flush() {
   std::string str_newline(stream_.str());
   TraceLogMessage(file_, line_, str_newline.substr(message_start_));
 
+#if !BUILDFLAG(THORIUM_DEBUG)
   // FATAL messages should always run the assert handler and crash, even if a
   // message handler marks them as otherwise handled.
   absl::Cleanup handle_fatal_message = [&] {
@@ -776,6 +802,7 @@ void LogMessage::Flush() {
 
   if (severity_ == LOGGING_FATAL)
     SetLogFatalCrashKey(this);
+#endif
 
   // Give any log message handler first dibs on the message.
   if (g_log_message_handler &&
diff --git a/base/logging.h b/base/logging.h
index fe2ce670da340..82bbda21a16e5 100644
--- a/base/logging.h
+++ b/base/logging.h
@@ -301,6 +301,9 @@ BASE_EXPORT void SetMinLogLevel(int level);
 // Gets the current log level.
 BASE_EXPORT int GetMinLogLevel();
 
+// Whether to always log in verbose mode
+BASE_EXPORT bool IsVerbose();
+
 // Used by LOG_IS_ON to lazy-evaluate stream arguments.
 BASE_EXPORT bool ShouldCreateLogMessage(int severity);
 
diff --git a/chrome/browser/extensions/api/messaging/launch_context_win.cc b/chrome/browser/extensions/api/messaging/launch_context_win.cc
index b103bbe61303d..469611cb36e7a 100644
--- a/chrome/browser/extensions/api/messaging/launch_context_win.cc
+++ b/chrome/browser/extensions/api/messaging/launch_context_win.cc
@@ -62,7 +62,7 @@ bool GetManifestPathWithFlags(HKEY root_key,
                               std::wstring* result) {
 #if BUILDFLAG(CHROMIUM_BRANDING)
   static constexpr wchar_t kChromiumNativeMessagingRegistryKey[] =
-      L"SOFTWARE\\Chromium\\NativeMessagingHosts";
+      L"SOFTWARE\\Thorium\\NativeMessagingHosts";
 
   // Try to read the path using the Chromium-specific registry for Chromium.
   // If that fails, fallback to Chrome-specific registry key below.
diff --git a/chrome/browser/resources/downloads/item.css b/chrome/browser/resources/downloads/item.css
index f5c2357c5c986..86f18f7c77f8a 100644
--- a/chrome/browser/resources/downloads/item.css
+++ b/chrome/browser/resources/downloads/item.css
@@ -322,7 +322,7 @@ cr-button {
   --cr-icon-button-icon-size: 20px;
   --cr-icon-button-margin-end: 0;
   --cr-icon-button-margin-start: 0;
-  gap: 12px;
+  gap: 6px;
   margin-top: 12px;
   margin-inline-start: 12px;
   margin-inline-end: 12px;
diff --git a/chrome/browser/resources/downloads/item.html.ts b/chrome/browser/resources/downloads/item.html.ts
index 1e0f2c895d708..64347e17d7e42 100644
--- a/chrome/browser/resources/downloads/item.html.ts
+++ b/chrome/browser/resources/downloads/item.html.ts
@@ -47,7 +47,7 @@ export function getHtml(this: DownloadsItemElement) {
             ?hidden="${!this.shouldShowReferrerUrl_()}">
           <!-- Text populated dynamically -->
         </div>
-        <a id="url" ?hidden="${this.showReferrerUrl_}" target="_blank"
+        <a id="url" target="_blank"
           @click="${this.onUrlClick_}" focus-row-control
           focus-type="url">${this.getDisplayUrlStr_()}</a>
       </div>
@@ -94,7 +94,6 @@ export function getHtml(this: DownloadsItemElement) {
             focus-row-control focus-type="copyDownloadLink">
         </cr-icon-button>
         <cr-icon-button id="more-actions" iron-icon="cr:more-vert"
-            ?hidden="${!this.computeShowActionMenu_()}"
             class="dropdown-trigger" title="$i18n{moreActions}"
             @click="${this.onMoreActionsClick_}" aria-haspopup="menu"
             focus-row-control focus-type="actionMenuButton">
diff --git a/chrome/browser/resources/pdf/manifest.json b/chrome/browser/resources/pdf/manifest.json
index f355f92ac2f37..e0b69081164fd 100644
--- a/chrome/browser/resources/pdf/manifest.json
+++ b/chrome/browser/resources/pdf/manifest.json
@@ -3,8 +3,8 @@
   "manifest_version": 2,
   "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDN6hM0rsDYGbzQPQfOygqlRtQgKUXMfnSjhIBL7LnReAVBEd7ZmKtyN2qmSasMl4HZpMhVe2rPWVVwBDl6iyNE/Kok6E6v6V3vCLGsOpQAuuNVye/3QxzIldzG/jQAdWZiyXReRVapOhZtLjGfywCvlWq7Sl/e3sbc0vWybSDI2QIDAQAB",
   "name": "<NAME>",
-  "version": "1",
-  "description": "",
+  "version": "1.0.1",
+  "description": "Internal Component Extension for rendering PDFs.",
   "offline_enabled": true,
   "incognito": "split",
   "permissions": [
diff --git a/chrome/browser/search/search.cc b/chrome/browser/search/search.cc
index 40c586fb4f715..9bc0ea94e459a 100644
--- a/chrome/browser/search/search.cc
+++ b/chrome/browser/search/search.cc
@@ -95,17 +95,6 @@ enum NewTabURLState {
   NEW_TAB_URL_MAX
 };
 
-const TemplateURL* GetDefaultSearchProviderTemplateURL(Profile* profile) {
-  if (profile) {
-    TemplateURLService* template_url_service =
-        TemplateURLServiceFactory::GetForProfile(profile);
-    if (template_url_service) {
-      return template_url_service->GetDefaultSearchProvider();
-    }
-  }
-  return nullptr;
-}
-
 bool IsMatchingServiceWorker(const GURL& my_url, const GURL& document_url) {
   // The origin should match.
   if (!MatchesOrigin(my_url, document_url)) {
@@ -142,21 +131,6 @@ bool IsNTPOrRelatedURLHelper(const GURL& url, Profile* profile) {
                                     IsMatchingServiceWorker(url, new_tab_url));
 }
 
-bool IsURLAllowedForSupervisedUser(const GURL& url, Profile& profile) {
-  if (!profile.IsChild()) {
-    return true;
-  }
-  supervised_user::SupervisedUserService* supervised_user_service =
-      SupervisedUserServiceFactory::GetForProfile(&profile);
-  supervised_user::SupervisedUserURLFilter* url_filter =
-      supervised_user_service->GetURLFilter();
-  if (url_filter->GetFilteringBehaviorForURL(url) ==
-      supervised_user::FilteringBehavior::kBlock) {
-    return false;
-  }
-  return true;
-}
-
 // Used to look up the URL to use for the New Tab page. Also tracks how we
 // arrived at that URL so it can be logged with UMA.
 struct NewTabURLDetails {
@@ -179,33 +153,9 @@ struct NewTabURLDetails {
     const GURL local_url(default_is_google
                              ? chrome::kChromeUINewTabPageURL
                              : chrome::kChromeUINewTabPageThirdPartyURL);
-    if (default_is_google) {
-      return NewTabURLDetails(local_url, NEW_TAB_URL_VALID);
-    }
 #endif
 
-    const TemplateURL* template_url =
-        GetDefaultSearchProviderTemplateURL(profile);
-    if (!profile || !template_url) {
-      return NewTabURLDetails(local_url, NEW_TAB_URL_BAD);
-    }
-
-    GURL search_provider_url(template_url->new_tab_url_ref().ReplaceSearchTerms(
-        TemplateURLRef::SearchTermsArgs(std::u16string()),
-        UIThreadSearchTermsData()));
-
-    if (!search_provider_url.is_valid()) {
-      return NewTabURLDetails(local_url, NEW_TAB_URL_NOT_SET);
-    }
-    if (!search_provider_url.SchemeIsCryptographic()) {
-      return NewTabURLDetails(local_url, NEW_TAB_URL_INSECURE);
-    }
-    if (!IsURLAllowedForSupervisedUser(search_provider_url,
-                                       CHECK_DEREF(profile))) {
-      return NewTabURLDetails(local_url, NEW_TAB_URL_BLOCKED);
-    }
-
-    return NewTabURLDetails(search_provider_url, NEW_TAB_URL_VALID);
+    return NewTabURLDetails(local_url, NEW_TAB_URL_VALID);
   }
 
   const GURL url;
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index bc6e4008f2c5a..9b6dffa76b9dc 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -182,6 +182,7 @@ static_library("ui") {
     "tab_modal_confirm_dialog.h",
     "tab_ui_helper.cc",
     "tab_ui_helper.h",
+    "thorium_2024.h",
     "toolbar/chrome_labs/chrome_labs_model.cc",
     "toolbar/chrome_labs/chrome_labs_model.h",
     "toolbar/chrome_labs/chrome_labs_prefs.cc",
@@ -4430,6 +4431,8 @@ static_library("ui") {
       "views/frame/top_container_view.cc",
       "views/frame/top_container_view.h",
       "views/frame/top_controls_slide_controller.h",
+      "views/frame/window_caption_util.cc",
+      "views/frame/window_caption_util.h",
       "views/frame/web_contents_close_handler.cc",
       "views/frame/web_contents_close_handler.h",
       "views/frame/web_contents_close_handler_delegate.h",
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils.cc b/chrome/browser/ui/bookmarks/bookmark_utils.cc
index e7858be996ca8..c8dd78eab4df0 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils.cc
@@ -7,6 +7,7 @@
 #include <stddef.h>
 
 #include "base/check.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/memory/raw_ptr.h"
@@ -292,9 +293,13 @@ gfx::ImageSkia GetBookmarkFolderImageFromVectorIcon(
   const gfx::VectorIcon* id;
   gfx::ImageSkia folder;
   if (icon_type == BookmarkFolderIconType::kNormal) {
-    id = &vector_icons::kFolderChromeRefreshIcon;
+    id = features::IsThorium2024()
+         ? &vector_icons::kFolderIcon
+         : &vector_icons::kFolderChromeRefreshIcon;
   } else {
-    id = &vector_icons::kFolderManagedRefreshIcon;
+    id = features::IsThorium2024()
+         ? &vector_icons::kFolderManagedIcon
+         : &vector_icons::kFolderManagedRefreshIcon;
   }
   const ui::ThemedVectorIcon icon =
       absl::holds_alternative<SkColor>(color)
@@ -318,8 +323,45 @@ ui::ImageModel GetBookmarkFolderIcon(
                             absl::variant<ui::ColorId, SkColor> color,
                             const ui::ColorProvider* color_provider) {
     gfx::ImageSkia folder;
-    folder =
-        GetBookmarkFolderImageFromVectorIcon(icon_type, color, color_provider);
+    if (!features::IsThorium2024()) {
+      folder = GetBookmarkFolderImageFromVectorIcon(icon_type, color,
+                                                    color_provider);
+    } else {
+#if BUILDFLAG(IS_WIN)
+      // TODO(bsep): vectorize the Windows versions: crbug.com/564112
+      folder = *ui::ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
+          default_id);
+#elif BUILDFLAG(IS_MAC)
+      SkColor sk_color;
+      if (absl::holds_alternative<SkColor>(color)) {
+        sk_color = absl::get<SkColor>(color);
+      } else {
+        DCHECK(color_provider);
+        sk_color = color_provider->GetColor(absl::get<ui::ColorId>(color));
+      }
+      const int white_id = (icon_type == BookmarkFolderIconType::kNormal)
+                               ? IDR_FOLDER_CLOSED_WHITE
+                               : IDR_BOOKMARK_BAR_FOLDER_MANAGED_WHITE;
+      const int resource_id =
+          color_utils::IsDark(sk_color) ? default_id : white_id;
+      folder = *ui::ResourceBundle::GetSharedInstance()
+                    .GetNativeImageNamed(resource_id)
+                    .ToImageSkia();
+#elif BUILDFLAG(IS_LINUX)
+      const bool classic_bookmarks =
+          base::CommandLine::ForCurrentProcess()->HasSwitch("classic-bookmarks");
+      if (classic_bookmarks) {
+        folder = *ui::ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
+            default_id);
+      } else {
+        folder = GetBookmarkFolderImageFromVectorIcon(icon_type, color,
+                                                      color_provider);
+      }
+#else
+      folder = GetBookmarkFolderImageFromVectorIcon(icon_type, color,
+                                                    color_provider);
+#endif
+    }
     return gfx::ImageSkia(std::make_unique<RTLFlipSource>(folder),
                           folder.size());
   };
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
index 64948595a4bc6..a568c893736ca 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -47,7 +47,7 @@ using bookmarks::BookmarkNode;
 
 namespace chrome {
 
-size_t kNumBookmarkUrlsBeforePrompting = 15;
+size_t kNumBookmarkUrlsBeforePrompting = 50;
 
 static BookmarkNavigationWrapper* g_nav_wrapper_test_instance = nullptr;
 
diff --git a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
index 71f9d6ad07da0..246532a09797a 100644
--- a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
+++ b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
@@ -133,10 +133,6 @@ std::optional<size_t> RecentlyUsedFoldersComboModel::GetDefaultIndex() const {
   // TODO(pbos): Look at returning -1 here if there's no default index. Right
   // now a lot of code in Combobox assumes an index within `items_` bounds.
   auto it = base::ranges::find(items_, Item(parent_node_, Item::TYPE_NODE));
-  if (it == items_.end()) {
-    it = base::ranges::find(items_,
-                            Item(parent_node_, Item::TYPE_ALL_BOOKMARKS_NODE));
-  }
   return it == items_.end() ? 0 : static_cast<int>(it - items_.begin());
 }
 
diff --git a/chrome/browser/ui/browser_actions.cc b/chrome/browser/ui/browser_actions.cc
index d65691f1aa1a5..da4fff1f928f7 100644
--- a/chrome/browser/ui/browser_actions.cc
+++ b/chrome/browser/ui/browser_actions.cc
@@ -9,6 +9,7 @@
 #include <string>
 
 #include "base/check_op.h"
+#include "base/command_line.h"
 #include "chrome/app/vector_icons/vector_icons.h"
 #include "chrome/browser/devtools/devtools_window.h"
 #include "chrome/browser/profiles/profile.h"
@@ -410,6 +411,8 @@ void BrowserActions::InitializeBrowserActions() {
     if (IsChromeLabsEnabled()) {
       // TODO(b/354758327): Update `ShouldShowChromeLabsUI()` to not require
       // `model` as a parameter, then use to set visibility of action item.
+      static const bool disable_thorium_icons =
+          base::CommandLine::ForCurrentProcess()->HasSwitch("disable-thorium-icons");
       root_action_item_->AddChild(
           ChromeMenuAction(base::BindRepeating(
                                [](Browser* browser, actions::ActionItem* item,
@@ -418,7 +421,9 @@ void BrowserActions::InitializeBrowserActions() {
                                },
                                base::Unretained(browser)),
                            kActionShowChromeLabs, IDS_CHROMELABS,
-                           IDS_CHROMELABS, kScienceIcon)
+                           IDS_CHROMELABS, disable_thorium_icons
+                                           ? kScienceIcon
+                                           : kScienceThoriumIcon)
               .SetVisible(false)
               .Build());
     }
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index 86af74569f013..1f9cc1696eda4 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -1423,7 +1423,8 @@ void BrowserCommandController::InitCommandState() {
   command_updater_.UpdateCommandEnabled(IDC_WINDOW_CLOSE_OTHER_TABS,
                                         normal_window);
 
-  const bool enable_tab_search_commands = browser_->is_type_normal();
+  const bool enable_tab_search_commands = browser_->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH,
                                         enable_tab_search_commands);
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH_CLOSE,
diff --git a/chrome/browser/ui/color/chrome_color_mixer.cc b/chrome/browser/ui/color/chrome_color_mixer.cc
index 589c77c52175b..28e662fdd8e2f 100644
--- a/chrome/browser/ui/color/chrome_color_mixer.cc
+++ b/chrome/browser/ui/color/chrome_color_mixer.cc
@@ -141,8 +141,7 @@ void AddChromeColorMixer(ui::ColorProvider* provider,
       gfx::kGoogleGrey500, kColorBookmarkBarBackground, 6.0f);
   mixer[kColorBookmarkFolderIcon] = {ui::kColorIcon};
   mixer[kColorBookmarkBarSeparator] = {kColorToolbarSeparator};
-  mixer[kColorBookmarkBarSeparatorChromeRefresh] = {
-      kColorTabBackgroundInactiveFrameActive};
+  mixer[kColorBookmarkBarSeparatorChromeRefresh] = {ui::kColorSysDivider};
   mixer[kColorBookmarkDragImageBackground] = {ui::kColorAccent};
   mixer[kColorBookmarkDragImageCountBackground] = {ui::kColorAlertHighSeverity};
   mixer[kColorBookmarkDragImageCountForeground] =
@@ -748,8 +747,7 @@ void AddChromeColorMixer(ui::ColorProvider* provider,
       ui::SetAlpha(kColorToolbarInkDrop, std::ceil(0.06f * 255.0f));
   mixer[kColorAppMenuChipInkDropHover] = {kColorToolbarInkDropHover};
   mixer[kColorAppMenuChipInkDropRipple] = {kColorToolbarInkDropRipple};
-  mixer[kColorToolbarExtensionSeparatorEnabled] = {
-      kColorTabBackgroundInactiveFrameActive};
+  mixer[kColorToolbarExtensionSeparatorEnabled] = {ui::kColorSysDivider};
   mixer[kColorToolbarExtensionSeparatorDisabled] = {
       kColorToolbarButtonIconInactive};
   mixer[kColorToolbarSeparator] = {kColorToolbarSeparatorDefault};
diff --git a/chrome/browser/ui/color/chrome_color_mixers.cc b/chrome/browser/ui/color/chrome_color_mixers.cc
index 9698e807b11df..8bb6a245caeba 100644
--- a/chrome/browser/ui/color/chrome_color_mixers.cc
+++ b/chrome/browser/ui/color/chrome_color_mixers.cc
@@ -22,6 +22,7 @@
 #include "chrome/browser/ui/color/omnibox_color_mixer.h"
 #include "chrome/browser/ui/color/product_specifications_color_mixer.h"
 #include "chrome/browser/ui/color/tab_strip_color_mixer.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider_utils.h"
 
 namespace {
@@ -59,20 +60,38 @@ void AddChromeColorMixers(ui::ColorProvider* provider,
       chrome_color_provider_utils_callbacks;
   ui::SetColorProviderUtilsCallbacks(
       chrome_color_provider_utils_callbacks.get());
-  AddChromeColorMixer(provider, key);
-  AddNewTabPageColorMixer(provider, key);
-  AddOmniboxColorMixer(provider, key);
-  AddProductSpecificationsColorMixer(provider, key);
-  AddTabStripColorMixer(provider, key);
-
-  AddMaterialChromeColorMixer(provider, key);
-  AddMaterialNewTabPageColorMixer(provider, key);
-  AddMaterialOmniboxColorMixer(provider, key);
-  AddMaterialSidePanelColorMixer(provider, key);
-  AddMaterialTabStripColorMixer(provider, key);
-
-  // Must be the last one in order to override other mixer colors.
-  AddNativeChromeColorMixer(provider, key);
+
+  if (features::IsThorium2024()) {
+    AddMaterialChromeColorMixer(provider, key);
+    AddMaterialNewTabPageColorMixer(provider, key);
+    AddMaterialOmniboxColorMixer(provider, key);
+    AddMaterialSidePanelColorMixer(provider, key);
+    AddMaterialTabStripColorMixer(provider, key);
+
+    AddChromeColorMixer(provider, key);
+    AddNewTabPageColorMixer(provider, key);
+    AddOmniboxColorMixer(provider, key);
+    AddProductSpecificationsColorMixer(provider, key);
+    AddTabStripColorMixer(provider, key);
+
+    // Must be the last one in order to override other mixer colors.
+    AddNativeChromeColorMixer(provider, key);
+  } else {
+    AddChromeColorMixer(provider, key);
+    AddNewTabPageColorMixer(provider, key);
+    AddOmniboxColorMixer(provider, key);
+    AddProductSpecificationsColorMixer(provider, key);
+    AddTabStripColorMixer(provider, key);
+
+    AddMaterialChromeColorMixer(provider, key);
+    AddMaterialNewTabPageColorMixer(provider, key);
+    AddMaterialOmniboxColorMixer(provider, key);
+    AddMaterialSidePanelColorMixer(provider, key);
+    AddMaterialTabStripColorMixer(provider, key);
+
+    // Must be the last one in order to override other mixer colors.
+    AddNativeChromeColorMixer(provider, key);
+  }
 
   if (key.custom_theme) {
     key.custom_theme->AddColorMixers(provider, key);
diff --git a/chrome/browser/ui/color/tab_strip_color_mixer.cc b/chrome/browser/ui/color/tab_strip_color_mixer.cc
index 9faa599b47cc1..d683ac878cb0e 100644
--- a/chrome/browser/ui/color/tab_strip_color_mixer.cc
+++ b/chrome/browser/ui/color/tab_strip_color_mixer.cc
@@ -136,10 +136,7 @@ void AddTabStripColorMixer(ui::ColorProvider* provider,
   // behavior. The main difference is that the tab hover color in GM2 depends on
   // the tab width - narrower tabs have more opacity. We must chooses a single
   // opacity, so we go with one towards the more opaque end of the GM2 range.
-  mixer[kColorTabBackgroundInactiveHoverFrameActive] = {
-      ui::AlphaBlend(kColorTabBackgroundActiveFrameActive,
-                     kColorTabBackgroundInactiveFrameActive,
-                     /* 40% opacity */ 0.4 * SK_AlphaOPAQUE)};
+  mixer[kColorTabBackgroundInactiveHoverFrameActive] = {ui::kColorSysStateHeaderHover};
   mixer[kColorTabBackgroundInactiveHoverFrameInactive] = {
       ui::AlphaBlend(kColorTabBackgroundActiveFrameInactive,
                      kColorTabBackgroundInactiveFrameInactive,
diff --git a/chrome/browser/ui/frame/window_frame_util.h b/chrome/browser/ui/frame/window_frame_util.h
index e4ccd7fab5421..0eadd6bdd8def 100644
--- a/chrome/browser/ui/frame/window_frame_util.h
+++ b/chrome/browser/ui/frame/window_frame_util.h
@@ -11,6 +11,8 @@ namespace gfx {
 class Size;
 }
 
+class Browser;
+
 // Static-only class containing values and helper functions for frame classes
 // that need to be accessible outside of /browser/ui/views.
 class WindowFrameUtil {
diff --git a/chrome/browser/ui/layout_constants.cc b/chrome/browser/ui/layout_constants.cc
index 87c4ee64068a6..d900607d59819 100644
--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -7,6 +7,7 @@
 #include "base/feature_list.h"
 #include "base/notreached.h"
 #include "build/build_config.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "components/omnibox/common/omnibox_features.h"
@@ -20,24 +21,31 @@
 
 int GetLayoutConstant(LayoutConstant constant) {
   const bool touch_ui = ui::TouchUiController::Get()->touch_ui();
+  static const bool classic_omnibox =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
   switch (constant) {
     case APP_MENU_PROFILE_ROW_AVATAR_ICON_SIZE:
-      return 24;
+      return features::IsThorium2024() ? 16 : 24;
     case APP_MENU_MAXIMUM_CHARACTER_LENGTH:
-      return 30;
+      return features::IsThorium2024() ? 28 : 30;
     case BOOKMARK_BAR_HEIGHT: {
       // The fixed margin ensures the bookmark buttons appear centered relative
       // to the white space above and below.
-      const int bookmark_bar_attached_vertical_margin = 6;
+      const int bookmark_bar_attached_vertical_margin = features::IsThorium2024() ? 3 : 6;
       return GetLayoutConstant(BOOKMARK_BAR_BUTTON_HEIGHT) +
              bookmark_bar_attached_vertical_margin;
     }
-    case BOOKMARK_BAR_BUTTON_HEIGHT:
-      return touch_ui ? 36 : 28;
+    case BOOKMARK_BAR_BUTTON_HEIGHT: {
+      if (features::IsThorium2024()) {
+        return touch_ui ? 34 : 26;
+      } else {
+        return touch_ui ? 36 : 28;
+      }
+    }
     case BOOKMARK_BAR_BUTTON_PADDING:
-      return GetLayoutConstant(TOOLBAR_ELEMENT_PADDING);
+      return features::IsThorium2024() ? 2 : GetLayoutConstant(TOOLBAR_ELEMENT_PADDING);
     case BOOKMARK_BAR_BUTTON_IMAGE_LABEL_PADDING:
-      return 6;
+      return features::IsThorium2024() ? 6 : 6;
     case WEB_APP_MENU_BUTTON_SIZE:
       return 24;
     case WEB_APP_PAGE_ACTION_ICON_SIZE:
@@ -51,7 +59,7 @@ int GetLayoutConstant(LayoutConstant constant) {
     case LOCATION_BAR_CHILD_INTERIOR_PADDING:
       return 3;
     case LOCATION_BAR_CHILD_CORNER_RADIUS:
-      return 12;
+      return classic_omnibox ? 4 : 12;
     case LOCATION_BAR_CHIP_ICON_SIZE:
       return 16;
     case LOCATION_BAR_CHIP_PADDING:
@@ -59,41 +67,69 @@ int GetLayoutConstant(LayoutConstant constant) {
     case LOCATION_BAR_ELEMENT_PADDING:
       return touch_ui ? 3 : 2;
     case LOCATION_BAR_PAGE_INFO_ICON_VERTICAL_PADDING:
-      return touch_ui ? 3 : 5;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 3 : 4;
+      } else {
+        return touch_ui ? 3 : 5;
+      }
     case LOCATION_BAR_LEADING_DECORATION_EDGE_PADDING:
       // TODO(manukh): See comment in `LocationBarView::Layout()`. We have too
       //   many feature permutations that would affect this and other layout
       //   constants, so instead of spreading the permutation logic here and
       //   elsewhere, it's consolidated in `Layout()` and will be moved back
       //   here once we decide on a permutation.
-      NOTREACHED();
+      if (features::IsThorium2024()) {
+        return touch_ui ? 3 : 4;
+      } else {
+        return touch_ui ? 3 : 5;
+      }
     case LOCATION_BAR_TRAILING_DECORATION_EDGE_PADDING:
-      return touch_ui ? 3 : 12;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 3 : 6;
+      } else {
+        return touch_ui ? 3 : 12;
+      }
     case LOCATION_BAR_TRAILING_DECORATION_INNER_PADDING:
-      return touch_ui ? 3 : 8;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 3 : 6;
+      } else {
+        return touch_ui ? 3 : 8;
+      }
     case LOCATION_BAR_HEIGHT:
-      return touch_ui ? 36 : 34;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 34 : 30;
+      } else {
+        return touch_ui ? 36 : 34;
+      }
     case LOCATION_BAR_ICON_SIZE:
       return touch_ui ? 20 : 16;
     case LOCATION_BAR_LEADING_ICON_SIZE:
       return GetLayoutConstant(LOCATION_BAR_ICON_SIZE);
     case LOCATION_BAR_TRAILING_ICON_SIZE:
-      return 20;
+      return features::IsThorium2024() ? 20 : 20;
     case TAB_AFTER_TITLE_PADDING:
       return touch_ui ? 8 : 4;
     case TAB_ALERT_INDICATOR_CAPTURE_ICON_WIDTH:
       return 16;
     case TAB_ALERT_INDICATOR_ICON_WIDTH:
       return touch_ui ? 12 : 16;
+    case TAB_BUTTON_OFFSET:
+      return features::IsThorium2024() ? -1 : 0;
     case TAB_CLOSE_BUTTON_SIZE:
-      return touch_ui ? 24 : 16;
+      return touch_ui ? 24 : 18;
     case TAB_HEIGHT:
       return 34 + GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
     case TAB_STRIP_HEIGHT:
       return GetLayoutConstant(TAB_HEIGHT) +
              GetLayoutConstant(TAB_STRIP_PADDING);
     case TAB_STRIP_PADDING:
-      return 6;
+      return features::IsThorium2024() ? 0 : 6;
+    case TAB_MARGIN:
+      return features::IsThorium2024() ? 6 : 6;
+    case TAB_INACTIVE_PADDING:
+      return features::IsThorium2024() ? 3 : 6;
+    case TAB_SEARCH_PADDING:
+      return features::IsThorium2024() ? 3 : 6;
     case TAB_SEPARATOR_HEIGHT:
       return touch_ui ? 24 : 20;
     case TAB_PRE_TITLE_PADDING:
@@ -108,27 +144,43 @@ int GetLayoutConstant(LayoutConstant constant) {
       }
       return 1;
     case TOOLBAR_BUTTON_HEIGHT:
-      return touch_ui ? 48 : 34;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 46 : 30;
+      } else {
+        return touch_ui ? 48 : 34;
+      }
     case TOOLBAR_DIVIDER_CORNER_RADIUS:
-      return 1;
+      return 1.0f;
     case TOOLBAR_DIVIDER_HEIGHT:
-      return touch_ui ? 20 : 16;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 20 : 18;
+      } else {
+        return touch_ui ? 20 : 16;
+      }
     case TOOLBAR_DIVIDER_SPACING:
-      return 9;
+      return features::IsThorium2024() ? 7 : 9;
     case TOOLBAR_DIVIDER_WIDTH:
       return 2;
     case TOOLBAR_ELEMENT_PADDING:
       return touch_ui ? 0 : 4;
     case TOOLBAR_ICON_DEFAULT_MARGIN:
-      return touch_ui ? 0 : 2;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 2 : 2;
+      } else {
+        return touch_ui ? 0 : 2;
+      }
     case TOOLBAR_STANDARD_SPACING:
-      return touch_ui ? 12 : 9;
+      if (features::IsThorium2024()) {
+        return touch_ui ? 12 : 7;
+      } else {
+       return touch_ui ? 12 : 9;
+      }
     case PAGE_INFO_ICON_SIZE:
-      return 20;
+      return features::IsThorium2024() ? 18 : 20;
     case DOWNLOAD_ICON_SIZE:
-      return 20;
+      return features::IsThorium2024() ? 18 : 20;
     case TOOLBAR_CORNER_RADIUS:
-      return 8;
+      return 0;
     default:
       break;
   }
@@ -143,10 +195,14 @@ gfx::Insets GetLayoutInsets(LayoutInset inset) {
       return gfx::Insets(4);
 
     case DOWNLOAD_ROW:
-      return gfx::Insets::VH(8, 20);
+      return gfx::Insets::VH(8, features::IsThorium2024() ? 18 : 20);
 
     case LOCATION_BAR_ICON_INTERIOR_PADDING:
-      return gfx::Insets::VH(2, 2);
+      if (features::IsThorium2024()) {
+        return touch_ui ? gfx::Insets::VH(5, 10) : gfx::Insets::VH(4, 4);
+      } else {
+        return touch_ui ? gfx::Insets::VH(2, 4) : gfx::Insets::VH(2, 2);
+      }
 
     case LOCATION_BAR_PAGE_INFO_ICON_PADDING:
       return touch_ui ? gfx::Insets::VH(5, 10) : gfx::Insets::VH(4, 4);
@@ -161,27 +217,36 @@ gfx::Insets GetLayoutInsets(LayoutInset inset) {
     }
 
     case TOOLBAR_BUTTON:
-      return gfx::Insets(touch_ui ? 12 : 7);
+      return gfx::Insets(touch_ui ? 12
+                                  : (features::IsThorium2024() ? 6 : 7));
 
     case BROWSER_APP_MENU_CHIP_PADDING:
-      if (touch_ui) {
+      if (touch_ui || features::IsThorium2024()) {
         return GetLayoutInsets(TOOLBAR_BUTTON);
       } else {
         return gfx::Insets::TLBR(7, 4, 7, 6);
       }
 
     case AVATAR_CHIP_PADDING:
-      if (touch_ui) {
+      if (touch_ui || features::IsThorium2024()) {
         return GetLayoutInsets(TOOLBAR_BUTTON);
       } else {
         return gfx::Insets::TLBR(7, 10, 7, 4);
       }
 
     case TOOLBAR_INTERIOR_MARGIN:
-      return touch_ui ? gfx::Insets() : gfx::Insets::VH(6, 5);
+      if (features::IsThorium2024()) {
+        return touch_ui ? gfx::Insets() : gfx::Insets::VH(3, 6);
+      } else {
+        return touch_ui ? gfx::Insets() : gfx::Insets::VH(6, 5);
+      }
 
     case WEBUI_TAB_STRIP_TOOLBAR_INTERIOR_MARGIN:
-      return gfx::Insets::VH(4, 0);
+      if (features::IsThorium2024()) {
+        return gfx::Insets::VH(4, 6);
+      } else {
+        return gfx::Insets::VH(4, 0);
+      }
   }
   NOTREACHED_IN_MIGRATION();
   return gfx::Insets();
diff --git a/chrome/browser/ui/layout_constants.h b/chrome/browser/ui/layout_constants.h
index a35795ee8cc11..60577ba01a5fd 100644
--- a/chrome/browser/ui/layout_constants.h
+++ b/chrome/browser/ui/layout_constants.h
@@ -123,9 +123,21 @@ enum LayoutConstant {
   // detached tab, and on all sides of the controls padding.
   TAB_STRIP_PADDING,
 
+  // For the tab margins
+  TAB_MARGIN,
+
+  // For inactive tab padding
+  TAB_INACTIVE_PADDING,
+
   // The height of a separator in the tabstrip.
   TAB_SEPARATOR_HEIGHT,
 
+  // Padding for the tab search button
+  TAB_SEARCH_PADDING,
+
+  // Offset y for new tab button
+  TAB_BUTTON_OFFSET,
+
   // Padding before the tab title.
   TAB_PRE_TITLE_PADDING,
 
diff --git a/chrome/browser/ui/omnibox/omnibox_pedal_implementations.cc b/chrome/browser/ui/omnibox/omnibox_pedal_implementations.cc
index 3ae6b02a62d64..63ef3fc6483fb 100644
--- a/chrome/browser/ui/omnibox/omnibox_pedal_implementations.cc
+++ b/chrome/browser/ui/omnibox/omnibox_pedal_implementations.cc
@@ -12,6 +12,7 @@
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/shell_integration.h"
 #include "chrome/common/chrome_features.h"
+#include "chrome/common/thorium_2024.h"
 #include "chrome/common/webui_url_constants.h"
 #include "components/omnibox/browser/actions/omnibox_pedal.h"
 #include "components/omnibox/browser/autocomplete_input.h"
@@ -1972,14 +1973,18 @@ class OmniboxPedalSetChromeAsDefaultBrowser : public OmniboxPedal {
 // =============================================================================
 
 const gfx::VectorIcon& GetSharingHubVectorIcon() {
+  const bool thorium_2024 = features::IsThorium2024();
 #if BUILDFLAG(IS_MAC)
   return omnibox::kShareMacChromeRefreshIcon;
 #elif BUILDFLAG(IS_WIN)
-  return omnibox::kShareWinChromeRefreshIcon;
+  return thorium_2024 ? omnibox::kShareChromeRefreshIcon
+                      : omnibox::kShareWinChromeRefreshIcon;
 #elif BUILDFLAG(IS_LINUX)
-  return omnibox::kShareLinuxChromeRefreshIcon;
+  return thorium_2024 ? omnibox::kShareChromeRefreshIcon
+                      : omnibox::kShareLinuxChromeRefreshIcon;
 #else
-  return omnibox::kShareChromeRefreshIcon;
+  return thorium_2024 ? omnibox::kShareIcon
+                      : omnibox::kShareChromeRefreshIcon;
 #endif
 }
 
diff --git a/chrome/browser/ui/status_bubble.h b/chrome/browser/ui/status_bubble.h
index 74a00df155806..c8e4a81911d80 100644
--- a/chrome/browser/ui/status_bubble.h
+++ b/chrome/browser/ui/status_bubble.h
@@ -18,7 +18,7 @@ class GURL;
 class StatusBubble {
  public:
   // On hover, expand status bubble to fit long URL after this delay.
-  static const int kExpandHoverDelayMS = 1600;
+  static const int kExpandHoverDelayMS = 1;
 
   virtual ~StatusBubble() {}
 
diff --git a/chrome/browser/ui/tabs/tab_menu_model.cc b/chrome/browser/ui/tabs/tab_menu_model.cc
index fba81d1815359..88415257b897c 100644
--- a/chrome/browser/ui/tabs/tab_menu_model.cc
+++ b/chrome/browser/ui/tabs/tab_menu_model.cc
@@ -105,6 +105,10 @@ void TabMenuModel::Build(TabStripModel* tab_strip, int index) {
   AddItemWithStringId(TabStripModel::CommandNewTabToRight,
                       base::i18n::IsRTL() ? IDS_TAB_CXMENU_NEWTABTOLEFT
                                           : IDS_TAB_CXMENU_NEWTABTORIGHT);
+  AddItemWithStringId(TabStripModel::CommandNewTabToLeft,
+                      base::i18n::IsRTL() ? IDS_TAB_CXMENU_NEWTABTORIGHT
+                                          : IDS_TAB_CXMENU_NEWTABTOLEFT);
+  //AddItemWithStringId(IDC_RESTORE_TAB, IDS_RESTORE_TAB);
   if (tab_strip->delegate()->SupportsReadLater()) {
     AddItem(
         TabStripModel::CommandAddToReadLater,
diff --git a/chrome/browser/ui/tabs/tab_strip_model.cc b/chrome/browser/ui/tabs/tab_strip_model.cc
index 91513d4488166..4fa0ac198e9c6 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.cc
+++ b/chrome/browser/ui/tabs/tab_strip_model.cc
@@ -1298,6 +1298,7 @@ bool TabStripModel::IsContextMenuCommandEnabled(
     ContextMenuCommand command_id) const {
   DCHECK(command_id > CommandFirst && command_id < CommandLast);
   switch (command_id) {
+    case CommandNewTabToLeft:
     case CommandNewTabToRight:
     case CommandCloseTab:
       return true;
@@ -1399,6 +1400,16 @@ void TabStripModel::ExecuteContextMenuCommand(int context_index,
   if (!ContainsIndex(context_index))
     return;
   switch (command_id) {
+
+    case CommandNewTabToLeft: {
+      base::RecordAction(UserMetricsAction("TabContextMenu_NewTab"));
+      UMA_HISTOGRAM_ENUMERATION("Tab.NewTab", NewTabTypes::NEW_TAB_CONTEXT_MENU,
+                                NewTabTypes::NEW_TAB_ENUM_COUNT);
+      delegate()->AddTabAt(GURL(), context_index, true,
+                           GetTabGroupForTab(context_index));
+      break;
+    }
+
     case CommandNewTabToRight: {
       base::RecordAction(UserMetricsAction("TabContextMenu_NewTab"));
       UMA_HISTOGRAM_ENUMERATION("Tab.NewTab", NewTabTypes::NEW_TAB_CONTEXT_MENU,
diff --git a/chrome/browser/ui/tabs/tab_strip_model.h b/chrome/browser/ui/tabs/tab_strip_model.h
index 4d900c4a7f58c..8daa4634abeaf 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -545,6 +545,7 @@ class TabStripModel : public TabGroupController {
   // for entries in the 'Add to existing group' submenu.
   enum ContextMenuCommand {
     CommandFirst,
+    CommandNewTabToLeft,
     CommandNewTabToRight,
     CommandReload,
     CommandDuplicate,
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index d48223986946d..9e5df278ea2b6 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -11,6 +11,7 @@
 
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/tabs/features.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider.h"
@@ -21,13 +22,18 @@ namespace {
 
 // Thickness in DIPs of the separator painted on the left and right edges of
 // the tab.
+constexpr int kThoriumSeparatorThickness = 2;
 constexpr int kChromeRefreshSeparatorThickness = 2;
+constexpr float kThoriumSeparatorHorizontalMargin = 0.0f;
 constexpr int kChromeRefreshSeparatorHorizontalMargin = 2;
 // TODO (crbug.com/1451400): This constant should be in LayoutConstants.
+constexpr int kThoriumSeparatorHeight = 20;
 constexpr int kChromeRefreshSeparatorHeight = 16;
 
 // The padding from the top of the tab to the content area.
+constexpr int kThoriumTabVerticalPadding = 9;
 constexpr int kChromeRefreshTabVerticalPadding = 6;
+constexpr int kThoriumTabHorizontalPadding = 6;
 constexpr int kChromeRefreshTabHorizontalPadding = 8;
 
 class ChromeRefresh2023TabStyle : public TabStyle {
@@ -59,8 +65,28 @@ class ChromeRefresh2023TabStyle : public TabStyle {
 TabStyle::~TabStyle() = default;
 
 int ChromeRefresh2023TabStyle::GetStandardWidth() const {
+
+  const std::string custom_tab_width = base::CommandLine::ForCurrentProcess()->
+                                       GetSwitchValueASCII("custom-tab-width");
+  int kTabWidthValue;
+  if (custom_tab_width == "60") {
+    kTabWidthValue = 60;
+  } else if (custom_tab_width == "120") {
+    kTabWidthValue = 120;
+  } else if (custom_tab_width == "180") {
+    kTabWidthValue = 180;
+  } else if (custom_tab_width == "240") {
+    kTabWidthValue = 240;
+  } else if (custom_tab_width == "300") {
+    kTabWidthValue = 300;
+  } else if (custom_tab_width == "400") {
+    kTabWidthValue = 400;
+  } else {
+    kTabWidthValue = 240;
+  }
+
   // The standard tab width is 240 DIP including both separators.
-  constexpr int kTabWidth = 240;
+  const int kTabWidth = kTabWidthValue;
   // The overlap includes one separator, so subtract it here.
   return kTabWidth + GetTabOverlap() - GetSeparatorSize().width();
 }
@@ -107,19 +133,42 @@ int ChromeRefresh2023TabStyle::GetMinimumInactiveWidth() const {
 }
 
 int ChromeRefresh2023TabStyle::GetTopCornerRadius() const {
-  return 10;
+  static const bool rectangular_tabs =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs");
+  if (features::IsThorium2024() && !rectangular_tabs) {
+    return 8;
+  } else if ((rectangular_tabs && features::IsThorium2024()) || (rectangular_tabs && !features::IsThorium2024())) {
+    return 4;
+  } else {
+    return 10;
+  }
 }
 
 int ChromeRefresh2023TabStyle::GetBottomCornerRadius() const {
-  return 12;
+  static const bool rectangular_tabs =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs");
+  if (features::IsThorium2024() && !rectangular_tabs) {
+    return 8;
+  } else if ((rectangular_tabs && features::IsThorium2024()) || (rectangular_tabs && !features::IsThorium2024())) {
+    return 4;
+  } else {
+    return 12;
+  }
 }
 
 int ChromeRefresh2023TabStyle::GetTabOverlap() const {
   // The overlap removes the width and the margins of the separator.
-  const float total_separator_width = GetSeparatorMargins().left() +
-                                      GetSeparatorSize().width() +
-                                      GetSeparatorMargins().right();
-  return 2 * GetBottomCornerRadius() - total_separator_width;
+  if (features::IsThorium2024()) {
+    const float total_separator_width = GetSeparatorMargins().left() +
+                                        GetSeparatorSize().width() +
+                                        GetSeparatorMargins().right();
+    return 2 * GetBottomCornerRadius() - total_separator_width;
+  } else {
+    const float total_separator_width = GetSeparatorMargins().left() +
+                                        GetSeparatorSize().width() +
+                                        GetSeparatorMargins().right();
+    return 2 * GetBottomCornerRadius() - total_separator_width;
+  }
 }
 
 gfx::Size ChromeRefresh2023TabStyle::GetPreviewImageSize() const {
@@ -129,23 +178,43 @@ gfx::Size ChromeRefresh2023TabStyle::GetPreviewImageSize() const {
 }
 
 gfx::Size ChromeRefresh2023TabStyle::GetSeparatorSize() const {
-  return gfx::Size(kChromeRefreshSeparatorThickness,
-                   kChromeRefreshSeparatorHeight);
+  if (features::IsThorium2024()) {
+    return gfx::Size(kThoriumSeparatorThickness,
+                     kThoriumSeparatorHeight);
+  } else {
+    return gfx::Size(kChromeRefreshSeparatorThickness,
+                     kChromeRefreshSeparatorHeight);
+  }
 }
 
 gfx::Insets ChromeRefresh2023TabStyle::GetSeparatorMargins() const {
-  return gfx::Insets::TLBR(GetLayoutConstant(TAB_STRIP_PADDING),
-                           kChromeRefreshSeparatorHorizontalMargin,
-                           GetLayoutConstant(TAB_STRIP_PADDING),
-                           kChromeRefreshSeparatorHorizontalMargin);
+  if (features::IsThorium2024()) {
+    return gfx::Insets::TLBR(GetLayoutConstant(TAB_INACTIVE_PADDING),
+                             kThoriumSeparatorHorizontalMargin,
+                             GetLayoutConstant(TAB_INACTIVE_PADDING),
+                             kThoriumSeparatorHorizontalMargin);
+  } else {
+    return gfx::Insets::TLBR(GetLayoutConstant(TAB_STRIP_PADDING),
+                             kChromeRefreshSeparatorHorizontalMargin,
+                             GetLayoutConstant(TAB_STRIP_PADDING),
+                             kChromeRefreshSeparatorHorizontalMargin);
+  }
 }
 
 int ChromeRefresh2023TabStyle::GetSeparatorCornerRadius() const {
-  return GetSeparatorSize().width() / 2;
+  if (features::IsThorium2024()) {
+    return 0;
+  } else {
+    return GetSeparatorSize().width() / 2;
+  }
 }
 
 int ChromeRefresh2023TabStyle::GetDragHandleExtension(int height) const {
-  return 6;
+  if (features::IsThorium2024()) {
+    return (height - GetSeparatorSize().height()) / 2 - 1;
+  } else {
+    return 6;
+  }
 }
 
 SkColor ChromeRefresh2023TabStyle::GetTabBackgroundColor(
@@ -182,11 +251,19 @@ SkColor ChromeRefresh2023TabStyle::GetTabBackgroundColor(
 }
 
 gfx::Insets ChromeRefresh2023TabStyle::GetContentsInsets() const {
-  return gfx::Insets::TLBR(
-      kChromeRefreshTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
-      GetBottomCornerRadius() + kChromeRefreshTabHorizontalPadding,
-      kChromeRefreshTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
-      GetBottomCornerRadius() + kChromeRefreshTabHorizontalPadding);
+  if (features::IsThorium2024()) {
+    return gfx::Insets::TLBR(
+       kThoriumTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
+       GetBottomCornerRadius() + kThoriumTabHorizontalPadding,
+       kThoriumTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
+       GetBottomCornerRadius() + kThoriumTabHorizontalPadding);
+  } else {
+    return gfx::Insets::TLBR(
+       kChromeRefreshTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
+       GetBottomCornerRadius() + kChromeRefreshTabHorizontalPadding,
+       kChromeRefreshTabVerticalPadding + GetLayoutConstant(TAB_STRIP_PADDING),
+       GetBottomCornerRadius() + kChromeRefreshTabHorizontalPadding);
+  }
 }
 
 float ChromeRefresh2023TabStyle::GetSelectedTabOpacity() const {
diff --git a/chrome/browser/ui/thorium_2024.h b/chrome/browser/ui/thorium_2024.h
new file mode 100644
index 0000000000000..de40b42fcc722
--- /dev/null
+++ b/chrome/browser/ui/thorium_2024.h
@@ -0,0 +1,14 @@
+// Copyright 2024 Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_THORIUM_2024_UI_H_
+#define CHROME_BROWSER_UI_THORIUM_2024_UI_H_
+
+#include "base/command_line.h"
+#include "ui/base/ui_base_features.h"
+
+// Blanking out until moving file to //ui/base
+//static const bool thor24 = features::IsThorium2024();
+
+#endif  // CHROME_BROWSER_UI_THORIUM_2024_UI_H_
diff --git a/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_model.cc b/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_model.cc
index 6a91493f7c2bc..fdeb2a4a0916e 100644
--- a/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_model.cc
+++ b/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_model.cc
@@ -49,6 +49,38 @@ const std::vector<LabInfo>& GetData() {
         l10n_util::GetStringUTF16(IDS_TABS_SHRINK_TO_LARGE_WIDTH),
         l10n_util::GetStringUTF16(IDS_TABS_DO_NOT_SHRINK)};
 
+    const char kThorium2024FlagId[] = "thorium-2024";
+    const std::u16string kThorium2024FlagName = u"Enable Thorium 2024 UI";
+    const std::u16string kThorium2024FlagDescription = u"Enable an experimental UI, which restores many parts of the pre-Chrome Refresh 2023 UI.";
+
+    lab_info.emplace_back(
+        kThorium2024FlagId,
+        kThorium2024FlagName,
+        kThorium2024FlagDescription,
+        "chrome-labs-thorium-2024", version_info::Channel::BETA);
+
+    const char kRestoreTabsFlagId[] = "restore-tab-button";
+    const std::u16string kRestoreTabsFlagName = u"Restore Tab Button";
+    const std::u16string kRestoreTabsFlagDescription = u"Enable a new toolbar button to restore your recently closed tabs.";
+
+    lab_info.emplace_back(
+        kRestoreTabsFlagId,
+        kRestoreTabsFlagName,
+        kRestoreTabsFlagDescription,
+        "chrome-labs-restore-tab-button", version_info::Channel::BETA);
+
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
+    const char kMiddleScrollFlagId[] = "middle-click-autoscroll";
+    const std::u16string kMiddleScrollFlagName = u"Middle Click Autoscroll";
+    const std::u16string kMiddleScrollFlagDescription = u"Enables autoscrolling when the middle mouse button is pressed.";
+
+    lab_info.emplace_back(
+        kMiddleScrollFlagId,
+        kMiddleScrollFlagName,
+        kMiddleScrollFlagDescription,
+        "chrome-labs-middle-click-autoscroll", version_info::Channel::BETA);
+#endif
+
     lab_info.emplace_back(
         flag_descriptions::kScrollableTabStripFlagId,
         l10n_util::GetStringUTF16(IDS_TAB_SCROLLING_EXPERIMENT_NAME),
diff --git a/chrome/browser/ui/view_ids.h b/chrome/browser/ui/view_ids.h
index fb9afeed5a60e..7b47ee8281b99 100644
--- a/chrome/browser/ui/view_ids.h
+++ b/chrome/browser/ui/view_ids.h
@@ -16,6 +16,7 @@ enum ViewID {
 
   // Views which make up the skyline. These are used only
   // on views.
+  VIEW_ID_TAB_SEARCH_BUTTON,
   VIEW_ID_MINIMIZE_BUTTON,
   VIEW_ID_MAXIMIZE_BUTTON,
   VIEW_ID_RESTORE_BUTTON,
@@ -51,6 +52,7 @@ enum ViewID {
   VIEW_ID_FORWARD_BUTTON,
   VIEW_ID_RELOAD_BUTTON,
   VIEW_ID_HOME_BUTTON,
+  VIEW_ID_RESTORE_TAB_BUTTON,
   VIEW_ID_STAR_BUTTON,
   VIEW_ID_EXTENSIONS_MENU_BUTTON,
   VIEW_ID_APP_MENU,
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
index 9cecb25b41d3b..a0662f288a022 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
@@ -56,6 +56,7 @@
 #include "chrome/browser/ui/tabs/saved_tab_groups/saved_tab_group_utils.h"
 #include "chrome/browser/ui/tabs/saved_tab_groups/tab_group_sync_service_proxy.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/view_ids.h"
 #include "chrome/browser/ui/views/bookmarks/bookmark_bar_view_observer.h"
@@ -339,8 +340,8 @@ class BookmarkBarView::ButtonSeparatorView : public views::Separator {
 
  public:
   ButtonSeparatorView() {
-    const int leading_padding = 8;
-    const int trailing_padding = 8;
+    const int leading_padding = features::IsThorium2024() ? 4 : 8;
+    const int trailing_padding = features::IsThorium2024() ? 3 : 8; // 4
     separator_thickness_ = kBookmarkBarSeparatorThickness;
     const gfx::Insets border_insets =
         gfx::Insets::TLBR(0, leading_padding, 0, trailing_padding);
@@ -571,8 +572,15 @@ void BookmarkBarView::GetAnchorPositionForButton(
 }
 
 int BookmarkBarView::GetLeadingMargin() const {
-  static constexpr int kBookmarksBarLeadingMarginWithoutSavedTabGroups = 6;
-  static constexpr int kBookmarksBarLeadingMarginWithSavedTabGroups = 12;
+  int kBookmarksBarLeadingMarginWithoutSavedTabGroups;
+  int kBookmarksBarLeadingMarginWithSavedTabGroups;
+  if (features::IsThorium2024()) {
+    kBookmarksBarLeadingMarginWithoutSavedTabGroups = 9;
+    kBookmarksBarLeadingMarginWithSavedTabGroups = 15;
+  } else {
+    kBookmarksBarLeadingMarginWithoutSavedTabGroups = 6;
+    kBookmarksBarLeadingMarginWithSavedTabGroups = 12;
+  }
 
   if (saved_tab_groups_separator_view_ &&
       saved_tab_groups_separator_view_->GetVisible()) {
@@ -702,7 +710,7 @@ void BookmarkBarView::Layout(PassKey) {
   }
 
   int x = GetLeadingMargin();
-  static constexpr int kBookmarkBarTrailingMargin = 8;
+  static const int kBookmarkBarTrailingMargin = features::IsThorium2024() ? 0 : 8;
   int width = View::width() - x - kBookmarkBarTrailingMargin;
 
   const int button_height = GetLayoutConstant(BOOKMARK_BAR_BUTTON_HEIGHT);
@@ -902,6 +910,9 @@ void BookmarkBarView::Layout(PassKey) {
   x = max_x + bookmark_bar_button_padding;
 
   // The overflow button.
+  if (features::IsThorium2024() && all_bookmarks_button_->GetVisible()) {
+    x -= 10;
+  }
   overflow_button_->SetBounds(x, y, overflow_pref.width(), button_height);
   overflow_button_->SetVisible(show_bookmarks_overflow);
   x += overflow_pref.width();
diff --git a/chrome/browser/ui/views/chrome_layout_provider.cc b/chrome/browser/ui/views/chrome_layout_provider.cc
index 9b189df8d8ffd..83bee2c7bac9a 100644
--- a/chrome/browser/ui/views/chrome_layout_provider.cc
+++ b/chrome/browser/ui/views/chrome_layout_provider.cc
@@ -7,9 +7,11 @@
 #include <algorithm>
 
 #include "base/feature_list.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "chrome/browser/ui/views/chrome_typography.h"
 #include "components/omnibox/common/omnibox_features.h"
 #include "ui/base/pointer/touch_ui_controller.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/shadow_value.h"
 
 namespace {
@@ -47,10 +49,12 @@ gfx::Insets ChromeLayoutProvider::GetInsetsMetric(int metric) const {
   switch (metric) {
     case views::INSETS_DIALOG:
     case views::INSETS_DIALOG_SUBSECTION: {
-      return gfx::Insets::VH(20, 20);
+      return features::IsThorium2024() ? gfx::Insets(16)
+                                       : gfx::Insets::VH(20, 20);
     }
     case views::INSETS_DIALOG_FOOTNOTE: {
-      return gfx::Insets::TLBR(10, 20, 15, 20);
+      return features::IsThorium2024() ? gfx::Insets(16)
+                                       : gfx::Insets::TLBR(10, 20, 15, 20);
     }
     case views::INSETS_CHECKBOX_RADIO_BUTTON: {
       gfx::Insets insets = LayoutProvider::GetInsetsMetric(metric);
@@ -76,7 +80,10 @@ gfx::Insets ChromeLayoutProvider::GetInsetsMetric(int metric) const {
     case INSETS_PAGE_INFO_HOVER_BUTTON: {
       const gfx::Insets insets =
           LayoutProvider::GetInsetsMetric(views::INSETS_LABEL_BUTTON);
-      const int horizontal_padding = 20;
+      const int horizontal_padding =
+          features::IsThorium2024()
+              ? 16
+              : 20;
       // Hover button in page info requires double the height compared to the
       // label button because it behaves like a menu control.
       return gfx::Insets::VH(insets.height(), horizontal_padding);
@@ -103,7 +110,7 @@ int ChromeLayoutProvider::GetDistanceMetric(int metric) const {
     case DISTANCE_EXTENSIONS_MENU_WIDTH:
       return kMediumDialogWidth;
     case DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SIZE:
-      return 20;
+      return features::IsThorium2024() ? 16 : 20;
     case DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SMALL_SIZE:
       return 16;
     case DISTANCE_EXTENSIONS_MENU_EXTENSION_ICON_SIZE:
@@ -141,7 +148,7 @@ int ChromeLayoutProvider::GetDistanceMetric(int metric) const {
     case DISTANCE_BETWEEN_PRIMARY_AND_SECONDARY_LABELS_HORIZONTAL:
       return 24;
     case DISTANCE_OMNIBOX_CELL_VERTICAL_PADDING:
-      return 12;
+      return features::IsThorium2024() ? 8 : 12;
     case DISTANCE_OMNIBOX_TWO_LINE_CELL_VERTICAL_PADDING:
       return 4;
     case DISTANCE_SIDE_PANEL_HEADER_VECTOR_ICON_SIZE:
@@ -151,17 +158,19 @@ int ChromeLayoutProvider::GetDistanceMetric(int metric) const {
     case DISTANCE_SIDE_PANEL_HEADER_INTERIOR_MARGIN_HORIZONTAL:
       return 4;
     case DISTANCE_HORIZONTAL_SEPARATOR_PADDING_PAGE_INFO_VIEW:
-      return 20;
+      return features::IsThorium2024() ? 4 : 20;
     case DISTANCE_INFOBAR_HORIZONTAL_ICON_LABEL_PADDING:
-      return 16;
+      return features::IsThorium2024() ? 12 : 16;
     case DISTANCE_INFOBAR_HEIGHT:
       // Spec says height of button should be 36dp, vertical padding on both
-      // top and bottom should be 8dp.
-      return 36 + 2 * 8;
+      // top and bottom should be 8dp, 2dp in Th24 case + 1px top padding.
+      return features::IsThorium2024()
+                 ? 36 + 1 + 2 * 2
+                 : 36 + 2 * 8;
     case DISTANCE_PERMISSION_PROMPT_HORIZONTAL_ICON_LABEL_PADDING:
-      return 8;
+      return features::IsThorium2024() ? 12 : 8;
     case DISTANCE_RICH_HOVER_BUTTON_ICON_HORIZONTAL:
-      return 8;
+      return features::IsThorium2024() ? 12 : 8;
     case DISTANCE_TOAST_BUBBLE_BETWEEN_CHILD_SPACING:
       return 4;
     case DISTANCE_TOAST_BUBBLE_BETWEEN_LABEL_ACTION_BUTTON_SPACING:
diff --git a/chrome/browser/ui/views/download/bubble/download_bubble_primary_view.cc b/chrome/browser/ui/views/download/bubble/download_bubble_primary_view.cc
index 147193abed0f0..3a4acb12b6d5f 100644
--- a/chrome/browser/ui/views/download/bubble/download_bubble_primary_view.cc
+++ b/chrome/browser/ui/views/download/bubble/download_bubble_primary_view.cc
@@ -21,6 +21,7 @@
 #include "components/vector_icons/vector_icons.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider.h"
 #include "ui/views/background.h"
 #include "ui/views/border.h"
@@ -129,8 +130,9 @@ void DownloadBubblePrimaryView::MaybeAddOtrInfoRow(Browser* browser) {
 }
 
 int DownloadBubblePrimaryView::DefaultPreferredWidth() const {
-  return ChromeLayoutProvider::Get()->GetDistanceMetric(
-      views::DISTANCE_BUBBLE_PREFERRED_WIDTH);
+  return ChromeLayoutProvider::Get()->GetDistanceMetric(features::IsThorium2024()
+      ? views::DISTANCE_MODAL_DIALOG_PREFERRED_WIDTH
+      : views::DISTANCE_BUBBLE_PREFERRED_WIDTH);
 }
 
 DownloadBubbleRowView* DownloadBubblePrimaryView::GetRow(
diff --git a/chrome/browser/ui/views/download/download_item_view.cc b/chrome/browser/ui/views/download/download_item_view.cc
index 31a271a03e5e6..ad03a301e1177 100644
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -67,6 +67,7 @@
 #include "ui/base/text/bytes_formatting.h"
 #include "ui/base/themed_vector_icon.h"
 #include "ui/base/ui_base_types.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/compositor/layer.h"
@@ -113,7 +114,7 @@ namespace {
 constexpr int kTextWidth = 140;
 
 // Padding before the icon and at end of the item.
-constexpr int kStartPadding = 12;
+constexpr int kStartPadding = 8;
 constexpr int kEndPadding = 6;
 
 // Horizontal padding between progress indicator and filename/status text.
@@ -585,6 +586,9 @@ gfx::Size DownloadItemView::CalculatePreferredSize(
     }
   }
 
+  if (features::IsThorium2024()) {
+    height -= 16;
+  }
   // The normal height of the item which may be exceeded if text is large.
   constexpr int kDefaultDownloadItemHeight = 48;
   return gfx::Size(width, std::max(kDefaultDownloadItemHeight,
@@ -593,13 +597,6 @@ gfx::Size DownloadItemView::CalculatePreferredSize(
 
 void DownloadItemView::OnPaintBackground(gfx::Canvas* canvas) {
   View::OnPaintBackground(canvas);
-
-  // Draw the separator as part of the background. It will be covered by the
-  // focus ring when the view has focus.
-  gfx::Rect rect(width() - 1, 0, 1, height());
-  rect.Inset(gfx::Insets::VH(kTopBottomPadding, 0));
-  canvas->FillRect(GetMirroredRect(rect),
-                   GetColorProvider()->GetColor(kColorToolbarSeparator));
 }
 
 void DownloadItemView::OnPaint(gfx::Canvas* canvas) {
@@ -675,6 +672,14 @@ void DownloadItemView::OnPaint(gfx::Canvas* canvas) {
     canvas->DrawImageInt(icon, bounds.x(), bounds.y());
   }
 
+  // Draw the separator as part of the background. It will be covered by the
+  // focus ring when the view has focus.
+  // Alex313031: TODO: Use NTB method to pop out to overlay and move right 1px
+  gfx::Rect rect(width() - 1, 0, 1, height());
+  rect.Inset(gfx::Insets::VH(kTopBottomPadding, 0));
+  canvas->FillRect(GetMirroredRect(rect),
+                   GetColorProvider()->GetColor(kColorToolbarSeparator));
+
   OnPaintBorder(canvas);
 }
 
diff --git a/chrome/browser/ui/views/extensions/extensions_menu_item_view.cc b/chrome/browser/ui/views/extensions/extensions_menu_item_view.cc
index 92157b05edc4f..53793a7062b31 100644
--- a/chrome/browser/ui/views/extensions/extensions_menu_item_view.cc
+++ b/chrome/browser/ui/views/extensions/extensions_menu_item_view.cc
@@ -28,6 +28,7 @@
 #include "extensions/common/extension_features.h"
 #include "ui/accessibility/ax_enums.mojom-shared.h"
 #include "ui/base/l10n/l10n_util.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/base/models/image_model.h"
 #include "ui/color/color_id.h"
@@ -189,7 +190,10 @@ views::Builder<HoverButton> GetSitePermissionsButtonBuilder(
     // Add right-aligned arrow icon for non-enterprise extensions when the
     // button is not disabled.
     auto arrow_icon = ui::ImageModel::FromVectorIcon(
-        vector_icons::kSubmenuArrowChromeRefreshIcon, ui::kColorIcon,
+        features::IsThorium2024()
+            ? vector_icons::kSubmenuArrowIcon
+            : vector_icons::kSubmenuArrowChromeRefreshIcon,
+        ui::kColorIcon,
         small_icon_size);
 
     button_builder.SetHorizontalAlignment(gfx::ALIGN_RIGHT)
@@ -247,12 +251,12 @@ ExtensionMenuItemView::ExtensionMenuItemView(
                       controller_->GetActionName()))
                   .SetImageModel(views::Button::STATE_NORMAL,
                                  ui::ImageModel::FromVectorIcon(
-                                     kBrowserToolsChromeRefreshIcon,
+                                     kBrowserToolsIcon,
                                      kColorExtensionMenuIcon, icon_size))
                   .SetImageModel(
                       views::Button::STATE_DISABLED,
                       ui::ImageModel::FromVectorIcon(
-                          kBrowserToolsChromeRefreshIcon,
+                          kBrowserToolsIcon,
                           kColorExtensionMenuIconDisabled, icon_size)));
 
   if (allow_pinning) {
@@ -480,7 +484,7 @@ void ExtensionMenuItemView::UpdateContextMenuButton(bool is_action_pinned) {
   const int icon_size = ChromeLayoutProvider::Get()->GetDistanceMetric(
       DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SIZE);
   auto three_dot_icon = ui::ImageModel::FromVectorIcon(
-      kBrowserToolsChromeRefreshIcon, kColorExtensionMenuIcon, icon_size);
+      kBrowserToolsIcon, kColorExtensionMenuIcon, icon_size);
 
   // Show a pin button for the context menu normal state icon when the action is
   // pinned in the toolbar. All other states should look, and behave, the same.
diff --git a/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc b/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc
index b4ed00fe214a9..cbd69f5565a61 100644
--- a/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc
+++ b/chrome/browser/ui/views/frame/browser_caption_button_container_win.cc
@@ -10,6 +10,8 @@
 #include "chrome/browser/ui/views/frame/browser_frame_view_win.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/frame/windows_caption_button.h"
+#include "chrome/browser/ui/views/frame/window_caption_util.h"
+#include "chrome/browser/ui/views/frame/windows_tab_search_caption_button.h"
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/generated_resources.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -66,6 +68,14 @@ BrowserCaptionButtonContainer::BrowserCaptionButtonContainer(
           frame_view_,
           VIEW_ID_CLOSE_BUTTON,
           IDS_APP_ACCNAME_CLOSE))) {
+  if (WindowCaptionUtil::IsWindowsTabSearchCaptionButtonEnabled(
+          frame_view_->browser_view()->browser())) {
+    tab_search_button_ =
+        AddChildViewAt(std::make_unique<WindowsTabSearchCaptionButton>(
+                           frame_view_, VIEW_ID_TAB_SEARCH_BUTTON,
+                           l10n_util::GetStringUTF16(IDS_ACCNAME_TAB_SEARCH)),
+                       0);
+  }
   // Layout is horizontal, with buttons placed at the trailing end of the view.
   // This allows the container to expand to become a faux titlebar/drag handle.
   auto* const layout = SetLayoutManager(std::make_unique<views::FlexLayout>());
@@ -91,6 +101,9 @@ int BrowserCaptionButtonContainer::NonClientHitTest(
     const gfx::Point& point) const {
   DCHECK(HitTestPoint(point))
       << "should only be called with a point inside this view's bounds";
+  if (tab_search_button_ && HitTestCaptionButton(tab_search_button_, point)) {
+    return HTCLIENT;
+  }
   // BrowserView covers the frame view when Window Controls Overlay is enabled.
   // The native window that encompasses Web Contents gets the mouse events meant
   // for the caption buttons, so returning HTClient allows these buttons to be
@@ -132,6 +145,11 @@ void BrowserCaptionButtonContainer::OnWindowControlsOverlayEnabledChanged() {
   UpdateButtonToolTipsForWindowControlsOverlay();
 }
 
+TabSearchBubbleHost* BrowserCaptionButtonContainer::GetTabSearchBubbleHost() {
+  return tab_search_button_ ? tab_search_button_->tab_search_bubble_host()
+                            : nullptr;
+}
+
 void BrowserCaptionButtonContainer::OnThemeChanged() {
   if (frame_view_->browser_view()->IsWindowControlsOverlayEnabled()) {
     SetBackground(
@@ -141,6 +159,9 @@ void BrowserCaptionButtonContainer::OnThemeChanged() {
 }
 
 void BrowserCaptionButtonContainer::ResetWindowControls() {
+  if (tab_search_button_) {
+    tab_search_button_->SetState(views::Button::STATE_NORMAL);
+  }
   minimize_button_->SetState(views::Button::STATE_NORMAL);
   maximize_button_->SetState(views::Button::STATE_NORMAL);
   restore_button_->SetState(views::Button::STATE_NORMAL);
diff --git a/chrome/browser/ui/views/frame/browser_caption_button_container_win.h b/chrome/browser/ui/views/frame/browser_caption_button_container_win.h
index bda5b2b0ab02d..a8dac38d7b61b 100644
--- a/chrome/browser/ui/views/frame/browser_caption_button_container_win.h
+++ b/chrome/browser/ui/views/frame/browser_caption_button_container_win.h
@@ -15,7 +15,9 @@
 #include "ui/views/widget/widget_observer.h"
 
 class BrowserFrameViewWin;
+class TabSearchBubbleHost;
 class WindowsCaptionButton;
+class WindowsTabSearchCaptionButton;
 
 // Provides a container for Windows caption buttons that can be moved between
 // frame and browser window as needed. When extended horizontally, becomes a
@@ -38,6 +40,8 @@ class BrowserCaptionButtonContainer : public views::View,
 
   void OnWindowControlsOverlayEnabledChanged();
 
+  TabSearchBubbleHost* GetTabSearchBubbleHost();
+
  private:
   friend class BrowserFrameViewWin;
 
@@ -64,6 +68,7 @@ class BrowserCaptionButtonContainer : public views::View,
   void UpdateButtonToolTipsForWindowControlsOverlay();
 
   const raw_ptr<BrowserFrameViewWin> frame_view_;
+  raw_ptr<WindowsTabSearchCaptionButton> tab_search_button_ = nullptr;
   const raw_ptr<WindowsCaptionButton> minimize_button_;
   const raw_ptr<WindowsCaptionButton> maximize_button_;
   const raw_ptr<WindowsCaptionButton> restore_button_;
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_layout_linux.cc b/chrome/browser/ui/views/frame/browser_frame_view_layout_linux.cc
index 84930758ab743..8b762a0c37582 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_layout_linux.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_layout_linux.cc
@@ -74,5 +74,5 @@ gfx::Insets BrowserFrameViewLayoutLinux::RestoredFrameEdgeInsets() const {
 }
 
 int BrowserFrameViewLayoutLinux::NonClientExtraTopThickness() const {
-  return delegate_->IsTabStripVisible() ? 0 : kExtraTopBorder;
+  return (!features::IsThorium2024() && delegate_->IsTabStripVisible()) ? 0 : kExtraTopBorder;
 }
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index eabc844883aca..d5e58befa0166 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -259,6 +259,10 @@ void BrowserFrameViewWin::WindowControlsOverlayEnabledChanged() {
   caption_button_container_->OnWindowControlsOverlayEnabledChanged();
 }
 
+TabSearchBubbleHost* BrowserFrameViewWin::GetTabSearchBubbleHost() {
+  return caption_button_container_->GetTabSearchBubbleHost();
+}
+
 void BrowserFrameViewWin::PaintAsActiveChanged() {
   BrowserNonClientFrameView::PaintAsActiveChanged();
 
@@ -321,7 +325,10 @@ int BrowserFrameViewWin::NonClientHitTest(const gfx::Point& point) {
   // pixels at the end of the top and bottom edges trigger diagonal resizing.
   constexpr int kResizeCornerWidth = 16;
 
-  const int top_border_thickness = GetLayoutConstant(TAB_STRIP_PADDING);
+  const int top_border_thickness = features::IsThorium2024()
+                                   // Alex313031: Maybe use INACTIVE_PADDING or simply 1
+                                   ? FrameTopBorderThickness(false)
+                                   : GetLayoutConstant(TAB_STRIP_PADDING);
 
   const int window_component = GetHTComponentForFrame(
       point, gfx::Insets::TLBR(top_border_thickness, 0, 0, 0),
@@ -501,7 +508,7 @@ int BrowserFrameViewWin::FrameTopBorderThickness(bool restored) const {
       // default. When maximized, the OS sizes the window such that the border
       // extends beyond the screen edges. In that case, we must return the
       // default value.
-      const int kTopResizeFrameArea = 0;
+      const int kTopResizeFrameArea = features::IsThorium2024() ? 8 : 0;
       return kTopResizeFrameArea;
     }
 
@@ -561,8 +568,26 @@ int BrowserFrameViewWin::TopAreaHeight(bool restored) const {
     return top;
   }
 
-  // The tabstrip controls its own top padding.
-  return top;
+  // In Cr23, the tabstrip controls its own top padding.
+  if (!features::IsThorium2024()) {
+    return top;
+  }
+
+  // In maximized mode, we do not add any additional thickness to the grab
+  // handle above the tabs; just return the frame thickness.
+  if (maximized) {
+    return top;
+  }
+
+  // Besides the frame border, there's empty space atop the window in restored
+  // mode, to use to drag the window around.
+  constexpr int kNonClientRestoredExtraThickness = 8;
+  int thickness = kNonClientRestoredExtraThickness;
+  if (EverHasVisibleBackgroundTabShapes() && features::IsThorium2024()) {
+    thickness =
+        std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
+  }
+  return top + thickness;
 }
 
 int BrowserFrameViewWin::TitlebarMaximizedVisualHeight() const {
@@ -810,17 +835,30 @@ void BrowserFrameViewWin::LayoutCaptionButtons() {
 
   const gfx::Size preferred_size =
       caption_button_container_->GetPreferredSize();
+  int height = preferred_size.height();
+  // We use the standard caption bar height when maximized in tablet mode, which
+  // is smaller than our preferred button size.
+  if (IsWebUITabStrip() && IsMaximized()) {
+    height = std::min(height, TitlebarMaximizedVisualHeight());
+  }
+  if (!browser_view()->GetWebAppFrameToolbarPreferredSize().IsEmpty()) {
+    height = IsMaximized() ? TitlebarMaximizedVisualHeight()
+                           : TitlebarHeight(false) - WindowTopY();
+  }
 
   const int system_caption_buttons_width =
       ShouldBrowserCustomDrawTitlebar(browser_view())
           ? 0
           : width() - frame()->GetMinimizeButtonOffset();
 
+  height = features::IsThorium2024() ? std::min(GetFrameHeight(), height)
+                                     : GetFrameHeight();
+
   caption_button_container_->SetBounds(
       CaptionButtonsOnLeadingEdge()
           ? system_caption_buttons_width
           : width() - system_caption_buttons_width - preferred_size.width(),
-      WindowTopY(), preferred_size.width(), GetFrameHeight());
+      WindowTopY(), preferred_size.width(), height);
 }
 
 void BrowserFrameViewWin::LayoutClientView() {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index 27caea181a279..d3210e6c02922 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -17,6 +17,7 @@
 #include "ui/views/window/non_client_view.h"
 
 class BrowserView;
+class TabSearchBubbleHost;
 class BrowserCaptionButtonContainer;
 
 class BrowserFrameViewWin : public BrowserNonClientFrameView,
@@ -45,6 +46,7 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   void UpdateThrobber(bool running) override;
   gfx::Size GetMinimumSize() const override;
   void WindowControlsOverlayEnabledChanged() override;
+  TabSearchBubbleHost* GetTabSearchBubbleHost() override;
 
   // views::NonClientFrameView:
   gfx::Rect GetBoundsForClientView() const override;
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view.cc b/chrome/browser/ui/views/frame/browser_non_client_frame_view.cc
index 3f1568d7a1c94..6483d1cbc5162 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view.cc
@@ -202,6 +202,10 @@ void BrowserNonClientFrameView::VisibilityChanged(views::View* starting_from,
     OnProfileAvatarChanged(base::FilePath());
 }
 
+TabSearchBubbleHost* BrowserNonClientFrameView::GetTabSearchBubbleHost() {
+  return nullptr;
+}
+
 gfx::Insets BrowserNonClientFrameView::RestoredMirroredFrameBorderInsets()
     const {
   NOTREACHED();
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view.h b/chrome/browser/ui/views/frame/browser_non_client_frame_view.h
index 2238e76440194..df37021bf766f 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view.h
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view.h
@@ -13,6 +13,7 @@
 #include "ui/views/window/non_client_view.h"
 
 class BrowserView;
+class TabSearchBubbleHost;
 
 // Type used for functions whose return values depend on the active state of
 // the frame.
@@ -133,6 +134,10 @@ class BrowserNonClientFrameView : public views::NonClientFrameView,
   using views::NonClientFrameView::ShouldPaintAsActive;
   void VisibilityChanged(views::View* starting_from, bool is_visible) override;
 
+  // Gets the TabSearchBubbleHost if present in the NonClientFrameView. Can
+  // return null.
+  virtual TabSearchBubbleHost* GetTabSearchBubbleHost();
+
   // Returns the insets from the edge of the native window to the client view in
   // DIPs. The value is left-to-right even on RTL locales. That is,
   // insets.left() will be on the left in screen coordinates.
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.cc b/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.cc
index 63cc8cddfe04e..a0c81619fb666 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.cc
@@ -283,7 +283,11 @@ int BrowserNonClientFrameViewChromeOS::GetTopInset(bool restored) const {
   }
 
   if (browser_view()->GetTabStripVisible()) {
-    return 0;
+    if (features::IsThorium2024()) {
+      return header_height - browser_view()->GetTabStripHeight();
+    } else {
+      return 0;
+    }
   }
 
   Browser* browser = browser_view()->browser();
@@ -349,6 +353,11 @@ SkColor BrowserNonClientFrameViewChromeOS::GetFrameColor(
   return color.value_or(fallback_color);
 }
 
+TabSearchBubbleHost*
+BrowserNonClientFrameViewChromeOS::GetTabSearchBubbleHost() {
+  return tab_search_bubble_host_;
+}
+
 void BrowserNonClientFrameViewChromeOS::UpdateMinimumSize() {
   gfx::Size current_min_size = GetMinimumSize();
   if (last_minimum_size_ == current_min_size)
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.h b/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.h
index 73458b42a53e7..1a602a719da5a 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.h
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_chromeos.h
@@ -69,6 +69,7 @@ class BrowserNonClientFrameViewChromeOS
   bool CanUserExitFullscreen() const override;
   SkColor GetCaptionColor(BrowserFrameActiveState active_state) const override;
   SkColor GetFrameColor(BrowserFrameActiveState active_state) const override;
+  TabSearchBubbleHost* GetTabSearchBubbleHost() override;
   void UpdateMinimumSize() override;
 
   // views::NonClientFrameView:
@@ -236,6 +237,8 @@ class BrowserNonClientFrameViewChromeOS
   raw_ptr<chromeos::FrameCaptionButtonContainerView> caption_button_container_ =
       nullptr;
 
+  raw_ptr<TabSearchBubbleHost> tab_search_bubble_host_ = nullptr;
+
   // For popups, the window icon.
   raw_ptr<TabIconView> window_icon_ = nullptr;
 
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h b/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h
index 263261b1c8204..93335609f27da 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h
@@ -105,6 +105,8 @@ class BrowserNonClientFrameViewMac : public BrowserNonClientFrameView,
       const gfx::Rect& frame,
       const gfx::Insets& caption_button_insets);
 
+  CGFloat FullscreenBackingBarHeight() const;
+
   // Calculate the y offset the top UI needs to shift down due to showing the
   // slide down menu bar at the very top in full screen.
   int TopUIFullscreenYOffset() const;
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm b/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm
index 2caa04674d405..85c6d434c537b 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm
@@ -50,6 +50,8 @@ namespace {
 // Keep in sync with web_app_frame_toolbar_browsertest.cc
 constexpr double kTitlePaddingWidthFraction = 0.1;
 
+constexpr int kResizeHandleHeight = 1;
+
 // Empirical measurements of the traffic lights.
 constexpr int kCaptionButtonsWidth = 52;
 constexpr int kCaptionButtonsLeadingPadding = 20;
@@ -224,7 +226,46 @@ void BrowserNonClientFrameViewMac::LayoutWebAppWindowTitle(
 }
 
 int BrowserNonClientFrameViewMac::GetTopInset(bool restored) const {
-  return 0;
+  if (features::IsThorium2024()) {
+    if (!browser_view()->ShouldDrawTabStrip()) {
+      return 0;
+    }
+
+    // Mac seems to reserve 1 DIP of the top inset as a resize handle.
+    const int kTabstripTopInset = 8;
+    int top_inset = kTabstripTopInset;
+    if (EverHasVisibleBackgroundTabShapes()) {
+      top_inset =
+          std::max(top_inset, BrowserNonClientFrameView::kMinimumDragHeight +
+                                  kResizeHandleHeight);
+    }
+
+    // Immersive fullscreen attaches the tab strip to the title bar, no need to
+    // calculate the y_offset below.
+    if (browser_view()->UsesImmersiveFullscreenMode()) {
+      return top_inset;
+    }
+
+    // Calculate the y offset for the tab strip because in fullscreen mode the tab
+    // strip may need to move under the slide down menu bar.
+    CGFloat y_offset = TopUIFullscreenYOffset();
+    if (y_offset > 0) {
+      // When menubar shows up, we need to update mouse tracking area.
+      NSWindow* window = GetWidget()->GetNativeWindow().GetNativeNSWindow();
+      NSRect content_bounds = [[window contentView] bounds];
+      // Backing bar tracking area uses native coordinates.
+      CGFloat tracking_height =
+          FullscreenBackingBarHeight() + top_inset + y_offset;
+      NSRect backing_bar_area =
+          NSMakeRect(0, NSMaxY(content_bounds) - tracking_height,
+                     NSWidth(content_bounds), tracking_height);
+      [fullscreen_toolbar_controller_ updateToolbarFrame:backing_bar_area];
+    }
+
+    return y_offset + top_inset;
+  } else {
+    return 0;
+  }
 }
 
 void BrowserNonClientFrameViewMac::UpdateFullscreenTopUI() {
@@ -485,6 +526,21 @@ void BrowserNonClientFrameViewMac::PaintThemedFrame(gfx::Canvas* canvas) {
   canvas->DrawImageInt(overlay, 0, 0);
 }
 
+CGFloat BrowserNonClientFrameViewMac::FullscreenBackingBarHeight() const {
+  BrowserView* browser_view = this->browser_view();
+  DCHECK(browser_view->IsFullscreen());
+
+  CGFloat total_height = 0;
+  if (browser_view->ShouldDrawTabStrip()) {
+    total_height += browser_view->GetTabStripHeight();
+  }
+
+  if (browser_view->IsToolbarVisible())
+    total_height += browser_view->toolbar()->bounds().height();
+
+  return total_height;
+}
+
 int BrowserNonClientFrameViewMac::TopUIFullscreenYOffset() const {
   if (!browser_view()->GetTabStripVisible() ||
       !browser_view()->IsFullscreen() ||
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index c3241e411d46d..2119bfe02bc32 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1239,6 +1239,10 @@ bool BrowserView::UsesImmersiveFullscreenTabbedMode() const {
 #endif
 
 TabSearchBubbleHost* BrowserView::GetTabSearchBubbleHost() {
+  if (auto* tab_search_host =
+          frame_->GetFrameView()->GetTabSearchBubbleHost()) {
+    return tab_search_host;
+  }
   if (auto* tab_search_container =
           tab_strip_region_view_->tab_search_container()) {
     return tab_search_container->tab_search_button()->tab_search_bubble_host();
diff --git a/chrome/browser/ui/views/frame/browser_view_layout.cc b/chrome/browser/ui/views/frame/browser_view_layout.cc
index cb14b46b727ca..c6523a0985809 100644
--- a/chrome/browser/ui/views/frame/browser_view_layout.cc
+++ b/chrome/browser/ui/views/frame/browser_view_layout.cc
@@ -606,7 +606,7 @@ int BrowserViewLayout::LayoutTabStripRegion(int top) {
   // anything to the left of it, like the incognito avatar.
   gfx::Rect tab_strip_region_bounds(
       delegate_->GetBoundsForTabStripRegionInBrowserView());
-  if (is_compact_mode_) {
+  if (is_compact_mode_ && !features::IsThorium2024()) {
     constexpr int retain_some_padding = 2;
     int height = GetLayoutConstant(TAB_STRIP_HEIGHT) -
                  GetLayoutConstant(TAB_STRIP_PADDING) + retain_some_padding;
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
index 4c5356d8f20f6..ccbe7a8ead81e 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
@@ -257,7 +257,9 @@ void OpaqueBrowserFrameView::LayoutWebAppWindowTitle(
 }
 
 int OpaqueBrowserFrameView::GetTopInset(bool restored) const {
-  return layout_->NonClientTopHeight(restored);
+  return browser_view()->ShouldDrawTabStrip() && features::IsThorium2024()
+             ? layout_->GetTabStripInsetsTop(restored)
+             : layout_->NonClientTopHeight(restored);
 }
 
 void OpaqueBrowserFrameView::UpdateThrobber(bool running) {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
index 5c82d24686e9f..6d577bf74d5e2 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
@@ -78,7 +78,7 @@ gfx::Rect OpaqueBrowserFrameViewLayout::GetBoundsForTabStripRegion(
     int total_width) const {
   const int x = available_space_leading_x_;
   const int available_width = available_space_trailing_x_ - x;
-  return gfx::Rect(x, NonClientTopHeight(false), std::max(0, available_width),
+  return gfx::Rect(x, GetTabStripInsetsTop(false), std::max(0, available_width),
                    tabstrip_minimum_size.height());
 }
 
@@ -181,6 +181,15 @@ int OpaqueBrowserFrameViewLayout::NonClientTopHeight(bool restored) const {
          kContentEdgeShadowThickness;
 }
 
+int OpaqueBrowserFrameViewLayout::GetTabStripInsetsTop(bool restored) const {
+  const int top = NonClientTopHeight(restored);
+  const bool start_at_top_of_frame = !restored &&
+                                     delegate_->IsFrameCondensed() &&
+                                     features::IsThorium2024();
+  return start_at_top_of_frame ? top
+                               : (top + GetNonClientRestoredExtraThickness());
+}
+
 gfx::Insets OpaqueBrowserFrameViewLayout::FrameEdgeInsets(bool restored) const {
   return IsFrameEdgeVisible(restored) ? RestoredFrameEdgeInsets()
                                       : gfx::Insets();
@@ -190,7 +199,12 @@ int OpaqueBrowserFrameViewLayout::DefaultCaptionButtonY(bool restored) const {
   // Maximized buttons start at window top, since the window has no border. This
   // offset is for the image (the actual clickable bounds extend all the way to
   // the top to take Fitts' Law into account).
-  return views::NonClientFrameView::kFrameShadowThickness;
+  const bool start_at_top_of_frame = !restored &&
+                                     delegate_->IsFrameCondensed() &&
+                                     features::IsThorium2024();
+  return start_at_top_of_frame
+             ? FrameBorderInsets(false).top()
+             : views::NonClientFrameView::kFrameShadowThickness;
 }
 
 int OpaqueBrowserFrameViewLayout::CaptionButtonY(views::FrameButton button_id,
@@ -236,6 +250,22 @@ int OpaqueBrowserFrameViewLayout::GetWindowCaptionSpacing(
   return 0;
 }
 
+int OpaqueBrowserFrameViewLayout::GetNonClientRestoredExtraThickness() const {
+  // In Refresh, the tabstrip controls its own top padding.
+  if (!features::IsThorium2024()) {
+    return 0;
+  }
+  // Besides the frame border, there's empty space atop the window in restored
+  // mode, to use to drag the window around.
+  constexpr int kNonClientRestoredExtraThickness = 8;
+  int thickness = kNonClientRestoredExtraThickness;
+  if (delegate_->EverHasVisibleBackgroundTabShapes()) {
+    thickness =
+        std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
+  }
+  return thickness;
+}
+
 void OpaqueBrowserFrameViewLayout::SetWindowControlsOverlayEnabled(
     bool enabled,
     views::View* host) {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h
index 707226e0e8c70..5e1a2b4dd9921 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h
@@ -89,6 +89,8 @@ class OpaqueBrowserFrameViewLayout : public views::LayoutManager {
   // if the window was restored, regardless of its current state.
   int NonClientTopHeight(bool restored) const;
 
+  int GetTabStripInsetsTop(bool restored) const;
+
   // Returns the y-coordinate of the caption button when native frame buttons
   // are disabled.  If |restored| is true, acts as if the window is restored
   // regardless of the real mode.
@@ -125,6 +127,9 @@ class OpaqueBrowserFrameViewLayout : public views::LayoutManager {
 
   const gfx::Rect& client_view_bounds() const { return client_view_bounds_; }
 
+  // Returns the extra thickness of the area above the tabs.
+  int GetNonClientRestoredExtraThickness() const;
+
   // Enables or disables WCO and updates child views accordingly.
   void SetWindowControlsOverlayEnabled(bool enabled, views::View* host);
 
diff --git a/chrome/browser/ui/views/frame/tab_strip_region_view.cc b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
index e7660352853f2..1d51369d271f7 100644
--- a/chrome/browser/ui/views/frame/tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
@@ -19,6 +19,7 @@
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/views/chrome_layout_provider.h"
 #include "chrome/browser/ui/views/commerce/product_specifications_button.h"
+#include "chrome/browser/ui/views/frame/window_caption_util.h"
 #include "chrome/browser/ui/views/tab_search_bubble_host.h"
 #include "chrome/browser/ui/views/tabs/new_tab_button.h"
 #include "chrome/browser/ui/views/tabs/tab_drag_controller.h"
@@ -115,7 +116,9 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
 
   // Add and configure the TabSearchContainer.
   std::unique_ptr<TabSearchContainer> tab_search_container;
-  if (browser && browser->is_type_normal()) {
+  static const bool remove_tabsearch_button =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
+  if (browser && browser->is_type_normal() && !remove_tabsearch_button) {
     tab_search_container = std::make_unique<TabSearchContainer>(
         tab_strip_->controller(), browser->tab_strip_model(),
         render_tab_search_before_tab_strip_, this,
@@ -192,7 +195,10 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
             tab_strip_->controller(),
             base::BindRepeating(&TabStrip::NewTabButtonPressed,
                                 base::Unretained(tab_strip_)),
-            vector_icons::kAddIcon);
+                                    features::IsThorium2024()
+                                    ? kAddIcon
+                                    : vector_icons::kAddIcon
+        );
     tab_strip_control_button->SetProperty(views::kElementIdentifierKey,
                                           kNewTabButtonElementId);
 
@@ -205,12 +211,10 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
 
     // TODO(crbug.com/40118868): Revisit the macro expression once build flag
     // switch of lacros-chrome is complete.
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
     // The New Tab Button can be middle-clicked on Linux.
     new_tab_button_->SetTriggerableEventFlags(
         new_tab_button_->GetTriggerableEventFlags() |
         ui::EF_MIDDLE_MOUSE_BUTTON);
-#endif
   }
 
   reserved_grab_handle_space_ =
@@ -223,7 +227,9 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
 
   SetProperty(views::kElementIdentifierKey, kTabStripRegionElementId);
 
-  if (browser && tab_search_container && !render_tab_search_before_tab_strip_) {
+  if (browser && tab_search_container &&
+      !WindowCaptionUtil::IsWindowsTabSearchCaptionButtonEnabled(browser) &&
+      !render_tab_search_before_tab_strip_) {
     if (product_specifications_button) {
       product_specifications_button_ =
           AddChildView(std::move(product_specifications_button));
@@ -231,7 +237,7 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
     tab_search_container_ = AddChildView(std::move(tab_search_container));
     tab_search_container_->SetProperty(
         views::kMarginsKey,
-        gfx::Insets::TLBR(0, 0, 0, GetLayoutConstant(TAB_STRIP_PADDING)));
+        gfx::Insets::TLBR(0, 0, 0, GetLayoutConstant(TAB_SEARCH_PADDING)));
   }
 
   UpdateTabStripMargin();
@@ -369,27 +375,48 @@ void TabStripRegionView::Layout(PassKey) {
     // The NTB needs to be layered on top of the tabstrip to achieve negative
     // margins.
     gfx::Size new_tab_button_size = new_tab_button_->GetPreferredSize();
+    int Th24XOffset;
+    if (features::IsThorium2024()) {
+      Th24XOffset = 4;
+    } else {
+      Th24XOffset = GetLayoutConstant(TAB_MARGIN);
+    }
 
     // The y position is measured from the bottom of the tabstrip, and then
     // padding and button height are removed.
     int x = tab_strip_container_->bounds().right() -
             TabStyle::Get()->GetBottomCornerRadius() +
-            GetLayoutConstant(TAB_STRIP_PADDING);
+            Th24XOffset;
 
     if (base::FeatureList::IsEnabled(features::kCompactMode)) {
       if (profile_->GetPrefs()->GetBoolean(prefs::kCompactModeEnabled)) {
-        x -= GetLayoutConstant(TAB_STRIP_PADDING);
+        x -= Th24XOffset;
       }
     }
-    gfx::Point new_tab_button_new_position = gfx::Point(x, 0);
+    const gfx::Point new_tab_button_new_position = gfx::Point(x, GetLayoutConstant(TAB_BUTTON_OFFSET));
 
-    gfx::Rect new_tab_button_new_bounds =
+    const gfx::Rect new_tab_button_new_bounds =
         gfx::Rect(new_tab_button_new_position, new_tab_button_size);
 
     // If the tabsearch button is before the tabstrip container, then manually
-    // set the bounds.
+    // set the NTB bounds. Also bump it up 1 DIP for Th24
     new_tab_button_->SetBoundsRect(new_tab_button_new_bounds);
   }
+
+  if (tab_search_container_ && features::IsThorium2024()) {
+    gfx::Size tab_search_container_size = tab_search_container_->GetPreferredSize();
+    const int tab_search_container_width = tab_search_container_->GetPreferredSize().width();
+    gfx::Point tab_search_button_new_position =
+                   gfx::Point(tab_search_container_->bounds().right() -
+                       tab_search_container_width,
+                       GetLayoutConstant(TAB_BUTTON_OFFSET));
+
+    const gfx::Rect tab_search_container_new_bounds =
+        gfx::Rect(tab_search_button_new_position, tab_search_container_size);
+
+    // Also bump the TSB up 1 DIP for Th24
+    tab_search_container_->SetBoundsRect(tab_search_container_new_bounds);
+  }
 }
 
 bool TabStripRegionView::CanDrop(const OSExchangeData& data) {
@@ -468,9 +495,10 @@ void TabStripRegionView::ReportCaptionHitTestInReservedGrabHandleSpace(
 }
 
 void TabStripRegionView::UpdateButtonBorders() {
+  constexpr gfx::Size kNTBButtonSize = {28, 28};
   const int extra_vertical_space = GetLayoutConstant(TAB_STRIP_HEIGHT) -
                                    GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP) -
-                                   NewTabButton::kButtonSize.height();
+                                   kNTBButtonSize.height();
   const int top_inset = extra_vertical_space / 2;
   const int bottom_inset = extra_vertical_space - top_inset +
                            GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
@@ -519,7 +547,7 @@ void TabStripRegionView::UpdateTabStripMargin() {
     new_tab_button_->SetProperty(views::kViewIgnoredByLayoutKey, true);
 
     tab_strip_right_margin = new_tab_button_->GetPreferredSize().width() +
-                             GetLayoutConstant(TAB_STRIP_PADDING);
+                             GetLayoutConstant(TAB_INACTIVE_PADDING);
   }
 
   // If the tab search button is before the tab strip, it also overlaps the
@@ -545,8 +573,8 @@ void TabStripRegionView::UpdateTabStripMargin() {
     // should have 6 px of padding between it and the tab_search button (not
     // including the corner radius).
     tab_strip_left_margin = tab_strip_left_margin.value() +
-                            GetLayoutConstant(TAB_STRIP_PADDING) +
-                            GetLayoutConstant(TAB_STRIP_PADDING) -
+                            GetLayoutConstant(TAB_INACTIVE_PADDING) +
+                            GetLayoutConstant(TAB_INACTIVE_PADDING) -
                             TabStyle::Get()->GetBottomCornerRadius();
   }
 
@@ -564,7 +592,7 @@ void TabStripRegionView::AdjustViewBoundsRect(View* view, int offset) {
   const gfx::Size view_size = view->GetPreferredSize();
   const int x =
       tab_strip_container_->x() + TabStyle::Get()->GetBottomCornerRadius() -
-      GetLayoutConstant(TAB_STRIP_PADDING) - view_size.width() - offset;
+      GetLayoutConstant(TAB_SEARCH_PADDING) - view_size.width() - offset;
   const gfx::Rect new_bounds = gfx::Rect(gfx::Point(x, 0), view_size);
   view->SetBoundsRect(new_bounds);
 }
diff --git a/chrome/browser/ui/views/frame/window_caption_util.cc b/chrome/browser/ui/views/frame/window_caption_util.cc
new file mode 100644
index 0000000000000..04703d70ecf9b
--- /dev/null
+++ b/chrome/browser/ui/views/frame/window_caption_util.cc
@@ -0,0 +1,26 @@
+// Copyright 2024 The Chromium Authors and Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/window_caption_util.h"
+
+#include "build/build_config.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/thorium_2024.h"
+
+// static
+bool WindowCaptionUtil::IsWindowsTabSearchCaptionButtonEnabled(
+    const Browser* browser) {
+#if BUILDFLAG(IS_WIN)
+  static const bool remove_tabsearch_button =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
+  static const bool disable_caption_button =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("disable-caption-button");
+  static const bool left_aligned_tab_search_button =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("left-aligned-tab-search-button");
+  return features::IsThorium2024() && browser->is_type_normal() &&
+      !remove_tabsearch_button && !disable_caption_button && !left_aligned_tab_search_button;
+#else
+  return false;
+#endif  // BUILDFLAG(IS_WIN)
+}
diff --git a/chrome/browser/ui/views/frame/window_caption_util.h b/chrome/browser/ui/views/frame/window_caption_util.h
new file mode 100644
index 0000000000000..92e166d7ca93c
--- /dev/null
+++ b/chrome/browser/ui/views/frame/window_caption_util.h
@@ -0,0 +1,21 @@
+// Copyright 2024 The Chromium Authors and Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_WINDOW_CAPTION_UTIL_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_WINDOW_CAPTION_UTIL_H_
+
+class Browser;
+
+// Static-only class containing values and helper functions for frame classes
+// that need to be accessible outside of /browser/ui/views.
+class WindowCaptionUtil {
+ public:
+  // Returns true if the Windows caption button is enabled.
+  static bool IsWindowsTabSearchCaptionButtonEnabled(const Browser* browser);
+
+ private:
+  WindowCaptionUtil() {}
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_WINDOW_CAPTION_UTIL_H_
diff --git a/chrome/browser/ui/views/frame/windows_caption_button.cc b/chrome/browser/ui/views/frame/windows_caption_button.cc
index d8000f801d188..7f69dd091d42a 100644
--- a/chrome/browser/ui/views/frame/windows_caption_button.cc
+++ b/chrome/browser/ui/views/frame/windows_caption_button.cc
@@ -14,6 +14,7 @@
 #include "chrome/browser/ui/views/frame/browser_frame_view_win.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/frame/tab_strip_region_view.h"
+#include "chrome/browser/ui/views/frame/window_caption_util.h"
 #include "chrome/grit/theme_resources.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/base/theme_provider.h"
@@ -155,16 +156,22 @@ int WindowsCaptionButton::GetBetweenButtonSpacing() const {
 
 int WindowsCaptionButton::GetButtonDisplayOrderIndex() const {
   int button_display_order = 0;
+  const bool tab_search_enabled =
+      WindowCaptionUtil::IsWindowsTabSearchCaptionButtonEnabled(
+          frame_view_->browser_view()->browser());
   switch (button_type_) {
-    case VIEW_ID_MINIMIZE_BUTTON:
+    case VIEW_ID_TAB_SEARCH_BUTTON:
       button_display_order = 0;
       break;
+    case VIEW_ID_MINIMIZE_BUTTON:
+      button_display_order = 0 + (tab_search_enabled ? 1 : 0);
+      break;
     case VIEW_ID_MAXIMIZE_BUTTON:
     case VIEW_ID_RESTORE_BUTTON:
-      button_display_order = 1;
+      button_display_order = 1 + (tab_search_enabled ? 1 : 0);
       break;
     case VIEW_ID_CLOSE_BUTTON:
-      button_display_order = 2;
+      button_display_order = 2 + (tab_search_enabled ? 1 : 0);
       break;
     default:
       NOTREACHED();
@@ -172,7 +179,7 @@ int WindowsCaptionButton::GetButtonDisplayOrderIndex() const {
 
   // Reverse the ordering if we're in RTL mode
   if (base::i18n::IsRTL()) {
-    const int max_index = 2;
+    const int max_index = tab_search_enabled ? 3 : 2;
     button_display_order = max_index - button_display_order;
   }
 
@@ -240,6 +247,10 @@ void WindowsCaptionButton::PaintSymbol(gfx::Canvas* canvas) {
       return;
     }
 
+    case VIEW_ID_TAB_SEARCH_BUTTON:
+      icon_painter_->PaintTabSearchIcon(canvas, symbol_rect, flags);
+      return;
+
     default:
       NOTREACHED();
   }
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index eca41f6f37b37..a0252c0eae77e 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -199,18 +199,24 @@ LocationBarView::LocationBarView(Browser* browser,
       is_popup_mode_(is_popup_mode) {
   set_suppress_default_focus_handling();
   if (!is_popup_mode_) {
-    views::FocusRing::Install(this);
-    views::FocusRing::Get(this)->SetHasFocusPredicate(
-        base::BindRepeating([](const View* view) {
-          const auto* v = views::AsViewClass<LocationBarView>(view);
-          CHECK(v);
-          // Show focus ring when the Omnibox is visibly focused and the popup
-          // is closed.
-          return v->omnibox_view_->model()->is_caret_visible() &&
-                 !v->GetOmniboxPopupView()->IsOpen();
-        }));
-    views::FocusRing::Get(this)->SetOutsetFocusRingDisabled(true);
-    views::InstallPillHighlightPathGenerator(this);
+    if (!features::IsThorium2024()) {
+      views::FocusRing::Install(this);
+      views::FocusRing::Get(this)->SetHasFocusPredicate(
+          base::BindRepeating([](const View* view) {
+            const auto* v = views::AsViewClass<LocationBarView>(view);
+            CHECK(v);
+            // Show focus ring when the Omnibox is visibly focused and the popup
+            // is closed.
+            return v->omnibox_view_->model()->is_caret_visible() &&
+                   !v->GetOmniboxPopupView()->IsOpen();
+          }));
+      views::FocusRing::Get(this)->SetOutsetFocusRingDisabled(true);
+    }
+    static const bool classic_omnibox =
+        base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
+    if (!classic_omnibox) {
+        views::InstallPillHighlightPathGenerator(this);
+    }
 
 #if BUILDFLAG(OS_LEVEL_GEOLOCATION_PERMISSION_SUPPORTED)
     if (features::IsOsLevelGeolocationPermissionSupportEnabled()) {
@@ -258,10 +264,16 @@ void LocationBarView::Init() {
   const gfx::FontList& font_list = typography_provider.GetFont(
       CONTEXT_OMNIBOX_PRIMARY, views::style::STYLE_PRIMARY);
 
-  const gfx::FontList& omnibox_chip_font_list = typography_provider.GetFont(
-      CONTEXT_OMNIBOX_PRIMARY, views::style::STYLE_BODY_4_EMPHASIS);
-  const gfx::FontList& page_action_font_list = typography_provider.GetFont(
-      CONTEXT_OMNIBOX_PRIMARY, views::style::STYLE_BODY_3_EMPHASIS);
+  const gfx::FontList& omnibox_chip_font_list =
+      features::IsThorium2024()
+          ? font_list
+          : typography_provider.GetFont(CONTEXT_OMNIBOX_PRIMARY,
+                                        views::style::STYLE_BODY_4_EMPHASIS);
+  const gfx::FontList& page_action_font_list =
+      features::IsThorium2024()
+          ? font_list
+          : typography_provider.GetFont(CONTEXT_OMNIBOX_PRIMARY,
+                                        views::style::STYLE_BODY_3_EMPHASIS);
 
   auto location_icon_view =
       std::make_unique<LocationIconView>(omnibox_chip_font_list, this, this);
@@ -400,12 +412,17 @@ void LocationBarView::Init() {
     }
   }
 
+  if (browser_) {
+    if (sharing_hub::HasPageAction(profile_, is_popup_mode_)) {
+      params.types_enabled.push_back(PageActionIconType::kSharingHub);
+    }
+  }
   if (browser_ && !is_popup_mode_) {
     params.types_enabled.push_back(PageActionIconType::kBookmarkStar);
   }
 
   params.icon_color = color_provider->GetColor(kColorPageActionIcon);
-  params.between_icon_spacing = 8;
+  params.between_icon_spacing = features::IsThorium2024() ? 4 : 8;
   params.font_list = &page_action_font_list;
   params.browser = browser_;
   params.command_updater = command_updater();
@@ -438,8 +455,14 @@ bool LocationBarView::IsInitialized() const {
 }
 
 int LocationBarView::GetBorderRadius() const {
-  return ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
-      views::Emphasis::kMaximum, size());
+  static const bool classic_omnibox =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
+  if (classic_omnibox) {
+    return 4;
+  } else {
+    return ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
+        views::Emphasis::kMaximum, size());
+  }
 }
 
 std::unique_ptr<views::Background> LocationBarView::CreateRoundRectBackground(
@@ -703,18 +726,18 @@ void LocationBarView::Layout(PassKey) {
   // The padding between the left edges of the location bar and the LHS icon
   // (e.g. the page info icon, the google G icon, the selected suggestion icon,
   // etc)
-  int icon_left = 5;
+  int icon_left = GetLayoutConstant(LOCATION_BAR_LEADING_DECORATION_EDGE_PADDING);
   // The padding between the LHS icon and the text.
-  int text_left = 8;
+  int text_left = features::IsThorium2024() ? 0 : 8;
   // Indentation to match the suggestion icons & texts.
-  int icon_indent = 7;
-  int text_indent = 6;
+  int icon_indent = features::IsThorium2024() ? 9 : 7;
+  int text_indent = features::IsThorium2024() ? 1 : 6;
   // Indentation to match the suggestion icons & texts when in keyword mode.
-  int icon_keyword_indent = 9;
-  int text_keyword_indent = -9;
+  int icon_keyword_indent = features::IsThorium2024() ? 10 : 9;
+  int text_keyword_indent = features::IsThorium2024() ? -10 : -9;
   // Indentation add padding when the permission chip is visible and replacing
   // the LHS icon.
-  int text_overriding_permission_chip_indent = 0;
+  int text_overriding_permission_chip_indent = features::IsThorium2024() ? 4 : 0;
   if (should_indent) {
     icon_left += icon_indent;
     text_left += text_indent;
@@ -805,12 +828,14 @@ void LocationBarView::Layout(PassKey) {
   add_trailing_decoration(page_action_icon_container_,
                           /*intra_item_padding=*/0);
   for (ContentSettingImageView* view : base::Reversed(content_setting_views_)) {
-    int intra_item_padding = kContentSettingIntraItemPadding;
+    int intra_item_padding =
+        features::IsThorium2024() ? 4 : kContentSettingIntraItemPadding;
     add_trailing_decoration(view, intra_item_padding);
   }
 
   if (intent_chip_) {
-    int intra_item_padding = kIntentChipIntraItemPadding;
+    int intra_item_padding =
+        features::IsThorium2024() ? 6 : kIntentChipIntraItemPadding;
     add_trailing_decoration(intent_chip_, intra_item_padding);
   }
 
@@ -1011,12 +1036,18 @@ SkColor LocationBarView::GetIconLabelBubbleSurroundingForegroundColor() const {
   // will inherit the selected "surrounding foreground color".
   const auto color_id = ShouldShowKeywordBubble()
                             ? kColorOmniboxKeywordSeparator
-                            : kColorPageActionIcon;
+                            : (features::IsThorium2024()
+                               ? kColorOmniboxText
+                               : kColorPageActionIcon);
   return GetColorProvider()->GetColor(color_id);
 }
 
 SkAlpha LocationBarView::GetIconLabelBubbleSeparatorAlpha() const {
-  return 0xFF;
+  if (features::IsThorium2024()) {
+    return IconLabelBubbleView::Delegate::GetIconLabelBubbleSeparatorAlpha();
+  } else {
+    return 0xFF;
+  }
 }
 
 SkColor LocationBarView::GetIconLabelBubbleBackgroundColor() const {
@@ -1091,7 +1122,7 @@ bool LocationBarView::IsVirtualKeyboardVisible(views::Widget* widget) {
 // static
 int LocationBarView::GetAvailableTextHeight() {
   return std::max(0, GetLayoutConstant(LOCATION_BAR_HEIGHT) -
-                         2 * GetLayoutConstant(LOCATION_BAR_ELEMENT_PADDING));
+                     2 * GetLayoutConstant(LOCATION_BAR_ELEMENT_PADDING));
 }
 
 // static
@@ -1135,6 +1166,7 @@ gfx::Rect LocationBarView::GetLocalBoundsWithoutEndcaps() const {
 void LocationBarView::RefreshBackground() {
   const double opacity = hover_animation_.GetCurrentValue();
   const bool is_caret_visible = omnibox_view_->model()->is_caret_visible();
+  const bool is_open = GetOmniboxPopupView()->IsOpen();
   const bool input_in_progress =
       omnibox_view_->model()->user_input_in_progress();
   const bool high_contrast = GetNativeTheme()->UserHasContrastPreference();
@@ -1150,7 +1182,7 @@ void LocationBarView::RefreshBackground() {
     // Match the background color to the popup if the Omnibox is visibly
     // focused.
     background_color = color_provider->GetColor(kColorOmniboxResultsBackground);
-  } else if (input_in_progress && !high_contrast) {
+  } else if (!features::IsThorium2024() && input_in_progress && !high_contrast) {
     // Under CR23 guidelines, if the Omnibox is unfocused, but still contains
     // in-progress user input, the background color matches the popup (unless
     // high-contrast mode is enabled).
@@ -1160,6 +1192,17 @@ void LocationBarView::RefreshBackground() {
   }
 
   SkColor border_color = SK_ColorTRANSPARENT;
+
+  static const bool classic_omnibox =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
+  if (classic_omnibox && !is_caret_visible ) {
+    border_color = color_provider->GetColor(kColorLocationBarBorderOnMismatch);
+  }
+
+  if (is_caret_visible && !is_open && features::IsThorium2024()) {
+    border_color = color_provider->GetColor(ui::kColorFocusableBorderFocused);
+  }
+
   if (high_contrast) {
     // High contrast schemes get a border stroke even on a rounded omnibox.
     border_color =
diff --git a/chrome/browser/ui/views/location_bar/location_icon_view.cc b/chrome/browser/ui/views/location_bar/location_icon_view.cc
index c00c86f254dd5..ff92f81f91bec 100644
--- a/chrome/browser/ui/views/location_bar/location_icon_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_icon_view.cc
@@ -75,8 +75,10 @@ LocationIconView::LocationIconView(
 
   SetAccessibleProperties(/*is_initialization*/ true);
 
+  if (!features::IsThorium2024()) {
     ConfigureInkDropForRefresh2023(this, kColorPageInfoIconHover,
                                    kColorPageInfoIconPressed);
+  }
 
   UpdateBorder();
 }
@@ -110,7 +112,7 @@ SkColor LocationIconView::GetForegroundColor() const {
 }
 
 bool LocationIconView::ShouldShowSeparator() const {
-  return false;
+  return features::IsThorium2024();
 }
 
 bool LocationIconView::ShouldShowLabelAfterAnimation() const {
@@ -320,6 +322,7 @@ void LocationIconView::UpdateIcon() {
 }
 
 void LocationIconView::UpdateBackground() {
+  if (!features::IsThorium2024()) {
     CHECK(GetColorProvider());
     const std::u16string& display_text = GetText();
     const bool is_text_dangerous =
@@ -341,6 +344,9 @@ void LocationIconView::UpdateBackground() {
       ConfigureInkDropForRefresh2023(this, kColorPageInfoIconHover,
                                      kColorPageInfoIconPressed);
     }
+  } else {
+    IconLabelBubbleView::UpdateBackground();
+  }
 }
 
 void LocationIconView::OnIconFetched(const gfx::Image& image) {
@@ -361,7 +367,7 @@ void LocationIconView::Update(bool suppress_animations,
   // level.
   UpdateLabelColors();
 
-  if (force_hide_background) {
+  if (force_hide_background && !features::IsThorium2024()) {
     SetBackground(
         views::CreateRoundedRectBackground(SK_ColorTRANSPARENT, height() / 2));
   }
@@ -419,20 +425,24 @@ void LocationIconView::UpdateBorder() {
   // the bubble should be smaller, so use an empty border to shrink down the
   // content bounds so the background gets painted correctly.
     gfx::Insets insets = GetLayoutInsets(LOCATION_BAR_PAGE_INFO_ICON_PADDING);
-    if (ShouldShowLabel()) {
-      SecurityLevel level = GetSecurityLevel();
-      if (level == security_state::DANGEROUS) {
-        // Extra space between the left edge and label.
-        const int kLeftHorizontalPadding = 6;
-        // Extra space between the label and right edge.
-        const int kRightHorizontalPadding = 10;
-        insets.set_left(kLeftHorizontalPadding);
-        insets.set_right(kRightHorizontalPadding);
-      } else {
-        // An extra space between chip's label and right edge.
-        const int kExtraRightPadding = 4;
-        insets.set_right(insets.right() + kExtraRightPadding);
+    if (!features::IsThorium2024()) {
+      if (ShouldShowLabel()) {
+        SecurityLevel level = GetSecurityLevel();
+        if (level == security_state::DANGEROUS) {
+          // Extra space between the left edge and label.
+          const int kLeftHorizontalPadding = 6;
+          // Extra space between the label and right edge.
+          const int kRightHorizontalPadding = 10;
+          insets.set_left(kLeftHorizontalPadding);
+          insets.set_right(kRightHorizontalPadding);
+        } else {
+          // An extra space between chip's label and right edge.
+          const int kExtraRightPadding = 4;
+          insets.set_right(insets.right() + kExtraRightPadding);
+        }
       }
+    } else {
+      IconLabelBubbleView::UpdateBorder();
     }
     SetBorder(views::CreateEmptyBorder(insets));
 }
diff --git a/chrome/browser/ui/views/omnibox/omnibox_suggestion_button_row_view.cc b/chrome/browser/ui/views/omnibox/omnibox_suggestion_button_row_view.cc
index 5530486ee3bb3..352aacdbfe227 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_suggestion_button_row_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_suggestion_button_row_view.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/omnibox/omnibox_suggestion_button_row_view.h"
 
+#include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "base/memory/raw_ptr.h"
 #include "base/ranges/algorithm.h"
@@ -139,7 +140,15 @@ class OmniboxSuggestionRowButton : public views::MdTextButton {
     SetImageLabelSpacing(8);
     SetCustomPadding(ChromeLayoutProvider::Get()->GetInsetsMetric(
         INSETS_OMNIBOX_PILL_BUTTON));
-    SetCornerRadius(GetLayoutConstant(TOOLBAR_CORNER_RADIUS));
+    static const bool classic_omnibox = base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
+    int corner_radius;
+    if (classic_omnibox) {
+      corner_radius = 4;
+    } else {
+      corner_radius = 8;
+    }
+    static const int kCornerRadius = corner_radius;
+    SetCornerRadius(kCornerRadius);
 
     auto* const ink_drop = views::InkDrop::Get(this);
     SetAnimationDuration(base::TimeDelta());
diff --git a/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.cc b/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.cc
index 4bc8f9177f416..9fc3598a5f1a8 100644
--- a/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.cc
+++ b/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.cc
@@ -35,9 +35,6 @@
 
 namespace {
 
-// Value from the spec controlling appearance of the shadow.
-constexpr int kElevation = 16;
-
 #if !defined(USE_AURA)
 
 struct WidgetEventPair {
@@ -243,7 +240,10 @@ RoundedOmniboxResultsFrame::RoundedOmniboxResultsFrame(
       views::BubbleBorder::Arrow::NONE,
       views::BubbleBorder::Shadow::STANDARD_SHADOW);
   border->SetCornerRadius(corner_radius);
-  border->set_md_shadow_elevation(kElevation);
+  border->set_md_shadow_elevation(GetBubbleElevation());
+  if (features::IsThorium2024()) {
+    border->set_draw_border_stroke(true);
+  }
   SetBorder(std::move(border));
 
   AddChildView(contents_host_.get());
@@ -272,10 +272,19 @@ void RoundedOmniboxResultsFrame::OnBeforeWidgetInit(
   params->shadow_type = views::Widget::InitParams::ShadowType::kNone;
 }
 
+// Static value from the spec controlling appearance of the shadow.
+int RoundedOmniboxResultsFrame::GetBubbleElevation() {
+  if (features::IsThorium2024()) {
+    return 6;
+  } else {
+    return 16;
+  }
+}
+
 // static
 int RoundedOmniboxResultsFrame::GetNonResultSectionHeight() {
   return GetLayoutConstant(LOCATION_BAR_HEIGHT) +
-         GetLocationBarAlignmentInsets().height();
+         GetNonResultSectionInsets().height();
 }
 
 // static
@@ -283,12 +292,26 @@ gfx::Insets RoundedOmniboxResultsFrame::GetLocationBarAlignmentInsets() {
   if (ui::TouchUiController::Get()->touch_ui()) {
     return gfx::Insets::TLBR(6, 1, 5, 1);
   }
+  if (features::IsThorium2024()) {
+    return gfx::Insets::VH(3, 6);
+  }
+  return gfx::Insets::VH(5, 6);
+}
+
+// static
+gfx::Insets RoundedOmniboxResultsFrame::GetNonResultSectionInsets() {
+  if (ui::TouchUiController::Get()->touch_ui()) {
+    return gfx::Insets::TLBR(6, 1, 5, 1);
+  }
+  if (features::IsThorium2024()) {
+    return gfx::Insets::VH(4.0f, 6);
+  }
   return gfx::Insets::VH(5, 6);
 }
 
 // static
 gfx::Insets RoundedOmniboxResultsFrame::GetShadowInsets() {
-  return views::BubbleBorder::GetBorderAndShadowInsets(kElevation);
+  return views::BubbleBorder::GetBorderAndShadowInsets(GetBubbleElevation());
 }
 
 void RoundedOmniboxResultsFrame::Layout(PassKey) {
diff --git a/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.h b/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.h
index d134918c8538e..04c405a754962 100644
--- a/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.h
+++ b/chrome/browser/ui/views/omnibox/rounded_omnibox_results_frame.h
@@ -29,12 +29,18 @@ class RoundedOmniboxResultsFrame : public views::View {
   static void OnBeforeWidgetInit(views::Widget::InitParams* params,
                                  views::Widget* widget);
 
+  // Bubble elevation metric for Omnibox popup shadows.
+  static int GetBubbleElevation();
+
   // The height of the location bar view part of the omnibox popup.
   static int GetNonResultSectionHeight();
 
   // How the Widget is aligned relative to the location bar.
   static gfx::Insets GetLocationBarAlignmentInsets();
 
+  // How the text area of the Widget is aligned relative to the location bar.
+  static gfx::Insets GetNonResultSectionInsets();
+
   // Returns the blur region taken up by the Omnibox popup shadows.
   static gfx::Insets GetShadowInsets();
 
diff --git a/chrome/browser/ui/views/page_info/page_info_view_factory.cc b/chrome/browser/ui/views/page_info/page_info_view_factory.cc
index 0a86475f8db19..9d599fa3f880a 100644
--- a/chrome/browser/ui/views/page_info/page_info_view_factory.cc
+++ b/chrome/browser/ui/views/page_info/page_info_view_factory.cc
@@ -34,6 +34,7 @@
 #include "components/strings/grit/components_strings.h"
 #include "components/vector_icons/vector_icons.h"
 #include "ui/base/l10n/l10n_util.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_id.h"
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/views/bubble/bubble_frame_view.h"
@@ -87,6 +88,12 @@ std::unique_ptr<views::View> PageInfoViewFactory::CreateSeparator(
     int horizontal_inset) {
   int separator_spacing = ChromeLayoutProvider::Get()->GetDistanceMetric(
       DISTANCE_CONTENT_LIST_VERTICAL_MULTI);
+  if (features::IsThorium2024()) {
+    // Distance for multi content list is used, but split in half, since there
+    // is a separator in the middle of it. For ChromeRefresh2023, the separator
+    // spacing is larger hence no need to split in half.
+    separator_spacing /= 2;
+  }
   auto separator = std::make_unique<views::Separator>();
   separator->SetProperty(views::kMarginsKey,
                          gfx::Insets::VH(separator_spacing, horizontal_inset));
@@ -648,9 +655,12 @@ const ui::ImageModel PageInfoViewFactory::GetConnectionSecureIcon() {
 const ui::ImageModel PageInfoViewFactory::GetOpenSubpageIcon() {
   // GetIconSize() does not work for subpage icons because the default size of
   // kSubmenuArrowIcon is 8 rather than 16.
-  constexpr int kIconSize = 20;
+  const int kIconSize = features::IsThorium2024() ? 9 : 20;
   return ui::ImageModel::FromVectorIcon(
-      vector_icons::kSubmenuArrowChromeRefreshIcon, ui::kColorIcon, kIconSize);
+      features::IsThorium2024()
+          ? vector_icons::kSubmenuArrowIcon
+          : vector_icons::kSubmenuArrowChromeRefreshIcon,
+      ui::kColorIcon, kIconSize);
 }
 
 // static
diff --git a/chrome/browser/ui/views/side_panel/side_panel.cc b/chrome/browser/ui/views/side_panel/side_panel.cc
index 12f3662bee633..d4295bb1f3785 100644
--- a/chrome/browser/ui/views/side_panel/side_panel.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel.cc
@@ -55,7 +55,7 @@ namespace {
 // This thickness includes the solid-color background and the inner round-rect
 // border-color stroke. It does not include the outer-color separator.
 int GetBorderThickness() {
-  return (lens::features::IsLensOverlayEnabled() ? 8 : 16) +
+  return (lens::features::IsLensOverlayEnabled() ? 12 : 12) +
          views::Separator::kThickness;
 }
 
diff --git a/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc b/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
index e65fda1bf0161..63a226c4bbf6e 100644
--- a/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
@@ -12,6 +12,7 @@
 #include "ui/accessibility/mojom/ax_node_data.mojom.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider.h"
 #include "ui/compositor/layer.h"
 #include "ui/gfx/geometry/size.h"
@@ -26,17 +27,22 @@ namespace views {
 
 SidePanelResizeHandle::SidePanelResizeHandle(SidePanel* side_panel)
     : side_panel_(side_panel) {
-  gfx::Size preferred_size((lens::features::IsLensOverlayEnabled() ? 4 : 16),
+  gfx::Size preferred_size((lens::features::IsLensOverlayEnabled()
+                                ? (features::IsThorium2024() ? 8 : 4)
+                                : 8),
                            24);
   SetPreferredSize(preferred_size);
   SetCanProcessEventsWithinSubtree(false);
   SetFocusBehavior(FocusBehavior::ALWAYS);
   FocusRing::Install(this);
-  if (lens::features::IsLensOverlayEnabled()) {
-    const int resize_handle_left_margin = 2;
+  if (lens::features::IsLensOverlayEnabled() && !features::IsThorium2024()) {
+    constexpr int resize_handle_left_margin = 2;
     SetProperty(views::kMarginsKey,
                 gfx::Insets().set_left(resize_handle_left_margin));
-  } else {
+  } else if (!lens::features::IsLensOverlayEnabled() || features::IsThorium2024()) {
+    constexpr float resize_handle_right_margin = 1.5f;
+    SetProperty(views::kMarginsKey,
+                gfx::Insets().set_left(resize_handle_right_margin));
     constexpr int kIconSize = 16;
     SetImage(ui::ImageModel::FromVectorIcon(
         kDragHandleIcon, kColorSidePanelResizeAreaHandle, kIconSize));
@@ -47,7 +53,7 @@ SidePanelResizeHandle::SidePanelResizeHandle(SidePanel* side_panel)
 }
 
 void SidePanelResizeHandle::UpdateVisibility(bool visible) {
-  if (visible) {
+  if (visible && !features::IsThorium2024() && lens::features::IsLensOverlayEnabled()) {
     const SkColor resize_handle_color =
         GetColorProvider()->GetColor(kColorSidePanelHoverResizeAreaHandle);
     SetBackground(CreateRoundedRectBackground(resize_handle_color, 2));
diff --git a/chrome/browser/ui/views/tab_search_bubble_host.cc b/chrome/browser/ui/views/tab_search_bubble_host.cc
index fa14797259775..6031b27d539e6 100644
--- a/chrome/browser/ui/views/tab_search_bubble_host.cc
+++ b/chrome/browser/ui/views/tab_search_bubble_host.cc
@@ -202,7 +202,7 @@ bool TabSearchBubbleHost::ShowTabSearchBubble(
     // Place the anchor similar to where the button would be in non-fullscreen
     // mode.
     const gfx::Rect bounds = button_->GetWidget()->GetWorkAreaBoundsInScreen();
-    const int offset = GetLayoutConstant(TAB_STRIP_PADDING);
+    const int offset = GetLayoutConstant(TAB_INACTIVE_PADDING);
 
     const int x = tabs::GetTabSearchTrailingTabstrip(profile_)
                       ? bounds.right() - offset
diff --git a/chrome/browser/ui/views/tabs/tab.cc b/chrome/browser/ui/views/tabs/tab.cc
index 30ec5058583ed..1b1b144a965aa 100644
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2024 The Chromium Authors, Alex313031, and gz83
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -16,6 +16,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
@@ -69,6 +70,7 @@
 #include "ui/base/pointer/touch_ui_controller.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/base/theme_provider.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/compositor/clip_recorder.h"
 #include "ui/compositor/compositor.h"
 #include "ui/gfx/animation/tween.h"
@@ -115,7 +117,9 @@ constexpr int kPinnedTabExtraWidthToRenderAsNormal = 30;
 // Additional padding of close button to the right of the tab
 // indicator when `extra_alert_indicator_padding_` is true.
 constexpr int kTabAlertIndicatorCloseButtonPaddingAdjustmentTouchUI = 8;
+constexpr int kTabAlertIndicatorCloseButtonPaddingAdjustmentTh24 = 6;
 constexpr int kTabAlertIndicatorCloseButtonPaddingAdjustment = 4;
+constexpr int kExtraLeftPaddingToBalanceCloseButtonPadding = 2;
 
 // When the DiscardRingImprovements feature is enabled, increase the radius of
 // the discard ring by this amount if there is enough space.
@@ -231,6 +235,7 @@ Tab::Tab(TabSlotController* controller)
   title_->SetHandlesTooltips(false);
   title_->SetAutoColorReadabilityEnabled(false);
   title_->SetText(CoreTabHelper::GetDefaultTitle());
+  title_->SetFontList(tab_style_views_->GetFontList());
   title_->SetBackgroundColor(SK_ColorTRANSPARENT);
   // |title_| paints on top of an opaque region (the tab background) of a
   // non-opaque layer (the tabstrip's layer), which cannot currently be detected
@@ -318,12 +323,23 @@ void Tab::Layout(PassKey) {
   const bool was_showing_icon = showing_icon_;
   UpdateIconVisibility();
 
-  const int start = contents_rect.x();
+  int start = contents_rect.x();
+
+  if (extra_padding_before_content_ && features::IsThorium2024()) {
+    start += kExtraLeftPaddingToBalanceCloseButtonPadding;
+  }
 
   // The bounds for the favicon will include extra width for the attention
   // indicator, but visually it will be smaller at kFaviconSize wide.
   gfx::Rect favicon_bounds(start, contents_rect.y(), 0, 0);
   if (showing_icon_) {
+    // Height should go to the bottom of the tab for the crashed tab animation
+    // to pop out of the bottom in Thorium 2024 UI.
+    favicon_bounds.set_y(contents_rect.y() +
+                         Center(features::IsThorium2024()
+                                    ? contents_rect.height()
+                                    : gfx::kFaviconSize,
+                                gfx::kFaviconSize));
     if (center_icon_) {
       // When centering the favicon, the favicon is allowed to escape the normal
       // contents rect.
@@ -387,7 +403,9 @@ void Tab::Layout(PassKey) {
       if (extra_alert_indicator_padding_) {
         right -= ui::TouchUiController::Get()->touch_ui()
                      ? kTabAlertIndicatorCloseButtonPaddingAdjustmentTouchUI
-                     : kTabAlertIndicatorCloseButtonPaddingAdjustment;
+                     : (features::IsThorium2024()
+                           ? kTabAlertIndicatorCloseButtonPaddingAdjustmentTh24
+                           : kTabAlertIndicatorCloseButtonPaddingAdjustment);
       }
     }
     const gfx::Size image_size = alert_indicator_button_->GetPreferredSize();
@@ -566,10 +584,34 @@ void Tab::OnMouseReleased(const ui::MouseEvent& event) {
     return;
   }
 
+  // Close tab on double click, mirror of IsOnlyMiddleMouseButton
+  // Based on gz83's work.
+  // if (base::CommandLine::ForCurrentProcess()->HasSwitch("double-click-close-tab")) {
+  //   if (event.IsOnlyLeftMouseButton() && event.GetClickCount() == 2) {
+  //      if (HitTestPoint(event.location())) {
+  //        controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
+  //      }
+  //    }
+  //  } else if (closing_) {
+      // We're animating closed and a middle mouse button was pushed on us but
+      // we don't contain the mouse anymore. We assume the user is clicking
+      // quicker than the animation and we should close the tab that falls under
+      // the mouse.
+  //      gfx::Point location_in_parent = event.location();
+  //      ConvertPointToTarget(this, parent(), &location_in_parent);
+  //      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
+  //      if (closest_tab)
+  //        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
+  //  }
+
   // Close tab on middle click, but only if the button is released over the tab
   // (normal windows behavior is to discard presses of a UI element where the
   // releases happen off the element).
-  if (event.IsOnlyMiddleMouseButton()) {
+  if (event.IsOnlyMiddleMouseButton() ||
+    // Close tab on double click, mirror of IsOnlyMiddleMouseButton
+    // Based on gz83's work.
+    ((event.IsOnlyLeftMouseButton() && event.GetClickCount() == 2) &&
+      base::CommandLine::ForCurrentProcess()->HasSwitch("double-click-close-tab"))) {
     if (HitTestPoint(event.location())) {
       controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
     } else if (closing_) {
@@ -702,8 +744,14 @@ void Tab::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 std::u16string Tab::GetTooltipText(const gfx::Point& p) const {
-  // Tab hover cards replace tooltips for tabs.
-  return std::u16string();
+  // Tab hover cards don't replace tooltips for tabs in all cases.
+  const auto tab_hover_cards_tooltip =
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "tooltip";
+  if (tab_hover_cards_tooltip) {
+    return GetTooltipText(data_.title, GetAlertStateToShow(data_.alert_state));
+  } else {
+    return std::u16string();
+  }
 }
 
 void Tab::GetAccessibleNodeData(ui::AXNodeData* node_data) {
@@ -859,6 +907,7 @@ void Tab::ActiveStateChanged() {
   UpdateForegroundColors();
   icon_->SetActiveState(IsActive());
   alert_indicator_button_->OnParentTabButtonColorChanged();
+  title_->SetFontList(tab_style_views_->GetFontList());
   DeprecatedLayoutImmediately();
 }
 
@@ -1022,6 +1071,7 @@ void Tab::UpdateIconVisibility() {
   // a non-narrow tab.
   if (!closing_) {
     center_icon_ = false;
+    extra_padding_before_content_ = false;
   }
 
   showing_icon_ = showing_alert_indicator_ = false;
@@ -1049,6 +1099,7 @@ void Tab::UpdateIconVisibility() {
     // While animating to or from the pinned state, pinned tabs are rendered as
     // normal tabs. Force the extra padding on so the favicon doesn't jitter
     // left and then back right again as it resizes through layout regimes.
+    extra_padding_before_content_ = true;
     extra_alert_indicator_padding_ = true;
     return;
   }
@@ -1123,6 +1174,16 @@ void Tab::UpdateIconVisibility() {
     }
   }
 
+  // Don't update padding while the tab is closing, to avoid glitchy-looking
+  // behaviour when the close animation causes the tab to get very small
+  if (!closing_) {
+    // The extra padding is intended to visually balance the close button, so
+    // only include it when the close button is shown or will be shown on hover.
+    // We also check this for active tabs so that the extra padding doesn't pop
+    // in and out as you switch tabs.
+    extra_padding_before_content_ = large_enough_for_close_button;
+  }
+
   extra_alert_indicator_padding_ = showing_alert_indicator_ &&
                                    showing_close_button_ &&
                                    large_enough_for_close_button;
diff --git a/chrome/browser/ui/views/tabs/tab.h b/chrome/browser/ui/views/tabs/tab.h
index 832881025a66b..23b5cdd8a67e9 100644
--- a/chrome/browser/ui/views/tabs/tab.h
+++ b/chrome/browser/ui/views/tabs/tab.h
@@ -276,6 +276,13 @@ class Tab : public gfx::AnimationDelegate,
   // Whether the tab is currently animating from a pinned to an unpinned state.
   bool is_animating_from_pinned_ = false;
 
+  // If there's room, we add additional padding to the left of the favicon to
+  // balance the whitespace inside the non-hovered close button image;
+  // otherwise, the tab contents look too close to the left edge. Once the tabs
+  // get too small, we let the tab contents take the full width, to maximize
+  // visible area.
+  bool extra_padding_before_content_ = false;
+
   // When both the close button and alert indicator are visible, we add extra
   // padding between them to space them out visually.
   bool extra_alert_indicator_padding_ = false;
diff --git a/chrome/browser/ui/views/tabs/tab_close_button.cc b/chrome/browser/ui/views/tabs/tab_close_button.cc
index ac335a68f3fd0..8eef7a2f256c8 100644
--- a/chrome/browser/ui/views/tabs/tab_close_button.cc
+++ b/chrome/browser/ui/views/tabs/tab_close_button.cc
@@ -38,7 +38,7 @@
 #endif
 
 namespace {
-constexpr int kIconSize = 16;
+constexpr int kIconSize = 18;
 constexpr gfx::Size kButtonSize = {28, 28};
 }  // namespace
 
diff --git a/chrome/browser/ui/views/tabs/tab_search_button.cc b/chrome/browser/ui/views/tabs/tab_search_button.cc
index a42855ead9dbe..6bc354f89e5e3 100644
--- a/chrome/browser/ui/views/tabs/tab_search_button.cc
+++ b/chrome/browser/ui/views/tabs/tab_search_button.cc
@@ -21,6 +21,7 @@
 #include "ui/views/view_class_properties.h"
 
 namespace {
+//constexpr int kTh24CRTabSearchCornerRadius = 8;
 constexpr int kCRTabSearchCornerRadius = 10;
 constexpr int kCRTabSearchFlatCornerRadius = 4;
 }  // namespace
@@ -29,7 +30,9 @@ TabSearchButton::TabSearchButton(TabStripController* tab_strip_controller,
                                  Edge flat_edge)
     : TabStripControlButton(tab_strip_controller,
                             PressedCallback(),
-                            vector_icons::kExpandMoreIcon,
+                            features::IsThorium2024()
+                                ? vector_icons::kCaretDownIcon
+                                : vector_icons::kExpandMoreIcon,
                             flat_edge),
       tab_search_bubble_host_(std::make_unique<TabSearchBubbleHost>(
           this,
@@ -40,11 +43,13 @@ TabSearchButton::TabSearchButton(TabStripController* tab_strip_controller,
   GetViewAccessibility().SetName(
       l10n_util::GetStringUTF16(IDS_ACCNAME_TAB_SEARCH));
 
-  SetForegroundFrameActiveColorId(kColorNewTabButtonForegroundFrameActive);
-  SetForegroundFrameInactiveColorId(kColorNewTabButtonForegroundFrameInactive);
-  SetBackgroundFrameActiveColorId(kColorNewTabButtonCRBackgroundFrameActive);
-  SetBackgroundFrameInactiveColorId(
-      kColorNewTabButtonCRBackgroundFrameInactive);
+  if (!features::IsThorium2024()) {
+    SetForegroundFrameActiveColorId(kColorNewTabButtonForegroundFrameActive);
+    SetForegroundFrameInactiveColorId(kColorNewTabButtonForegroundFrameInactive);
+    SetBackgroundFrameActiveColorId(kColorNewTabButtonCRBackgroundFrameActive);
+    SetBackgroundFrameInactiveColorId(
+        kColorNewTabButtonCRBackgroundFrameInactive);
+  }
 
   UpdateColors();
 }
@@ -61,7 +66,15 @@ void TabSearchButton::NotifyClick(const ui::Event& event) {
 }
 
 int TabSearchButton::GetCornerRadius() const {
-  return kCRTabSearchCornerRadius;
+  static const bool rectangular_tabs =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs");
+  if (rectangular_tabs) {
+    return kCRTabSearchFlatCornerRadius;
+  } else {
+    return features::IsThorium2024()
+               ? TabStripControlButton::kButtonSize.width() / 2
+               : kCRTabSearchCornerRadius;
+  }
 }
 
 int TabSearchButton::GetFlatCornerRadius() const {
diff --git a/chrome/browser/ui/views/tabs/tab_strip_control_button.cc b/chrome/browser/ui/views/tabs/tab_strip_control_button.cc
index d0ee903b51d37..b23a8f1037956 100644
--- a/chrome/browser/ui/views/tabs/tab_strip_control_button.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip_control_button.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/command_line.h"
 #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h"
 #include "chrome/browser/ui/views/tabs/tab_strip.h"
 #include "chrome/browser/ui/views/tabs/tab_strip_controller.h"
@@ -225,7 +226,13 @@ void TabStripControlButton::UpdateBackground() {
 }
 
 int TabStripControlButton::GetCornerRadius() const {
-  return TabStripControlButton::kButtonSize.width() / 2;
+  static const bool rectangular_tabs =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs");
+  if (rectangular_tabs) {
+    return 4;
+  } else {
+    return TabStripControlButton::kButtonSize.width() / 2;
+  }
 }
 
 int TabStripControlButton::GetFlatCornerRadius() const {
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.cc b/chrome/browser/ui/views/tabs/tab_style_views.cc
index 65676013fece9..d45fc4f3e1754 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -7,10 +7,12 @@
 #include <algorithm>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/strings/strcat.h"
+#include "build/build_config.h"
 #include "cc/paint/paint_record.h"
 #include "cc/paint/paint_shader.h"
 #include "chrome/browser/themes/theme_properties.h"
@@ -18,6 +20,7 @@
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/tabs/tab_types.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/frame/top_container_background.h"
@@ -39,6 +42,7 @@
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/gfx/scoped_canvas.h"
 #include "ui/views/controls/focus_ring.h"
+#include "ui/views/style/typography.h"
 #include "ui/views/widget/widget.h"
 
 namespace {
@@ -85,6 +89,7 @@ class TabStyleViewsImpl : public TabStyleViews {
   float GetCurrentActiveOpacity() const override;
   TabActive GetApparentActiveState() const override;
   TabStyle::TabColors CalculateTargetColors() const override;
+  const gfx::FontList& GetFontList() const override;
   void PaintTab(gfx::Canvas* canvas) const override;
   void SetHoverLocation(const gfx::Point& location) override;
   void ShowHover(TabStyle::ShowHoverStyle style) override;
@@ -190,6 +195,9 @@ class TabStyleViewsImpl : public TabStyleViews {
   const raw_ptr<const Tab> tab_;
 
   std::unique_ptr<GlowHoverController> hover_controller_;
+
+  gfx::FontList normal_font_;
+  gfx::FontList heavy_font_;
 };
 
 // TabStyleViewsImpl ----------------------------------------------------------
@@ -198,7 +206,11 @@ TabStyleViewsImpl::TabStyleViewsImpl(Tab* tab)
     : tab_(tab),
       hover_controller_((tab && gfx::Animation::ShouldRenderRichAnimation())
                             ? new GlowHoverController(tab)
-                            : nullptr) {
+                            : nullptr),
+      normal_font_(views::TypographyProvider::Get().GetFont(views::style::CONTEXT_LABEL,
+                                                           views::style::STYLE_PRIMARY)),
+      heavy_font_(views::TypographyProvider::Get().GetFont(views::style::CONTEXT_BUTTON_MD,
+                                                           views::style::STYLE_PRIMARY)) {
   // `tab_` must not be nullptr.
   CHECK(tab_);
   // TODO(dfried): create a new STYLE_PROMINENT or similar to use instead of
@@ -244,7 +256,8 @@ SkPath TabStyleViewsImpl::GetPath(TabStyle::PathType path_type,
     // this. Detached tab shapes do not need to respect this.
     if (path_type != TabStyle::PathType::kInteriorClip &&
         path_type != TabStyle::PathType::kHitTest) {
-      tab_height -= GetLayoutConstant(TAB_STRIP_PADDING) * scale;
+      // Keep this in Thorium
+      tab_height -= GetLayoutConstant(TAB_MARGIN) * scale;
       tab_height -= GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP) * scale;
     }
 
@@ -254,16 +267,19 @@ SkPath TabStyleViewsImpl::GetPath(TabStyle::PathType path_type,
     }
 
     int left = aligned_bounds.x() + extension_corner_radius;
-    int top = aligned_bounds.y() + GetLayoutConstant(TAB_STRIP_PADDING) * scale;
+    // Keep this in Thorium
+    int top = aligned_bounds.y() + GetLayoutConstant(TAB_INACTIVE_PADDING) * scale;
     int right = aligned_bounds.right() - extension_corner_radius;
-    const int bottom = top + tab_height;
+    // Keep this in Thorium
+    int bottom = top + tab_height;
 
     // For maximized and full screen windows, extend the tab hit test to the top
     // of the tab, encompassing the top padding. This makes it easy to click on
     // tabs by moving the mouse to the top of the screen.
     if (path_type == TabStyle::PathType::kHitTest &&
         tab()->controller()->IsFrameCondensed()) {
-      top -= GetLayoutConstant(TAB_STRIP_PADDING) * scale;
+      // Keep this in Thorium
+      top -= GetLayoutConstant(TAB_MARGIN) * scale;
       // Don't round the top corners to avoid creating dead space between tabs.
       top_content_corner_radius = 0;
     }
@@ -298,6 +314,21 @@ SkPath TabStyleViewsImpl::GetPath(TabStyle::PathType path_type,
       }
     }
 
+  #if BUILDFLAG(IS_LINUX)
+    if (features::IsThorium2024()) {
+      constexpr float Th24StrokeOffset = 1.0f;
+      top -= Th24StrokeOffset;
+      //bottom -= Th24StrokeOffset;
+    }
+  #else
+    if (features::IsThorium2024()) {
+      VLOG(0) << "Th24StrokeOffset on Windows is imperfect";
+      constexpr float Th24StrokeOffset = 1.0f;
+      top -= Th24StrokeOffset;
+      //bottom -= Th24StrokeOffset;
+    }
+  #endif
+
     // Radii are clockwise from top left.
     const SkVector radii[4] = {
         SkVector(top_content_corner_radius, top_content_corner_radius),
@@ -581,6 +612,18 @@ TabStyle::TabColors TabStyleViewsImpl::CalculateTargetColors() const {
           close_button_focus_ring_color};
 }
 
+const gfx::FontList& TabStyleViewsImpl::GetFontList() const {
+  // Don't want to have to keep re-computing this value.
+  static const bool prominent_active_tab_titles =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("prominent-active-tab-titles");
+
+  if (prominent_active_tab_titles && tab_->IsActive()) {
+    return heavy_font_;
+  }
+
+  return normal_font_;
+}
+
 void TabStyleViewsImpl::PaintTab(gfx::Canvas* canvas) const {
   std::optional<int> active_tab_fill_id;
   if (tab_->GetThemeProvider()->HasCustomImage(IDR_THEME_TOOLBAR)) {
@@ -731,6 +774,11 @@ float TabStyleViewsImpl::GetSeparatorOpacity(bool for_layout,
   const Tab* const adjacent_tab =
       tab()->controller()->GetAdjacentTab(tab(), leading ? -1 : 1);
 
+  // The separator should never appear at the end of the tab strip.
+  //if (!adjacent_tab && !leading) {
+      //return 0.0f;
+  //}
+
   const Tab* const left_tab = leading ? adjacent_tab : tab();
   const Tab* const right_tab = leading ? tab() : adjacent_tab;
   const bool adjacent_to_header =
@@ -965,6 +1013,10 @@ void TabStyleViewsImpl::PaintTabBackgroundFill(
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
     flags.setColor(GetCurrentTabBackgroundColor(selection_state, hovered));
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("transparent-tabs") &&
+        selection_state != TabStyle::TabSelectionState::kActive) {
+        flags.setAlphaf(0.7f);
+    }
     canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),
                      flags);
   }
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.h b/chrome/browser/ui/views/tabs/tab_style_views.h
index 4160d9c4d503f..54ae85ef82a3e 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.h
+++ b/chrome/browser/ui/views/tabs/tab_style_views.h
@@ -48,6 +48,9 @@ class TabStyleViews {
                          TabStyle::RenderUnits render_units =
                              TabStyle::RenderUnits::kPixels) const = 0;
 
+  // Returns the appropriate fonts for the current theme and active state.
+  virtual const gfx::FontList& GetFontList() const = 0;
+
   // Paints the tab.
   virtual void PaintTab(gfx::Canvas* canvas) const = 0;
 
diff --git a/chrome/browser/ui/views/toolbar/BUILD.gn b/chrome/browser/ui/views/toolbar/BUILD.gn
index e368f860ec9a7..b81b109035cdd 100644
--- a/chrome/browser/ui/views/toolbar/BUILD.gn
+++ b/chrome/browser/ui/views/toolbar/BUILD.gn
@@ -39,6 +39,8 @@ source_set("toolbar") {
     "pinned_toolbar_button_status_indicator.h",
     "reload_button.cc",
     "reload_button.h",
+    "restore_tab_button.cc",
+    "restore_tab_button.h",
     "toolbar_action_hover_card_bubble_view.cc",
     "toolbar_action_hover_card_bubble_view.h",
     "toolbar_action_hover_card_controller.cc",
diff --git a/chrome/browser/ui/views/toolbar/chrome_labs/chrome_labs_bubble_view.cc b/chrome/browser/ui/views/toolbar/chrome_labs/chrome_labs_bubble_view.cc
index b071682471a32..94123478b7fab 100644
--- a/chrome/browser/ui/views/toolbar/chrome_labs/chrome_labs_bubble_view.cc
+++ b/chrome/browser/ui/views/toolbar/chrome_labs/chrome_labs_bubble_view.cc
@@ -112,7 +112,7 @@ ChromeLabsBubbleView::ChromeLabsBubbleView(views::Button* anchor_view,
   SetLayoutManager(std::make_unique<views::BoxLayout>())
       ->SetOrientation(views::BoxLayout::Orientation::kVertical);
   set_fixed_width(views::LayoutProvider::Get()->GetDistanceMetric(
-      views::DISTANCE_BUBBLE_PREFERRED_WIDTH));
+      views::DISTANCE_MODAL_DIALOG_PREFERRED_WIDTH));
   set_margins(gfx::Insets(0));
   SetEnableArrowKeyTraversal(true);
   // Set `kDialog` to avoid the BubbleDialogDelegate returning a default of
@@ -124,7 +124,7 @@ ChromeLabsBubbleView::ChromeLabsBubbleView(views::Button* anchor_view,
   // TODO(crbug.com/40797818): Currently basing this off what extension menu
   // uses for sizing as suggested as an initial fix by UI. Discuss a more formal
   // solution.
-  constexpr int kMaxChromeLabsHeightDp = 448;
+  constexpr int kMaxChromeLabsHeightDp = 560;
   auto scroll_view = std::make_unique<views::ScrollView>(
       views::ScrollView::ScrollWithLayers::kEnabled);
   // TODO(elainechien): Check with UI whether we want to draw overflow
diff --git a/chrome/browser/ui/views/toolbar/restore_tab_button.cc b/chrome/browser/ui/views/toolbar/restore_tab_button.cc
new file mode 100644
index 0000000000000..97d29250ae49d
--- /dev/null
+++ b/chrome/browser/ui/views/toolbar/restore_tab_button.cc
@@ -0,0 +1,72 @@
+// Copyright 2024 The Chromium Authors and Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/toolbar/restore_tab_button.h"
+
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/command_updater.h"
+#include "chrome/browser/external_protocol/external_protocol_handler.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/view_ids.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/vector_icons/vector_icons.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/metadata/metadata_impl_macros.h"
+#include "ui/base/ui_base_features.h"
+#include "ui/views/accessibility/view_accessibility.h"
+#include "ui/views/controls/button/button_controller.h"
+
+RestoreTabButton::RestoreTabButton(CommandUpdater* command_updater)
+    : ToolbarButton(base::BindRepeating(&RestoreTabButton::ButtonPressed,
+                                        base::Unretained(this))),
+      command_updater_(command_updater) {
+
+  SetIcon();
+
+  SetTooltipText(l10n_util::GetStringUTF16(IDS_RESTORE_TAB_BUTTON_TOOLTIP));
+  SetAccessibleName(l10n_util::GetStringUTF16(IDS_RESTORE_TAB_BUTTON_NAME));
+  button_controller()->set_notify_action(
+      views::ButtonController::NotifyAction::kOnPress);
+  SetID(VIEW_ID_RESTORE_TAB_BUTTON);
+  SizeToPreferredSize();
+}
+
+RestoreTabButton::~RestoreTabButton() = default;
+
+void RestoreTabButton::ButtonPressed() {
+  ExternalProtocolHandler::PermitLaunchUrl();
+
+  int command;
+  // See chrome/app/chrome_command_ids.h for all possible commands
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("button-command")) {
+    const std::string button_command =
+        base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("button-command");
+    command = base::StringToInt(button_command, &command);
+    LOG(ERROR) << command;
+  } else {
+    command = IDC_RESTORE_TAB;
+  }
+  const int command_to_exec = command;
+
+  ExecuteBrowserCommand(command_to_exec);
+}
+
+void RestoreTabButton::SetIcon() {
+  const gfx::VectorIcon& restore_icon =
+      vector_icons::kRestoreTabIcon;
+  SetVectorIcons(restore_icon, restore_icon);
+}
+
+void RestoreTabButton::ExecuteBrowserCommand(int command) {
+  if (!command_updater_) {
+    return;
+  }
+  command_updater_->ExecuteCommand(command);
+}
+
+BEGIN_METADATA(RestoreTabButton)
+END_METADATA
diff --git a/chrome/browser/ui/views/toolbar/restore_tab_button.h b/chrome/browser/ui/views/toolbar/restore_tab_button.h
new file mode 100644
index 0000000000000..43b9476bb127c
--- /dev/null
+++ b/chrome/browser/ui/views/toolbar/restore_tab_button.h
@@ -0,0 +1,31 @@
+// Copyright 2024 The Chromium Authors and Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_TOOLBAR_RESTORE_TAB_BUTTON_H_
+#define CHROME_BROWSER_UI_VIEWS_TOOLBAR_RESTORE_TAB_BUTTON_H_
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/ui/views/toolbar/toolbar_button.h"
+#include "ui/base/metadata/metadata_header_macros.h"
+
+class CommandUpdater;
+
+class RestoreTabButton : public ToolbarButton {
+  METADATA_HEADER(RestoreTabButton, ToolbarButton)
+
+ public:
+  explicit RestoreTabButton(CommandUpdater* command_updater);
+  RestoreTabButton(const RestoreTabButton&) = delete;
+  RestoreTabButton& operator=(const RestoreTabButton&) = delete;
+  ~RestoreTabButton() override;
+
+ private:
+  void SetIcon();
+  void ButtonPressed();
+  void ExecuteBrowserCommand(int command);
+
+  raw_ptr<CommandUpdater, DanglingUntriaged> command_updater_;
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_TOOLBAR_RESTORE_TAB_BUTTON_H_
diff --git a/chrome/browser/ui/views/toolbar/toolbar_button.cc b/chrome/browser/ui/views/toolbar/toolbar_button.cc
index 36ba4fcfc2683..584c2b6e10941 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_button.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_button.cc
@@ -176,7 +176,7 @@ void ToolbarButton::UpdateColorsAndInsets() {
 
   // ToolbarButton height is constrained by the height of the location bar.
   const int extra_height = std::max(
-      0, target_size.height() - GetLayoutConstant(LOCATION_BAR_HEIGHT));
+      0, target_size.height() - GetLayoutConstant(TOOLBAR_BUTTON_HEIGHT));
   const gfx::Insets paint_insets =
       gfx::Insets(extra_height / 2) + *GetProperty(views::kInternalPaddingKey);
 
@@ -262,6 +262,9 @@ int ToolbarButton::GetIconSize() const {
   if (ui::TouchUiController::Get()->touch_ui()) {
     return kDefaultTouchableIconSize;
   }
+  if (features::IsThorium2024()) {
+    return kDefaultIconSizeThorium2024;
+  }
 
   return kDefaultIconSizeChromeRefresh;
 }
diff --git a/chrome/browser/ui/views/toolbar/toolbar_button.h b/chrome/browser/ui/views/toolbar/toolbar_button.h
index d85292e244d48..f3775f4cd4ec0 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_button.h
+++ b/chrome/browser/ui/views/toolbar/toolbar_button.h
@@ -226,6 +226,13 @@ class ToolbarButton : public views::LabelButton,
 
   static constexpr int kDefaultIconSize = 16;
   static constexpr int kDefaultIconSizeChromeRefresh = 20;
+  // Force drawing the <20DP version of .icon files
+  // We still want it to look like 20 like above, but by making
+  // it ever so slightly less, the vector icon painter will choose
+  // the smaller version, if it exists in the .icon file as a
+  // separate canvas. Chose 4 9's as even on an 8K screen, the
+  // difference should be less than 1 pixel.
+  static constexpr float kDefaultIconSizeThorium2024 = 20.0f;
   static constexpr int kDefaultTouchableIconSize = 24;
 
  private:
diff --git a/chrome/browser/ui/views/toolbar/toolbar_view.cc b/chrome/browser/ui/views/toolbar/toolbar_view.cc
index 577215577d9ac..3d63a1a714ef3 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -81,6 +81,7 @@
 #include "chrome/browser/ui/views/toolbar/home_button.h"
 #include "chrome/browser/ui/views/toolbar/pinned_toolbar_actions_container.h"
 #include "chrome/browser/ui/views/toolbar/reload_button.h"
+#include "chrome/browser/ui/views/toolbar/restore_tab_button.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_button.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_controller.h"
 #include "chrome/browser/ui/web_applications/app_browser_controller.h"
@@ -358,8 +359,12 @@ void ToolbarView::Init() {
   std::unique_ptr<HomeButton> home = std::make_unique<HomeButton>(
       base::BindRepeating(callback, browser_, IDC_HOME), prefs);
 
+  std::unique_ptr<RestoreTabButton> restore =
+      std::make_unique<RestoreTabButton>(browser_->command_controller());
+
   std::unique_ptr<ExtensionsToolbarContainer> extensions_container;
   std::unique_ptr<views::View> toolbar_divider;
+  std::unique_ptr<views::View> toolbar_divider2;
 
   // Do not create the extensions or browser actions container if it is a guest
   // profile (only regular and incognito profiles host extensions).
@@ -369,6 +374,9 @@ void ToolbarView::Init() {
 
     toolbar_divider = std::make_unique<views::View>();
   }
+  if (features::EnableRestoreTabButton()) {
+    toolbar_divider2 = std::make_unique<views::View>();
+  }
   std::unique_ptr<media_router::CastToolbarButton> cast;
   if (media_router::MediaRouterEnabled(browser_->profile()))
     cast = media_router::CastToolbarButton::Create(browser_);
@@ -393,6 +401,15 @@ void ToolbarView::Init() {
   reload_ = container_view_->AddChildView(std::move(reload));
   home_ = container_view_->AddChildView(std::move(home));
 
+  if (features::EnableRestoreTabButton()) {
+    toolbar_divider2_ =
+        container_view_->AddChildView(std::move(toolbar_divider2));
+    toolbar_divider2_->SetPreferredSize(
+        gfx::Size(GetLayoutConstant(TOOLBAR_DIVIDER_WIDTH),
+                  GetLayoutConstant(TOOLBAR_DIVIDER_HEIGHT)));
+    restore_ = container_view_->AddChildView(std::move(restore));
+  }
+
   location_bar_ = container_view_->AddChildView(std::move(location_bar));
 
   if (extensions_container) {
@@ -494,6 +511,18 @@ void ToolbarView::Init() {
                                browser_->profile()->IsGuestSession() ||
                                browser_->profile()->IsRegularProfile();
 #endif
+
+  const std::string sab_value = base::CommandLine::ForCurrentProcess()->
+                                GetSwitchValueASCII("show-avatar-button");
+  if (sab_value == "always") {
+    show_avatar_toolbar_button = true;
+  } else if (sab_value == "incognito-and-guest") {
+    show_avatar_toolbar_button = browser_->profile()->IsIncognitoProfile() ||
+                                 browser_->profile()->IsGuestSession();
+  } else if (sab_value == "never") {
+    show_avatar_toolbar_button = false;
+  }
+
   avatar_->SetVisible(show_avatar_toolbar_button);
 
 #if BUILDFLAG(ENABLE_WEBUI_TAB_STRIP)
@@ -1004,6 +1033,12 @@ void ToolbarView::InitLayout() {
         gfx::Insets::VH(0, GetLayoutConstant(TOOLBAR_DIVIDER_SPACING)));
   }
 
+  if (toolbar_divider2_) {
+    toolbar_divider2_->SetProperty(
+        views::kMarginsKey,
+        gfx::Insets::VH(0, GetLayoutConstant(TOOLBAR_DIVIDER_SPACING)));
+  }
+
   if (base::FeatureList::IsEnabled(features::kResponsiveToolbar)) {
     constexpr int kToolbarFlexOrderStart = 1;
 
@@ -1076,15 +1111,21 @@ void ToolbarView::LayoutCommon() {
   app_menu_button_->SetTrailingMargin(
       extend_buttons_to_edge ? interior_margin.right() : 0);
 
+  const SkColor toolbar_extension_separator_color =
+      GetColorProvider()->GetColor(kColorToolbarExtensionSeparatorEnabled);
+
   if (toolbar_divider_ && extensions_container_) {
     views::ManualLayoutUtil(layout_manager_)
         .SetViewHidden(toolbar_divider_, !extensions_container_->GetVisible());
-    const SkColor toolbar_extension_separator_color =
-        GetColorProvider()->GetColor(kColorToolbarExtensionSeparatorEnabled);
     toolbar_divider_->SetBackground(views::CreateRoundedRectBackground(
         toolbar_extension_separator_color,
         GetLayoutConstant(TOOLBAR_DIVIDER_CORNER_RADIUS)));
   }
+  if (toolbar_divider2_) {
+  toolbar_divider2_->SetBackground(views::CreateRoundedRectBackground(
+      toolbar_extension_separator_color,
+      GetLayoutConstant(TOOLBAR_DIVIDER_CORNER_RADIUS)));
+  }
   // Cast button visibility is controlled externally.
 }
 
diff --git a/chrome/browser/ui/views/toolbar/toolbar_view.h b/chrome/browser/ui/views/toolbar/toolbar_view.h
index 1688062ae52ab..55dba3d1d4d45 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_view.h
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.h
@@ -54,6 +54,7 @@ class ExtensionsToolbarCoordinator;
 class ManagementToolbarButton;
 class MediaToolbarButtonView;
 class ReloadButton;
+class RestoreTabButton;
 class PinnedToolbarActionsContainer;
 class ToolbarButton;
 class AvatarToolbarButtonBrowserTest;
@@ -162,6 +163,7 @@ class ToolbarView : public views::AccessiblePaneView,
   ToolbarButton* forward_button() const { return forward_; }
   ExtensionsToolbarButton* GetExtensionsButton() const;
   ReloadButton* reload_button() const { return reload_; }
+  RestoreTabButton* restore_tab_button() const { return restore_; }
   LocationBarView* location_bar() const { return location_bar_; }
   CustomTabBarView* custom_tab_bar() { return custom_tab_bar_; }
   BatterySaverButton* battery_saver_button() const {
@@ -298,11 +300,13 @@ class ToolbarView : public views::AccessiblePaneView,
   raw_ptr<ToolbarButton> back_ = nullptr;
   raw_ptr<ToolbarButton> forward_ = nullptr;
   raw_ptr<ReloadButton> reload_ = nullptr;
+  raw_ptr<RestoreTabButton> restore_ = nullptr;
   raw_ptr<HomeButton> home_ = nullptr;
   raw_ptr<CustomTabBarView> custom_tab_bar_ = nullptr;
   raw_ptr<LocationBarView> location_bar_ = nullptr;
   raw_ptr<ExtensionsToolbarContainer> extensions_container_ = nullptr;
   raw_ptr<views::View> toolbar_divider_ = nullptr;
+  raw_ptr<views::View> toolbar_divider2_ = nullptr;
   raw_ptr<ChromeLabsButton> chrome_labs_button_ = nullptr;
   raw_ptr<BatterySaverButton> battery_saver_button_ = nullptr;
   raw_ptr<PerformanceInterventionButton> performance_intervention_button_ =
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index 743fd86a35a10..e7679d12e2c8d 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -49,6 +49,7 @@
 #include "chrome/browser/ui/webui/policy/policy_ui.h"
 #include "chrome/browser/ui/webui/privacy_sandbox/privacy_sandbox_internals_ui.h"
 #include "chrome/browser/ui/webui/suggest_internals/suggest_internals_ui.h"
+#include "chrome/browser/ui/webui/thorium_webui.h"
 #include "chrome/browser/ui/webui/webui_util.h"
 #include "chrome/common/buildflags.h"
 #include "chrome/common/chrome_features.h"
@@ -695,6 +696,10 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<privacy_sandbox_internals::PrivacySandboxInternalsUI>;
   }
 
+  if (url.host_piece() == chrome::kChromeUIEggsHost) {
+    return &NewWebUI<ThoriumWebUILoad>;
+  }
+
   return nullptr;
 }
 
diff --git a/chrome/browser/ui/webui/cr_components/theme_color_picker/customize_chrome_colors.h b/chrome/browser/ui/webui/cr_components/theme_color_picker/customize_chrome_colors.h
index f7dcd7cbfee20..6a0be3307f6c6 100644
--- a/chrome/browser/ui/webui/cr_components/theme_color_picker/customize_chrome_colors.h
+++ b/chrome/browser/ui/webui/cr_components/theme_color_picker/customize_chrome_colors.h
@@ -27,6 +27,17 @@ constexpr int kCustomizeChromeColorIds[] = {
     6,   // Yellow and white.
     5,   // Beige and white.
     1,   // Warm grey.
+    7,   // Green and white.
+    8,   // Light teal and white.
+    9,   // Light purple and white.
+    10,  // Pink and white.
+    11,  // Beige.
+    12,  // Orange.
+    18,  // Dark red and orange.
+    19,  // Dark green.
+    12,  // Orange.
+    18,  // Dark red and orange.
+    19,  // Dark green.
 };
 
 // The chrome colors selected and ordered by |kCustomizeChromeColorIds|.
diff --git a/chrome/browser/ui/webui/thorium_webui.h b/chrome/browser/ui/webui/thorium_webui.h
new file mode 100644
index 0000000000000..897bacb966ca8
--- /dev/null
+++ b/chrome/browser/ui/webui/thorium_webui.h
@@ -0,0 +1,78 @@
+// Copyright 2024 Alex313031
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THORIUM_WEBUI_H_
+#define THORIUM_WEBUI_H_
+
+#include "base/memory/ref_counted_memory.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/url_data_source.h"
+#include "content/public/browser/web_ui.h"
+#include "content/public/browser/web_ui_controller.h"
+#include "services/network/public/mojom/content_security_policy.mojom.h"
+
+class ThoriumDataSource : public content::URLDataSource {
+ public:
+  ThoriumDataSource() {}
+  ThoriumDataSource(const ThoriumDataSource&) = delete;
+  ThoriumDataSource& operator=(const ThoriumDataSource&) = delete;
+  std::string GetSource() override;
+  std::string GetMimeType(const GURL& url) override;
+  std::string GetContentSecurityPolicy(network::mojom::CSPDirectiveName directive) override;
+  void StartDataRequest(const GURL& url,
+                        const content::WebContents::Getter& wc_getter,
+                        GotDataCallback callback) override;
+};
+
+std::string ThoriumDataSource::GetSource() { return "eggs"; }
+std::string ThoriumDataSource::GetMimeType(const GURL& url) { return "text/html"; }
+std::string ThoriumDataSource::GetContentSecurityPolicy(network::mojom::CSPDirectiveName directive) {
+  if (directive == network::mojom::CSPDirectiveName::ScriptSrc)
+    return "script-src 'unsafe-inline'";
+  return std::string();
+}
+void ThoriumDataSource::StartDataRequest(const GURL& url,
+                      const content::WebContents::Getter& wc_getter,
+                      GotDataCallback callback) {
+  std::string source = R"(
+    <html>
+    <head>
+      <title>Thorium Easter Eggs</title>
+      <meta name="color-scheme" content="light dark">
+      <meta name="viewport" content="width=device-width, initial-scale=1">
+      <link rel="shortcut icon" type="image/x-icon" href="chrome://theme/current-channel-logo@2x">
+    <style>
+      @import url(chrome://resources/css/text_defaults_md.css);
+      body { text-align: center; align-content: center; max-width: 75%; margin: auto;}
+      img { max-width: 75%; height: auto; }
+    </style>
+    </head>
+    <body>
+      <h2><u>Thorium Easter Eggs WebUI Page</u></h3>
+      <hr>
+      <p>
+        <img src="chrome://theme/IDR_PRODUCT_THORIUM_ELEMENT">
+        <hr>
+        <img src="chrome://theme/IDR_PRODUCT_THORIUM_ATOMIC">
+        <img src="chrome://theme/IDR_PRODUCT_CHROMIUM_QUESTION">
+        <img src="chrome://theme/IDR_PRODUCT_THORIUM_GUY">
+        <img src="chrome://theme/IDR_PRODUCT_CHROMIUM_BLANK">
+        <img src="chrome://theme/IDR_PRODUCT_AI_CHROME">
+      </p>
+    </body>
+    </html>
+  )";
+  std::move(callback).Run(base::MakeRefCounted<base::RefCountedString>(std::move(source)));
+}
+
+class ThoriumWebUILoad : public content::WebUIController {
+ public:
+  ThoriumWebUILoad(content::WebUI* web_ui) : content::WebUIController(web_ui) {
+    content::URLDataSource::Add(Profile::FromWebUI(web_ui), std::make_unique<ThoriumDataSource>());
+  }
+  ThoriumWebUILoad(const ThoriumWebUILoad&) = delete;
+  ThoriumWebUILoad& operator=(const ThoriumWebUILoad&) = delete;
+};
+
+#endif  // THORIUM_WEBUI_H_
diff --git a/chrome/common/chrome_paths.cc b/chrome/common/chrome_paths.cc
index 3c569bc610124..160d1bd4090a3 100644
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -59,7 +59,7 @@ const base::FilePath::CharType kFilepathSinglePrefExtensions[] =
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
     FILE_PATH_LITERAL("/usr/share/google-chrome/extensions");
 #else
-    FILE_PATH_LITERAL("/usr/share/chromium/extensions");
+    FILE_PATH_LITERAL("/usr/share/thorium/extensions");
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
@@ -573,8 +573,7 @@ bool PathProvider(int key, base::FilePath* result) {
         return false;
       }
 
-      cur = cur.Append(FILE_PATH_LITERAL("Google"))
-                .Append(FILE_PATH_LITERAL("Chrome"))
+      cur = cur.Append(FILE_PATH_LITERAL("Thorium"))
                 .Append(FILE_PATH_LITERAL("External Extensions"));
 #else
       if (!base::PathService::Get(base::DIR_MODULE, &cur)) {
@@ -607,7 +606,7 @@ bool PathProvider(int key, base::FilePath* result) {
           FILE_PATH_LITERAL("/Library/Google/Chrome/NativeMessagingHosts"));
 #else
       cur = base::FilePath(FILE_PATH_LITERAL(
-          "/Library/Application Support/Chromium/NativeMessagingHosts"));
+          "/Library/Application Support/Thorium/NativeMessagingHosts"));
 #endif
 #else  // BUILDFLAG(IS_MAC)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
@@ -615,7 +614,7 @@ bool PathProvider(int key, base::FilePath* result) {
           FILE_PATH_LITERAL("/etc/opt/chrome/native-messaging-hosts"));
 #else
       cur = base::FilePath(
-          FILE_PATH_LITERAL("/etc/chromium/native-messaging-hosts"));
+          FILE_PATH_LITERAL("/etc/thorium/native-messaging-hosts"));
 #endif
 #endif  // !BUILDFLAG(IS_MAC)
       break;
diff --git a/chrome/common/webui_url_constants.cc b/chrome/common/webui_url_constants.cc
index 248b6795e8cbe..488bade160e37 100644
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -75,6 +75,7 @@ bool IsSystemWebUIHost(std::string_view host) {
 // These hosts will also be suggested by BuiltinProvider.
 base::span<const base::cstring_view> ChromeURLHosts() {
   static constexpr auto kChromeURLHosts = std::to_array<base::cstring_view>({
+      kChromeUIEggsHost,
       kChromeUIAboutHost,
       kChromeUIAccessibilityHost,
 #if !BUILDFLAG(IS_ANDROID)
diff --git a/chrome/common/webui_url_constants.h b/chrome/common/webui_url_constants.h
index d1a8dc8342177..a407f00138376 100644
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -32,6 +32,8 @@ namespace chrome {
 // Not all components have corresponding URLs and vice versa. Only add as
 // needed.
 // Please keep in alphabetical order, with OS/feature specific sections below.
+inline constexpr char kChromeUIEggsHost[] = "eggs";
+inline constexpr char kChromeUIEggsURL[] = "chrome://eggs/";
 inline constexpr char kChromeUIAboutHost[] = "about";
 inline constexpr char kChromeUIAboutURL[] = "chrome://about/";
 inline constexpr char kChromeUIAccessCodeCastHost[] = "access-code-cast";
diff --git a/components/lens/lens_features.cc b/components/lens/lens_features.cc
index e821793248fe3..7815ad6d1d167 100644
--- a/components/lens/lens_features.cc
+++ b/components/lens/lens_features.cc
@@ -7,6 +7,7 @@
 #include "base/feature_list.h"
 #include "base/metrics/field_trial_params.h"
 #include "build/build_config.h"
+#include "chrome/browser/ui/thorium_2024.h"
 
 namespace lens::features {
 
@@ -47,7 +48,7 @@ BASE_FEATURE(kLensOverlay,
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_IOS)
              base::FEATURE_DISABLED_BY_DEFAULT
 #else
-             base::FEATURE_ENABLED_BY_DEFAULT
+             base::FEATURE_DISABLED_BY_DEFAULT
 #endif
 );
 
diff --git a/components/resources/search_engine_choice_scaled_resources.grdp b/components/resources/search_engine_choice_scaled_resources.grdp
index 87d186a04e66c..01beccd365540 100644
--- a/components/resources/search_engine_choice_scaled_resources.grdp
+++ b/components/resources/search_engine_choice_scaled_resources.grdp
@@ -6,6 +6,7 @@
     <structure type="chrome_scaled_image" name="IDR_GOOGLE_COM_PNG" file="google_chrome/google_search_logo.png" />
   </if>
   <structure type="chrome_scaled_image" name="IDR_AR_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
+  <structure type="chrome_scaled_image" name="IDR_ASK_COM_PNG" file="search_engine_choice/ask_com.png" />
   <structure type="chrome_scaled_image" name="IDR_AT_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
   <structure type="chrome_scaled_image" name="IDR_AU_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
   <structure type="chrome_scaled_image" name="IDR_BING_COM_PNG" file="search_engine_choice/bing_com.png" />
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 9e5567aec56dc..0e3978ff8da39 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3538,7 +3538,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     }
   }
 
-#if BUILDFLAG(IS_WIN) && !defined(OFFICIAL_BUILD)
+#if BUILDFLAG(IS_WIN) && !defined(OFFICIAL_BUILD) || BUILDFLAG(THORIUM_DEBUG)
   // Needed because we can't show the dialog from the sandbox. Don't pass
   // --no-sandbox in official builds because that would bypass the bad_flgs
   // prompt.
diff --git a/ui/base/ui_base_features.cc b/ui/base/ui_base_features.cc
index 595af68372edc..348d245dfc586 100644
--- a/ui/base/ui_base_features.cc
+++ b/ui/base/ui_base_features.cc
@@ -498,6 +498,41 @@ bool IsLacrosColorManagementEnabled() {
   return base::FeatureList::IsEnabled(kLacrosColorManagement);
 }
 
+BASE_FEATURE(kThorium2024,
+             "Thorium2024",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
+bool IsThorium2024() {
+  static const bool Th24flag =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("th24");
+  return base::FeatureList::IsEnabled(kThorium2024) || Th24flag;
+}
+
+BASE_FEATURE(kDownloadShelf,
+             "DownloadShelf",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
+bool DownloadShelf() {
+  //if (features::IsThorium2024()) {
+    //return base::FeatureList::IsEnabled(kThorium2024);
+  //}
+  return base::FeatureList::IsEnabled(kDownloadShelf);
+}
+
+BASE_FEATURE(kRestoreTabButton,
+             "RestoreTabButton",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
+bool EnableRestoreTabButton() {
+  return base::FeatureList::IsEnabled(kRestoreTabButton);
+}
+
+bool IsVerbose() {
+  static const bool is_verbose =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("verbose");
+  return is_verbose;
+}
+
 BASE_FEATURE(kBubbleMetricsApi,
              "BubbleMetricsApi",
              base::FEATURE_DISABLED_BY_DEFAULT);
diff --git a/ui/base/ui_base_features.h b/ui/base/ui_base_features.h
index a5c3bb6349099..4624cb7005e43 100644
--- a/ui/base/ui_base_features.h
+++ b/ui/base/ui_base_features.h
@@ -224,6 +224,18 @@ COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kLacrosColorManagement);
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 bool IsLacrosColorManagementEnabled();
 
+// Used to revert some stupid UI decisions for Cr23
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kThorium2024);
+COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsThorium2024();
+
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kDownloadShelf);
+COMPONENT_EXPORT(UI_BASE_FEATURES) bool DownloadShelf();
+
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kRestoreTabButton);
+COMPONENT_EXPORT(UI_BASE_FEATURES) bool EnableRestoreTabButton();
+
+COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsVerbose();
+
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kBubbleMetricsApi);
 
diff --git a/ui/linux/linux_ui_factory.cc b/ui/linux/linux_ui_factory.cc
index d21456ab73faa..de14c868fcc26 100644
--- a/ui/linux/linux_ui_factory.cc
+++ b/ui/linux/linux_ui_factory.cc
@@ -175,7 +175,7 @@ SystemTheme GetDefaultSystemTheme() {
     case base::nix::DESKTOP_ENVIRONMENT_PANTHEON:
     case base::nix::DESKTOP_ENVIRONMENT_UNITY:
     case base::nix::DESKTOP_ENVIRONMENT_XFCE:
-      return SystemTheme::kGtk;
+      return SystemTheme::kDefault;
     case base::nix::DESKTOP_ENVIRONMENT_KDE3:
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
     case base::nix::DESKTOP_ENVIRONMENT_KDE5:
@@ -183,7 +183,7 @@ SystemTheme GetDefaultSystemTheme() {
     case base::nix::DESKTOP_ENVIRONMENT_UKUI:
     case base::nix::DESKTOP_ENVIRONMENT_DEEPIN:
     case base::nix::DESKTOP_ENVIRONMENT_LXQT:
-      return SystemTheme::kQt;
+      return SystemTheme::kDefault;
     case base::nix::DESKTOP_ENVIRONMENT_OTHER:
       return SystemTheme::kDefault;
   }
diff --git a/ui/views/controls/button/toggle_button.cc b/ui/views/controls/button/toggle_button.cc
index 1380921296fcf..c7e8a29577398 100644
--- a/ui/views/controls/button/toggle_button.cc
+++ b/ui/views/controls/button/toggle_button.cc
@@ -11,6 +11,7 @@
 #include "base/callback_list.h"
 #include "base/functional/bind.h"
 #include "cc/paint/paint_flags.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "third_party/skia/include/core/SkRect.h"
 #include "ui/accessibility/ax_enums.mojom.h"
 #include "ui/accessibility/ax_node_data.h"
@@ -41,7 +42,14 @@ namespace views {
 namespace {
 
 // Constants are measured in dip.
-constexpr gfx::Size kTrackSize = gfx::Size(26, 16);
+constexpr gfx::Size kTrackSize = gfx::Size(28, 16);
+constexpr gfx::Size kTh24TrackSize = gfx::Size(30, 12);
+
+constexpr int kTrackVerticalMargin = 5;
+constexpr int kTrackHorizontalMargin = 4;
+
+// Insets from the rounded edge of the thumb to the rounded edge of the track.
+constexpr int kTh24ThumbInset = 2;
 constexpr int kThumbInset = -4;
 constexpr int kThumbInsetSelected = -2;
 constexpr int kThumbPressedOutset = 1;
@@ -49,11 +57,15 @@ constexpr int kHoverDiameter = 20;
 constexpr float kBorderStrokeWidth = 1.0f;
 
 const gfx::Size GetTrackSize() {
-  return kTrackSize;
+  return features::IsThorium2024() ? kTh24TrackSize : kTrackSize;
 }
 
 int GetThumbInset(bool is_on) {
-  return is_on ? kThumbInsetSelected : kThumbInset;
+  if (features::IsThorium2024()) {
+     return kTh24ThumbInset;
+  } else {
+    return is_on ? kThumbInsetSelected : kThumbInset;
+  }
 }
 
 std::optional<SkColor> GetSkColorFromVariant(
@@ -148,7 +160,7 @@ class ToggleButton::ThumbView : public View {
         ConvertVariantToSkColor(thumb_off_color_, color_provider);
     SkColor thumb_color =
         color_utils::AlphaBlend(thumb_on_color, thumb_off_color, color_ratio_);
-    if (is_hovered_ && is_on_) {
+    if (!features::IsThorium2024() && is_hovered_ && is_on_) {
       // This will blend and additional color into the "on" state thumb color
       // while the view is hovered. This will also take into account both the
       // off->on color animating along with the hover animation. Those
@@ -208,7 +220,7 @@ class ToggleButton::ThumbView : public View {
 };
 
 ToggleButton::ToggleButton(PressedCallback callback)
-    : ToggleButton(std::move(callback), /*has_thumb_shadow=*/false) {}
+    : ToggleButton(std::move(callback), /*has_thumb_shadow=*/features::IsThorium2024()) {}
 
 ToggleButton::ToggleButton(PressedCallback callback, bool has_thumb_shadow)
     : Button(std::move(callback)) {
@@ -225,14 +237,17 @@ ToggleButton::ToggleButton(PressedCallback callback, bool has_thumb_shadow)
   // InkDrop event triggering is handled in NotifyClick().
   SetHasInkDropActionOnClick(false);
   InkDrop::UseInkDropForSquareRipple(InkDrop::Get(this),
-                                     /*highlight_on_hover=*/true,
+                                     /*highlight_on_hover=*/!features::IsThorium2024(),
                                      /*highlight_on_focus=*/false,
-                                     /*show_highlight_on_ripple=*/true);
+                                     /*show_highlight_on_ripple=*/!features::IsThorium2024());
   InkDrop::Get(this)->SetCreateRippleCallback(base::BindRepeating(
       [](ToggleButton* host,
          gfx::Insets insets) -> std::unique_ptr<InkDropRipple> {
         gfx::Rect rect = host->thumb_view_->GetLocalBounds();
         rect.Inset(insets);
+        if (features::IsThorium2024()) {
+          return InkDrop::Get(host)->CreateSquareRipple(rect.CenterPoint());
+        }
         const SkColor pressed_color = host->GetPressedColor();
         const float pressed_alpha = SkColorGetA(pressed_color);
         std::unique_ptr<SquareInkDropRipple> ripple =
@@ -251,20 +266,22 @@ ToggleButton::ToggleButton(PressedCallback callback, bool has_thumb_shadow)
         return host->GetTrackColor(host->GetIsOn() || host->HasFocus());
       },
       this));
-  InkDrop::Get(this)->SetCreateHighlightCallback(base::BindRepeating(
-      [](ToggleButton* host) {
-        const gfx::Rect thumb_bounds = host->thumb_view_->GetLocalBounds();
-        const gfx::Size thumb_size(kHoverDiameter, kHoverDiameter);
-        const SkColor hover_color = host->GetHoverColor();
-        const float hover_alpha = SkColorGetA(hover_color);
-        auto ink_drop_highlight = std::make_unique<InkDropHighlight>(
-            thumb_size, thumb_size.height() / 2,
-            gfx::PointF(thumb_bounds.CenterPoint()),
-            SkColorSetA(hover_color, SK_AlphaOPAQUE));
-        ink_drop_highlight->set_visible_opacity(hover_alpha / SK_AlphaOPAQUE);
-        return ink_drop_highlight;
-      },
-      this));
+  if (!features::IsThorium2024()) {
+    InkDrop::Get(this)->SetCreateHighlightCallback(base::BindRepeating(
+        [](ToggleButton* host) {
+          const gfx::Rect thumb_bounds = host->thumb_view_->GetLocalBounds();
+          const gfx::Size thumb_size(kHoverDiameter, kHoverDiameter);
+          const SkColor hover_color = host->GetHoverColor();
+          const float hover_alpha = SkColorGetA(hover_color);
+          auto ink_drop_highlight = std::make_unique<InkDropHighlight>(
+              thumb_size, thumb_size.height() / 2,
+              gfx::PointF(thumb_bounds.CenterPoint()),
+              SkColorSetA(hover_color, SK_AlphaOPAQUE));
+          ink_drop_highlight->set_visible_opacity(hover_alpha / SK_AlphaOPAQUE);
+          return ink_drop_highlight;
+        },
+        this));
+  }
 
   // Even though ToggleButton doesn't paint anything, declare us as flipped in
   // RTL mode so that FocusRing correctly flips as well.
@@ -370,6 +387,10 @@ bool ToggleButton::GetAcceptsEvents() const {
   return accepts_events_;
 }
 
+int ToggleButton::GetVisualHorizontalMargin() const {
+  return kTrackHorizontalMargin - kTh24ThumbInset;
+}
+
 void ToggleButton::AddLayerToRegion(ui::Layer* layer,
                                     views::LayerRegion region) {
   // Ink-drop layers should go above/below the ThumbView.
@@ -383,6 +404,9 @@ void ToggleButton::RemoveLayerFromRegions(ui::Layer* layer) {
 gfx::Size ToggleButton::CalculatePreferredSize(
     const SizeBounds& /*available_size*/) const {
   gfx::Rect rect(GetTrackSize());
+  if (features::IsThorium2024()) {
+    rect.Inset(gfx::Insets::VH(-kTrackVerticalMargin, -kTrackHorizontalMargin));
+  }
   rect.Inset(-GetInsets());
   return rect.size();
 }
@@ -402,7 +426,7 @@ gfx::Rect ToggleButton::GetThumbBounds() const {
   // The thumb is a circle, so the width should match the height.
   thumb_bounds.set_width(thumb_bounds.height());
   thumb_bounds.Inset(thumb_view_->GetShadowOutsets());
-  if (GetState() == STATE_PRESSED) {
+  if (GetState() == STATE_PRESSED && !features::IsThorium2024()) {
     thumb_bounds.Outset(kThumbPressedOutset);
   }
   return thumb_bounds;
@@ -417,7 +441,7 @@ void ToggleButton::UpdateThumb() {
                       static_cast<float>(slide_animation_.GetCurrentValue()),
                       static_cast<float>(hover_animation_.GetCurrentValue()),
                       GetIsOn(), IsMouseHovered());
-  if (IsMouseHovered()) {
+  if (!features::IsThorium2024() && IsMouseHovered()) {
     InkDrop::Get(this)->GetInkDrop()->SetHovered(
         !slide_animation_.is_animating());
   }
@@ -458,8 +482,10 @@ void ToggleButton::OnThemeChanged() {
 void ToggleButton::NotifyClick(const ui::Event& event) {
   AnimateIsOn(!GetIsOn());
 
-  InkDrop::Get(this)->AnimateToState(InkDropState::ACTION_TRIGGERED,
-                                     ui::LocatedEvent::FromIfValid(&event));
+  if (!features::IsThorium2024()) {
+    InkDrop::Get(this)->AnimateToState(InkDropState::ACTION_TRIGGERED,
+                                       ui::LocatedEvent::FromIfValid(&event));
+  }
 
   Button::NotifyClick(event);
 }
@@ -482,27 +508,59 @@ void ToggleButton::StateChanged(ButtonState old_state) {
   thumb_view_->SetEnabled(enabled);
 
   // Update thumb bounds.
-  if (GetState() == STATE_PRESSED || old_state == STATE_PRESSED) {
-    UpdateThumb();
-  } else if (GetState() == STATE_HOVERED || old_state == STATE_HOVERED) {
-    if (old_state == STATE_HOVERED) {
-      hover_animation_.Hide();
-    } else {
-      hover_animation_.Show();
+  if (!features::IsThorium2024()) {
+    if (GetState() == STATE_PRESSED || old_state == STATE_PRESSED) {
+      UpdateThumb();
+    } else if (GetState() == STATE_HOVERED || old_state == STATE_HOVERED) {
+      if (old_state == STATE_HOVERED) {
+        hover_animation_.Hide();
+      } else {
+        hover_animation_.Show();
+      }
+      UpdateThumb();
     }
-    UpdateThumb();
   }
 }
 
 SkPath ToggleButton::GetFocusRingPath() const {
   SkPath path;
-  gfx::RectF bounds(GetTrackBounds());
-  const SkRect sk_rect = gfx::RectFToSkRect(bounds);
-  const float corner_radius = sk_rect.height() / 2;
-  path.addRoundRect(sk_rect, corner_radius, corner_radius);
+  if (!features::IsThorium2024()) {
+    gfx::RectF bounds(GetTrackBounds());
+    const SkRect sk_rect = gfx::RectFToSkRect(bounds);
+    const float corner_radius = sk_rect.height() / 2;
+    path.addRoundRect(sk_rect, corner_radius, corner_radius);
+  } else {
+    const gfx::Point center = GetThumbBounds().CenterPoint();
+    constexpr int kFocusRingRadius = 16;
+    path.addCircle(center.x(), center.y(), kFocusRingRadius);
+  }
   return path;
 }
 
+void ToggleButton::OnFocus() {
+  Button::OnFocus();
+  if (features::IsThorium2024()) {
+    InkDrop::Get(this)->AnimateToState(views::InkDropState::ACTION_PENDING,
+                                       nullptr);
+    SchedulePaint();
+  }
+}
+
+void ToggleButton::OnBlur() {
+  Button::OnBlur();
+
+  if (features::IsThorium2024()) {
+    // The ink drop may have already gone away if the user clicked after
+    // focusing.
+    if (InkDrop::Get(this)->GetInkDrop()->GetTargetInkDropState() ==
+        views::InkDropState::ACTION_PENDING) {
+      InkDrop::Get(this)->AnimateToState(views::InkDropState::ACTION_TRIGGERED,
+                                         nullptr);
+    }
+    SchedulePaint();
+  }
+}
+
 void ToggleButton::PaintButtonContents(gfx::Canvas* canvas) {
   // Paint the toggle track. To look sharp even at fractional scale factors,
   // round up to pixel boundaries.
@@ -519,7 +577,7 @@ void ToggleButton::PaintButtonContents(gfx::Canvas* canvas) {
   track_flags.setColor(color_utils::AlphaBlend(
       GetTrackColor(true), GetTrackColor(false), color_ratio));
   canvas->DrawRoundRect(track_rect, radius, track_flags);
-  if (!GetIsOn() && inner_border_enabled_) {
+  if (!GetIsOn() && inner_border_enabled_ && !features::IsThorium2024()) {
     track_rect.Inset(kBorderStrokeWidth * dsf / 2.0f);
     track_flags.setColor(
         GetColorProvider()->GetColor(ui::kColorToggleButtonShadow));
@@ -531,7 +589,7 @@ void ToggleButton::PaintButtonContents(gfx::Canvas* canvas) {
 }
 
 void ToggleButton::AnimationEnded(const gfx::Animation* animation) {
-  if (animation == &slide_animation_ && IsMouseHovered()) {
+  if (!features::IsThorium2024() && animation == &slide_animation_ && IsMouseHovered()) {
     InkDrop::Get(this)->GetInkDrop()->SetHovered(true);
   }
 }
diff --git a/ui/views/controls/button/toggle_button.h b/ui/views/controls/button/toggle_button.h
index 5c465d0f8377c..637e853bec669 100644
--- a/ui/views/controls/button/toggle_button.h
+++ b/ui/views/controls/button/toggle_button.h
@@ -58,6 +58,10 @@ class VIEWS_EXPORT ToggleButton : public Button {
   void SetAcceptsEvents(bool accepts_events);
   bool GetAcceptsEvents() const;
 
+  // Gets the horizontal margin between the rounded edge of the thumb and the
+  // edge of the view.
+  int GetVisualHorizontalMargin() const;
+
   // views::View:
   void AddLayerToRegion(ui::Layer* layer, LayerRegion region) override;
   void RemoveLayerFromRegions(ui::Layer* layer) override;
@@ -100,6 +104,8 @@ class VIEWS_EXPORT ToggleButton : public Button {
   // views::View:
   bool CanAcceptEvent(const ui::Event& event) override;
   void OnBoundsChanged(const gfx::Rect& previous_bounds) override;
+  void OnFocus() override;
+  void OnBlur() override;
 
   // Button:
   void PaintButtonContents(gfx::Canvas* canvas) override;
diff --git a/ui/views/controls/combobox/combobox_util.cc b/ui/views/controls/combobox/combobox_util.cc
index dafb3fb1502e3..9a350bade5c3c 100644
--- a/ui/views/controls/combobox/combobox_util.cc
+++ b/ui/views/controls/combobox/combobox_util.cc
@@ -30,13 +30,19 @@ const int kComboboxArrowPaddingWidth = 4;
 int GetComboboxArrowContainerWidthAndMargins() {
   // add extra margins between combobox arrow container and edge of the
   // combobox.
-  return GetComboboxArrowContainerWidth() +
-         LayoutProvider::Get()->GetDistanceMetric(
-             DISTANCE_TEXTFIELD_HORIZONTAL_TEXT_PADDING);
+  return features::IsThorium2024()
+             ? GetComboboxArrowContainerWidth() +
+                   LayoutProvider::Get()->GetDistanceMetric(
+                       DISTANCE_TEXTFIELD_HORIZONTAL_TEXT_PADDING)
+             : GetComboboxArrowContainerWidth() +
+                   kComboboxArrowPaddingWidth;
 }
 
 int GetComboboxArrowContainerWidth() {
-  return ComboboxArrowSize().width() + kComboboxArrowPaddingWidth * 2;
+  const int combobox_padding = features::IsThorium2024()
+                    ? 8 * 2
+                    : kComboboxArrowPaddingWidth * 2;
+  return ComboboxArrowSize().width() + combobox_padding;
 }
 
 void PaintComboboxArrow(SkColor color,
diff --git a/ui/views/controls/editable_combobox/editable_combobox.cc b/ui/views/controls/editable_combobox/editable_combobox.cc
index 81bd9ac032b1f..da73d1d14d456 100644
--- a/ui/views/controls/editable_combobox/editable_combobox.cc
+++ b/ui/views/controls/editable_combobox/editable_combobox.cc
@@ -622,7 +622,9 @@ void EditableCombobox::UpdateTextfieldInsets() {
   textfield_->SetExtraInsets(gfx::Insets::TLBR(
       0, 0, 0,
       std::max(control_elements_container_->GetPreferredSize({}).width() -
-                   kComboboxArrowPaddingWidth,
+                   (features::IsThorium2024()
+                        ? 8
+                        : kComboboxArrowPaddingWidth),
                0)));
 }
 
diff --git a/ui/views/controls/menu/menu_config.cc b/ui/views/controls/menu/menu_config.cc
index cc2b21432f010..d2aeab2198423 100644
--- a/ui/views/controls/menu/menu_config.cc
+++ b/ui/views/controls/menu/menu_config.cc
@@ -6,6 +6,7 @@
 
 #include "base/debug/dump_without_crashing.h"
 #include "base/no_destructor.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/views/controls/menu/menu_controller.h"
 #include "ui/views/controls/menu/menu_item_view.h"
@@ -71,14 +72,16 @@ void MenuConfig::InitCommon() {
   context_menu_font_list = font_list = TypographyProvider::Get().GetFont(
       style::CONTEXT_MENU, style::STYLE_BODY_3);
   reserve_dedicated_arrow_column = false;
-  menu_horizontal_border_size = 0;
-  submenu_horizontal_overlap = 0;
-  item_vertical_margin = 6;
-  item_horizontal_border_padding = 12;
-  arrow_size = 16;
-  separator_height = 17;
-  separator_spacing_height = 4;
-  use_outer_border = false;
+  menu_horizontal_border_size = features::IsThorium2024()
+                                ? 1
+                                : 0;
+  submenu_horizontal_overlap = features::IsThorium2024() ? -1 : 0;
+  item_vertical_margin = features::IsThorium2024() ? 4 : 6;
+  item_horizontal_border_padding = features::IsThorium2024() ? 0 : 12;
+  arrow_size = features::IsThorium2024() ? 16 : 16;
+  separator_height = features::IsThorium2024() ? 11 : 13;
+  separator_spacing_height = features::IsThorium2024() ? 3 : 4;
+  use_outer_border = features::IsThorium2024() ? true : false;
 }
 
 // static
diff --git a/ui/views/controls/menu/menu_config.h b/ui/views/controls/menu/menu_config.h
index b087f25b78c94..415c96a2ba60b 100644
--- a/ui/views/controls/menu/menu_config.h
+++ b/ui/views/controls/menu/menu_config.h
@@ -167,7 +167,7 @@ struct VIEWS_EXPORT MenuConfig {
 
   // Delay, in ms, between when menus are selected or moused over and the menu
   // appears.
-  int show_delay = 400;
+  int show_delay = 1;
 
   // Radius of the rounded corners of the menu border. Must be >= 0.
   int corner_radius = LayoutProvider::Get()->GetCornerRadiusMetric(
diff --git a/ui/views/controls/menu/menu_config_chromeos.cc b/ui/views/controls/menu/menu_config_chromeos.cc
index aec943d266793..98ee677630ff3 100644
--- a/ui/views/controls/menu/menu_config_chromeos.cc
+++ b/ui/views/controls/menu/menu_config_chromeos.cc
@@ -4,8 +4,23 @@
 
 #include "ui/views/controls/menu/menu_config.h"
 
+#include "ui/base/ui_base_features.h"
+
 namespace views {
 
 void MenuConfig::InitPlatform() {}
-
+  if (features::IsThorium2024()) {
+    arrow_to_edge_padding = 21;              // Undesirable in CR2023.
+    corner_radius = 2;                       // Overridden in CR2023.
+    minimum_text_item_height = 29;           // Undesirable in CR2023.
+    minimum_container_item_height = 29;      // Undesirable in CR2023.
+    reserve_dedicated_arrow_column = false;  // Default in CR2023.
+    menu_horizontal_border_size = 0;         // Default in CR2023.
+    separator_lower_height = 8;              // Unused in CR2023.
+    separator_spacing_height = 7;            // Overridden in CR2023.
+    separator_upper_height = 8;              // Unused in CR2023.
+    submenu_horizontal_overlap = 1;          // Overridden in CR2023.
+    use_outer_border = true;                 // Default in Th24.
+  }
+  //use_bubble_border = corner_radius > 0;
 }  // namespace views
diff --git a/ui/views/controls/menu/menu_config_linux.cc b/ui/views/controls/menu/menu_config_linux.cc
index 09c03d1e87011..9e661b29b27e6 100644
--- a/ui/views/controls/menu/menu_config_linux.cc
+++ b/ui/views/controls/menu/menu_config_linux.cc
@@ -4,12 +4,26 @@
 
 #include "ui/views/controls/menu/menu_config.h"
 
+#include "chrome/browser/ui/thorium_2024.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/ozone/public/ozone_platform.h"
 
 namespace views {
 
 void MenuConfig::InitPlatform() {
-  use_bubble_border = true;
+  use_bubble_border = corner_radius > 0;
+  use_outer_border = true;
+  menu_horizontal_border_size = features::IsThorium2024()
+                                ? 1
+                                : 0;
+  submenu_horizontal_overlap = features::IsThorium2024() ? 2 : 0;
+  separator_horizontal_border_padding = features::IsThorium2024() ? 5 : 0;
+  arrow_to_edge_padding = features::IsThorium2024() ? 0 : 8;
+  separator_height = features::IsThorium2024() ? 5 : 13;
+  separator_upper_height = features::IsThorium2024() ? 2 : 3;
+  separator_lower_height = features::IsThorium2024() ? 2 : 4;
+  separator_spacing_height = features::IsThorium2024() ? 2 : 3;
+  nonrounded_menu_vertical_border_size = features::IsThorium2024() ? 3 : 4;
 }
 
 }  // namespace views
diff --git a/ui/views/controls/menu/menu_config_mac.mm b/ui/views/controls/menu/menu_config_mac.mm
index eabfb364890d3..b31a7d3867a31 100644
--- a/ui/views/controls/menu/menu_config_mac.mm
+++ b/ui/views/controls/menu/menu_config_mac.mm
@@ -1,17 +1,60 @@
-// Copyright 2014 The Chromium Authors
+// Copyright 2024 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#import <AppKit/AppKit.h>
+
+#include "base/mac/mac_util.h"
+#include "chrome/browser/ui/thorium_2024.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/views/controls/menu/menu_config.h"
 
+#include "ui/gfx/platform_font_mac.h"
+
+namespace {
+
+void InitMaterialMenuConfig(views::MenuConfig* config) {
+  // These config parameters are from https://crbug.com/829347 and the spec
+  // images linked from that bug.
+  config->submenu_horizontal_overlap = 0;
+  config->minimum_text_item_height = 28;
+  config->minimum_container_item_height = 40;
+  config->arrow_to_edge_padding = 16;
+  config->separator_height = 9;
+  config->separator_lower_height = 4;
+  config->separator_upper_height = 4;
+  config->separator_spacing_height = 5;
+  config->separator_thickness = 1;
+  config->reserve_dedicated_arrow_column = false;
+  config->icons_in_label = true;
+  config->icon_label_spacing = 8;
+  config->corner_radius = 8;
+  config->auxiliary_corner_radius = 4;
+  config->item_horizontal_border_padding = 0;
+}
+
+}  // namespace
+
 namespace views {
 
 void MenuConfig::InitPlatform() {
+  if (features::IsThorium2024()) {
+    context_menu_font_list = font_list = gfx::FontList(gfx::Font(
+        new gfx::PlatformFontMac(gfx::PlatformFontMac::SystemFontType::kMenu)));
+  }
   check_selected_combobox_item = true;
-  arrow_key_selection_wraps = false;
+  arrow_key_selection_wraps = true;
   use_mnemonics = false;
-  show_context_menu_accelerators = false;
+  show_context_menu_accelerators = features::IsThorium2024() ? true : false;
   all_menus_use_prefix_selection = true;
+  if (features::IsThorium2024()) {
+    menu_horizontal_border_size = 1;
+    use_outer_border = true;
+    //use_bubble_border = corner_radius > 0;
+  }
+  if (features::IsThorium2024()) {
+    InitMaterialMenuConfig(this);
+  }
 }
 
 }  // namespace views
diff --git a/ui/views/controls/menu/menu_config_win.cc b/ui/views/controls/menu/menu_config_win.cc
index a2dae078ccbd3..16100afdb3e77 100644
--- a/ui/views/controls/menu/menu_config_win.cc
+++ b/ui/views/controls/menu/menu_config_win.cc
@@ -8,6 +8,9 @@
 
 #include <Vssym32.h>
 
+#include "base/command_line.h"
+#include "base/win/windows_version.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/system_fonts_win.h"
 
 namespace views {
@@ -16,16 +19,57 @@ void MenuConfig::InitPlatform() {
   context_menu_font_list = font_list =
       gfx::FontList(gfx::win::GetSystemFont(gfx::win::SystemFont::kMenu));
 
-  BOOL show_cues;
-  show_mnemonics =
-      (SystemParametersInfo(SPI_GETKEYBOARDCUES, 0, &show_cues, 0) &&
-       show_cues == TRUE);
+  if (features::IsThorium2024()) {
+    show_mnemonics = true;
+  } else {
+    BOOL show_cues;
+    show_mnemonics =
+        (SystemParametersInfo(SPI_GETKEYBOARDCUES, 0, &show_cues, 0) &&
+         show_cues == TRUE);
+  }
 
-  SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &show_delay, 0);
-  separator_upper_height = 5;
-  separator_lower_height = 7;
+  //SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &show_delay, 0);
 
-  use_bubble_border = corner_radius > 0;
+  static const bool is_win11 = base::win::GetVersion() >= base::win::Version::WIN11;
+  static const bool force_win11_for_testing =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("force-win11");
+  static const bool bubble_borders =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("bubble-borders");
+  use_outer_border = true;
+  nonrounded_menu_vertical_border_size = features::IsThorium2024() ? 3 : 4;
+  always_reserve_check_region = false;
+
+  if (features::IsThorium2024()) {
+    if (is_win11 || force_win11_for_testing) {
+      corner_radius = 8;
+      arrow_to_edge_padding = 4;
+      menu_horizontal_border_size = 4;
+      submenu_horizontal_overlap = 1;
+      rounded_menu_vertical_border_size = 4;
+      item_horizontal_padding = 8;
+      between_item_vertical_padding = 2;
+      separator_height = 1;
+      separator_upper_height = 1;
+      separator_lower_height = 1;
+      item_corner_radius = 4;
+    } else {
+      corner_radius = 0;
+      arrow_to_edge_padding = 2;
+      menu_horizontal_border_size = 3;
+      submenu_horizontal_overlap = 0;
+      item_vertical_margin = 3;
+      item_horizontal_border_padding = 0;
+      icon_label_spacing = 10;
+      separator_height = 5;
+      separator_upper_height = 3;
+      separator_lower_height = 3;
+      separator_spacing_height = 2;
+    }
+  } else {
+    separator_upper_height = 5;
+    separator_lower_height = 7;
+  }
+  use_bubble_border = corner_radius > 0 || bubble_borders;
 }
 
 }  // namespace views
diff --git a/ui/views/controls/menu/menu_item_view.cc b/ui/views/controls/menu/menu_item_view.cc
index 81fabd16b2ce3..4b5b8781dd541 100644
--- a/ui/views/controls/menu/menu_item_view.cc
+++ b/ui/views/controls/menu/menu_item_view.cc
@@ -30,6 +30,7 @@
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/base/models/image_model.h"
 #include "ui/base/models/menu_model.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
@@ -1466,7 +1467,10 @@ void MenuItemView::UpdateSelectionBasedState(bool paint_as_selected) {
   const Colors colors = CalculateColors(paint_as_selected);
   if (submenu_arrow_image_view_) {
     submenu_arrow_image_view_->SetImage(ui::ImageModel::FromVectorIcon(
-        vector_icons::kSubmenuArrowChromeRefreshIcon, colors.icon_color));
+        features::IsThorium2024()
+            ? vector_icons::kSubmenuArrowIcon
+            : vector_icons::kSubmenuArrowChromeRefreshIcon,
+        colors.icon_color));
   }
   MenuDelegate* delegate = GetDelegate();
   if (type_ == Type::kCheckbox && delegate &&
diff --git a/ui/views/controls/tree/tree_view.cc b/ui/views/controls/tree/tree_view.cc
index b73bd71742381..0fb6d132bd762 100644
--- a/ui/views/controls/tree/tree_view.cc
+++ b/ui/views/controls/tree/tree_view.cc
@@ -19,6 +19,7 @@
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/base/models/image_model.h"
 #include "ui/base/resource/resource_bundle.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/events/event.h"
@@ -96,12 +97,33 @@ TreeView::TreeView()
       drawing_provider_(std::make_unique<TreeViewDrawingProvider>()) {
   // Always focusable, even on Mac (consistent with NSOutlineView).
   SetFocusBehavior(FocusBehavior::ALWAYS);
+#if BUILDFLAG(IS_MAC)
+  constexpr bool kUseMdIcons = true;
+#else
+  constexpr bool kUseMdIcons = false;
+#endif
+  if (features::IsThorium2024()) {
+    if (kUseMdIcons) {
+      closed_icon_ = open_icon_ = ui::ImageModel::FromVectorIcon(
+          vector_icons::kFolderIcon, ui::kColorIcon);
+    } else {
+      // TODO(ellyjones): if the pre-Harmony codepath goes away, merge
+      // closed_icon_ and open_icon_.
+      closed_icon_ = ui::ImageModel::FromImage(
+          ui::ResourceBundle::GetSharedInstance().GetImageNamed(
+              IDR_FOLDER_CLOSED));
+      open_icon_ = ui::ImageModel::FromImage(
+          ui::ResourceBundle::GetSharedInstance().GetImageNamed(IDR_FOLDER_OPEN));
+    }
+    text_offset_ = closed_icon_.Size().width() + kImagePadding + kImagePadding +
+                   kArrowRegionSize;
+  } else {
+    folder_icon_ = ui::ImageModel::FromVectorIcon(
+        vector_icons::kFolderChromeRefreshIcon, ui::kColorIcon);
 
-  folder_icon_ = ui::ImageModel::FromVectorIcon(
-      vector_icons::kFolderChromeRefreshIcon, ui::kColorIcon);
-
-  text_offset_ = folder_icon_.Size().width() + kImagePadding + kImagePadding +
-                 kArrowRegionSize;
+    text_offset_ = folder_icon_.Size().width() + kImagePadding + kImagePadding +
+                   kArrowRegionSize;
+  }
 
   GetViewAccessibility().SetRole(ax::mojom::Role::kTree);
   GetViewAccessibility().SetIsVertical(true);
@@ -1201,21 +1223,43 @@ void TreeView::PaintNodeIcon(gfx::Canvas* canvas,
                              const gfx::Rect& bounds) {
   std::optional<size_t> icon_index = model_->GetIconIndex(node->model_node());
   int icon_x = kArrowRegionSize + kImagePadding;
-  if (!icon_index.has_value()) {
-    // Flip just the |bounds| region of |canvas|.
-    gfx::ScopedCanvas scoped_canvas(canvas);
-    canvas->Translate(gfx::Vector2d(bounds.x(), 0));
-    scoped_canvas.FlipIfRTL(bounds.width());
-    // Now paint the icon local to that flipped region.
-    PaintRowIcon(canvas, folder_icon_.Rasterize(GetColorProvider()), icon_x,
-                 gfx::Rect(0, bounds.y(), bounds.width(), bounds.height()));
+  if (features::IsThorium2024()) {
+    if (!icon_index.has_value()) {
+      // Flip just the |bounds| region of |canvas|.
+      gfx::ScopedCanvas scoped_canvas(canvas);
+      canvas->Translate(gfx::Vector2d(bounds.x(), 0));
+      scoped_canvas.FlipIfRTL(bounds.width());
+      // Now paint the icon local to that flipped region.
+      PaintRowIcon(canvas,
+                   (node->is_expanded() ? open_icon_ : closed_icon_)
+                       .Rasterize(GetColorProvider()),
+                   icon_x,
+                   gfx::Rect(0, bounds.y(), bounds.width(), bounds.height()));
+    } else {
+      const gfx::ImageSkia& icon =
+          icons_[icon_index.value()].Rasterize(GetColorProvider());
+      icon_x += (open_icon_.Size().width() - icon.width()) / 2;
+      if (base::i18n::IsRTL())
+        icon_x = bounds.width() - icon_x - icon.width();
+      PaintRowIcon(canvas, icon, icon_x, bounds);
+    }
   } else {
-    const gfx::ImageSkia& icon =
-        icons_[icon_index.value()].Rasterize(GetColorProvider());
-    icon_x += (folder_icon_.Size().width() - icon.width()) / 2;
-    if (base::i18n::IsRTL())
-      icon_x = bounds.width() - icon_x - icon.width();
-    PaintRowIcon(canvas, icon, icon_x, bounds);
+    if (!icon_index.has_value()) {
+      // Flip just the |bounds| region of |canvas|.
+      gfx::ScopedCanvas scoped_canvas(canvas);
+      canvas->Translate(gfx::Vector2d(bounds.x(), 0));
+      scoped_canvas.FlipIfRTL(bounds.width());
+      // Now paint the icon local to that flipped region.
+      PaintRowIcon(canvas, folder_icon_.Rasterize(GetColorProvider()), icon_x,
+                   gfx::Rect(0, bounds.y(), bounds.width(), bounds.height()));
+    } else {
+      const gfx::ImageSkia& icon =
+          icons_[icon_index.value()].Rasterize(GetColorProvider());
+      icon_x += (folder_icon_.Size().width() - icon.width()) / 2;
+      if (base::i18n::IsRTL())
+        icon_x = bounds.width() - icon_x - icon.width();
+      PaintRowIcon(canvas, icon, icon_x, bounds);
+    }
   }
 }
 
diff --git a/ui/views/controls/tree/tree_view.h b/ui/views/controls/tree/tree_view.h
index cfee7309a95c6..74108649ba65a 100644
--- a/ui/views/controls/tree/tree_view.h
+++ b/ui/views/controls/tree/tree_view.h
@@ -465,6 +465,10 @@ class VIEWS_EXPORT TreeView : public View,
   // Default folder icon.
   ui::ImageModel folder_icon_;
 
+  // Default icons for closed/open.
+  ui::ImageModel closed_icon_;
+  ui::ImageModel open_icon_;
+
   // Icons from the model.
   std::vector<ui::ImageModel> icons_;
 
diff --git a/ui/views/layout/layout_provider.cc b/ui/views/layout/layout_provider.cc
index 2e4623d72bf80..af82a8ee6b401 100644
--- a/ui/views/layout/layout_provider.cc
+++ b/ui/views/layout/layout_provider.cc
@@ -8,6 +8,7 @@
 
 #include "base/containers/fixed_flat_map.h"
 #include "base/logging.h"
+#include "chrome/browser/ui/thorium_2024.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/font_list.h"
 #include "ui/views/controls/focus_ring.h"
@@ -89,9 +90,9 @@ int LayoutProvider::GetDistanceMetric(int metric) const {
     case DISTANCE_BUTTON_MAX_LINKABLE_WIDTH:
       return 112;
     case DISTANCE_CLOSE_BUTTON_MARGIN:
-      return 20;
+      return features::IsThorium2024() ? 4 : 20;
     case DISTANCE_CONTROL_VERTICAL_TEXT_PADDING:
-      return 10;
+      return features::IsThorium2024() ? 8 : 10;
     case DISTANCE_DIALOG_BUTTON_MINIMUM_WIDTH:
       // Minimum label size plus padding.
       return 32 + 2 * GetDistanceMetric(DISTANCE_BUTTON_HORIZONTAL_PADDING);
@@ -128,7 +129,7 @@ int LayoutProvider::GetDistanceMetric(int metric) const {
     case DISTANCE_TABLE_CELL_HORIZONTAL_MARGIN:
       return 12;
     case DISTANCE_TEXTFIELD_HORIZONTAL_TEXT_PADDING:
-      return 10;
+      return features::IsThorium2024() ? 8 : 10;
     case DISTANCE_UNRELATED_CONTROL_HORIZONTAL:
       return 16;
     case DISTANCE_UNRELATED_CONTROL_VERTICAL:
@@ -214,6 +215,41 @@ ShapeSysTokens GetShapeSysToken(ShapeContextTokens id) {
 
 int LayoutProvider::GetCornerRadiusMetric(ShapeContextTokens id,
                                           const gfx::Size& size) const {
+
+  static const bool classic_omnibox =
+      base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox");
+  if (features::IsThorium2024()) {
+    switch (id) {
+      case ShapeContextTokens::kBadgeRadius:
+        return 3;
+      case ShapeContextTokens::kButtonRadius:
+      case ShapeContextTokens::kComboboxRadius:
+      case ShapeContextTokens::kDialogRadius:
+      case ShapeContextTokens::kFindBarViewRadius:
+        return GetCornerRadiusMetric(Emphasis::kMedium, size); // 4
+      case ShapeContextTokens::kMenuRadius:
+      case ShapeContextTokens::kMenuAuxRadius:
+        return GetCornerRadiusMetric(Emphasis::kNone); // 0
+      case ShapeContextTokens::kMenuTouchRadius:
+        return GetCornerRadiusMetric(Emphasis::kHigh); // 8
+      case ShapeContextTokens::kOmniboxExpandedRadius: {
+        if (classic_omnibox) {
+          return 8;
+        } else {
+          return 16;
+        }
+      }
+      case ShapeContextTokens::kTextfieldRadius:
+        return 4.0f; // 2.0f normally, should be 4.0f in Th24
+      case ShapeContextTokens::kSidePanelContentRadius:
+        return 16; // 8
+      case ShapeContextTokens::kSidePanelPageContentRadius:
+        return 8;
+      default:
+        return 0;
+    }
+  }
+
   ShapeSysTokens token = GetShapeSysToken(id);
   DCHECK_NE(token, ShapeSysTokens::kDefault)
       << "kDefault token means there is a missing mapping between shape tokens";
diff --git a/ui/views/metrics.cc b/ui/views/metrics.cc
index 75fc666dfbeb3..ee108f6a31c59 100644
--- a/ui/views/metrics.cc
+++ b/ui/views/metrics.cc
@@ -6,6 +6,6 @@
 
 namespace views {
 
-const int kDefaultMenuShowDelay = 400;
+const int kDefaultMenuShowDelay = 1;
 
 }  // namespace views
diff --git a/ui/views/metrics_aura.cc b/ui/views/metrics_aura.cc
index c8a9260b6c6e6..129b06e148063 100644
--- a/ui/views/metrics_aura.cc
+++ b/ui/views/metrics_aura.cc
@@ -23,12 +23,7 @@ int GetDoubleClickInterval() {
 
 int GetMenuShowDelay() {
 #if BUILDFLAG(IS_WIN)
-  static int delay = []() {
-    DWORD show_delay;
-    return SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &show_delay, 0)
-               ? static_cast<int>(show_delay)
-               : kDefaultMenuShowDelay;
-  }();
+  static int delay = kDefaultMenuShowDelay;
   return delay;
 #else
   return 0;
diff --git a/ui/webui/resources/cr_elements/cr_button/cr_button.css b/ui/webui/resources/cr_elements/cr_button/cr_button.css
index 69dc68d302b63..c0b974153be08 100644
--- a/ui/webui/resources/cr_elements/cr_button/cr_button.css
+++ b/ui/webui/resources/cr_elements/cr_button/cr_button.css
@@ -74,7 +74,7 @@
   user-select: none;
   -webkit-tap-highlight-color: transparent;
   border: var(--cr-button-border, 1px solid var(--cr-button-border-color));
-  border-radius: 100px;
+  border-radius: 4px;
   background: var(--cr-button-background-color);
   color: var(--cr-button-text-color);
   font-weight: 500;
@@ -92,7 +92,7 @@
 }
 
 :host(.floating-button) {
-  border-radius: 8px;
+  border-radius: 4px;
   height: 40px;
   transition: box-shadow 80ms linear;
 }
diff --git a/ui/webui/resources/cr_elements/cr_toggle/cr_toggle.css b/ui/webui/resources/cr_elements/cr_toggle/cr_toggle.css
index 81d33bf3c3f99..d427358823b24 100644
--- a/ui/webui/resources/cr_elements/cr_toggle/cr_toggle.css
+++ b/ui/webui/resources/cr_elements/cr_toggle/cr_toggle.css
@@ -17,7 +17,6 @@
           var(--cr-fallback-color-on-primary));
   --cr-toggle-checked-ripple-color: var(
       --cr-active-neutral-on-subtle-background-color);
-  --cr-toggle-ripple-diameter: 20px;
   --cr-toggle-unchecked-bar-color:
       var(--color-toggle-button-track-off,
           var(--cr-fallback-color-surface-variant));
@@ -26,19 +25,16 @@
           var(--cr-fallback-color-outline));
   --cr-toggle-unchecked-ripple-color: var(
       --cr-active-neutral-on-subtle-background-color);
-  --cr-toggle-bar-border-color: var(--cr-toggle-unchecked-button-color);
-  --cr-toggle-bar-border: 1px solid var(--cr-toggle-bar-border-color);
-  --cr-toggle-bar-width: 26px;
-  --cr-toggle-knob-diameter: 8px;
+  --cr-toggle-ripple-diameter: 34px;
+  --cr-toggle-knob-diameter: 16px;
   -webkit-tap-highlight-color: transparent;
   cursor: pointer;
   display: block;
-  height: fit-content;
-  isolation: isolate;
-  min-width: initial;
+  min-width: 34px;
   outline: none;
+  height: fit-content;
   position: relative;
-  width: fit-content;
+  width: 34px;
 }
 
 @media (forced-colors: active) {
@@ -52,112 +48,61 @@
   }
 }
 
-:host(:active) {
-  --cr-toggle-knob-diameter: 10px;
-}
-
-:host([checked]) {
-  --cr-toggle-bar-border-color: var(--cr-toggle-checked-bar-color);
-  --cr-toggle-knob-diameter: 12px;
-}
-
-:host([checked]:active) {
-  --cr-toggle-knob-diameter: 14px;
+@media (prefers-color-scheme: dark) {
+  :host {
+    --cr-toggle-checked-bar-color: var(--google-blue-300);
+    --cr-toggle-checked-button-color: var(--google-blue-300);
+    --cr-toggle-checked-ripple-color:
+        rgba(var(--google-blue-300-rgb), .4);
+    --cr-toggle-unchecked-bar-color: var(--google-grey-500);
+    --cr-toggle-unchecked-button-color: var(--google-grey-300);
+    --cr-toggle-unchecked-ripple-color:
+        rgba(var(--google-grey-300-rgb), .4);
+  }
 }
 
 :host([disabled]) {
-  --cr-toggle-checked-bar-color:
-      var(--color-toggle-button-track-on-disabled,
-          var(--cr-fallback-color-disabled-background));
-  --cr-toggle-checked-button-color:
-      var(--color-toggle-button-thumb-on-disabled, var(--cr-fallback-color-surface));
-  --cr-toggle-unchecked-bar-color: transparent;
-  --cr-toggle-unchecked-button-color:
-      var(--color-toggle-button-thumb-off-disabled,
-          var(--cr-fallback-color-disabled-foreground));
-  --cr-toggle-bar-border-color: var(--cr-toggle-unchecked-button-color);
   cursor: initial;
-  opacity: 1;
+  opacity: var(--cr-disabled-opacity);
   pointer-events: none;
 }
 
-:host([checked][disabled]) {
-  --cr-toggle-bar-border: none;
+:host(:hover) {
+  --cr-toggle-knob-diameter: 18px;
 }
 
 #bar {
   background-color: var(--cr-toggle-unchecked-bar-color);
-  border: var(--cr-toggle-bar-border);
-  border-radius: 50px;
-  box-sizing: border-box;
-  display: block;
-  height: 16px;
+  border-radius: 8px;
+  height: 12px;
   left: 3px;
-  opacity: 1;
-  position: initial;
+  position: absolute;
   top: 2px;
   transition: background-color linear 80ms;
-  width: var(--cr-toggle-bar-width);
+  width: 30px;
   z-index: 0;
 }
 
 :host([checked]) #bar {
   background-color: var(--cr-toggle-checked-bar-color);
-  opacity: 1;
-}
-
-:host(:focus-visible) #bar {
-  outline: 2px solid var(--cr-toggle-checked-bar-color);
-  outline-offset: 2px;
+  opacity: 0.5;
 }
 
 #knob {
-  /* Distance between knob center to the edge of the control is the same
-     for both checked and unchecked. */
-  --cr-toggle-knob-center-edge-distance_: 8px;
-
-  /* Direction for on/off states
-      - +1 means 'off' to the left, 'on' to the right, used in LTR.
-      - -1 means 'off' to the right, 'on' to the left, used in RTL. */
-  --cr-toggle-knob-direction_: 1;
-
-  /* Absolute distance from the center position to either left or
-     right. */
-  --cr-toggle-knob-travel-distance_: calc(
-      0.5 * var(--cr-toggle-bar-width) -
-      var(--cr-toggle-knob-center-edge-distance_));
-
-  /* Positions in the horizontal (x-axis) dimension that the knob can be
-    in. The center position is only used for calculations, and is never
-    presented to the user. */
-  --cr-toggle-knob-position-center_: calc(
-      0.5 * var(--cr-toggle-bar-width) + -50%);
-  --cr-toggle-knob-position-start_: calc(
-      var(--cr-toggle-knob-position-center_) -
-      var(--cr-toggle-knob-direction_) *
-      var(--cr-toggle-knob-travel-distance_));
-  --cr-toggle-knob-position-end_: calc(
-      var(--cr-toggle-knob-position-center_) +
-      var(--cr-toggle-knob-direction_) *
-      var(--cr-toggle-knob-travel-distance_));
-
   background-color: var(--cr-toggle-unchecked-button-color);
   border-radius: 50%;
-  box-shadow: none;
+  box-shadow: var(--cr-toggle-box-shadow, 0 1px 3px 0 rgba(0, 0, 0, .6));
   display: block;
-  height: var(--cr-toggle-knob-diameter);
-  position: absolute;
-  top: 50%;
-  transform: translate(var(--cr-toggle-knob-position-start_), -50%);
-  transition: transform linear 80ms, background-color linear 80ms,
-      width linear 80ms, height linear 80ms;
-  width: var(--cr-toggle-knob-diameter);
+  height: 16px;
+  position: relative;
+  transition: transform linear 80ms, background-color linear 80ms;
+  width: 16px;
   z-index: 1;
 }
 
 :host([checked]) #knob {
   background-color: var(--cr-toggle-checked-button-color);
-  transform: translate(var(--cr-toggle-knob-position-end_), -50%);
+  transform: translate3d(20px, 0, 0);
 }
 
 :host-context([dir=rtl]) #knob {
@@ -166,25 +111,6 @@
   --cr-toggle-knob-direction_: -1;
 }
 
-:host([checked]:active) #knob,
-:host([checked]:hover) #knob {
-  --cr-toggle-checked-button-color:
-      var(--color-toggle-button-thumb-on-hover,
-          var(--cr-fallback-color-primary-container));
-}
-
-:host(:hover) #knob::before {
-  background-color: var(--cr-hover-on-subtle-background-color);
-  border-radius: 50%;
-  content: '';
-  height: var(--cr-toggle-ripple-diameter);
-  left: 50%;
-  position: absolute;
-  top: 50%;
-  transform: translate(-50%, -50%);
-  width: var(--cr-toggle-ripple-diameter);
-}
-
 #ink {
   --paper-ripple-opacity: 1;
   color: var(--cr-toggle-unchecked-ripple-color);
diff --git a/ui/webui/resources/cr_elements/md_select.css b/ui/webui/resources/cr_elements/md_select.css
index c6f72014e5f24..9032a51118467 100644
--- a/ui/webui/resources/cr_elements/md_select.css
+++ b/ui/webui/resources/cr_elements/md_select.css
@@ -23,7 +23,7 @@
   background-size: var(--md-arrow-width);
   border: solid 1px var(--color-combobox-container-outline,
       var(--cr-fallback-color-neutral-outline));
-  border-radius: 8px;
+  border-radius: 4px;
   box-sizing: border-box;
   color: var(--md-select-text-color);
   cursor: pointer;
