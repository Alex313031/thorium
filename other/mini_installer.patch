diff --git a/chrome/installer/mini_installer/BUILD.gn b/chrome/installer/mini_installer/BUILD.gn
index 7e49b4e449981..4a59d3e73940d 100644
--- a/chrome/installer/mini_installer/BUILD.gn
+++ b/chrome/installer/mini_installer/BUILD.gn
@@ -1,7 +1,8 @@
-# Copyright 2015 The Chromium Authors
+# Copyright 2026 The Chromium Authors and Alex313031
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/compiler_opt.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/features.gni")
 import("//build/config/python.gni")
@@ -36,7 +37,33 @@ declare_args() {
 
 config("mini_installer_compiler_flags") {
   # Disable buffer security checking.
-  cflags = [ "/GS-" ]
+  cflags = [ "/GS-", "/clang:-O3", ]
+
+  if (!use_sse3 && use_sse2) {
+    cflags += [ "/arch:SSE2", ]
+  } else if (use_sse3) {
+    cflags += [ "/clang:-msse3", ]
+  } else if (use_sse41) {
+    cflags += [ "/clang:-mssse3", "/clang:-msse4.1", ]
+  } else if (!use_avx && use_sse42) {
+    if (current_cpu == "x86") {
+      cflags += [ "/clang:-msse4.2", ]
+    } else {
+      cflags += [ "/arch:SSE42", ]
+    }
+  } else if (!use_avx2 && use_avx) {
+    cflags += [ "/arch:AVX", ]
+  } else if (!use_avx512 && use_avx2) {
+    cflags += [ "/arch:AVX2", ]
+  } else if (use_avx512) {
+    cflags += [ "/arch:AVX2", ]
+  } else {
+    print("No SIMD")
+  }
+
+  if (use_fma) {
+    cflags += [ "/fp:fast", ]
+  }
 }
 
 source_set("lib") {
@@ -69,13 +96,24 @@ source_set("lib") {
     "write_to_disk.h",
   ]
 
-  deps = [ "//build:branding_buildflags" ]
+  deps = [
+    ":mini_installer_version",
+    "//build:branding_buildflags"
+  ]
 
   # Initialization may insert unexpected memset calls.
   configs -= [ "//build/config/compiler:default_init_stack_vars" ]
   configs += [ ":mini_installer_compiler_flags" ]
 }
 
+process_version("mini_installer_version") {
+  process_only = true
+  visibility = [ ":*" ]
+  template_file = "mini_installer_version.h.template"
+  sources = [ "//chrome/VERSION" ]
+  output = "$target_gen_dir/mini_installer_version.h"
+}
+
 process_version_rc_template("version") {
   template_file = "mini_installer_exe_version.rc.version"
   output = "$root_out_dir/mini_installer_exe_version.rc"
@@ -145,7 +183,7 @@ action("mini_installer_archive") {
   inputs = [
     "$root_out_dir/chrome.dll",
     "$root_out_dir/chrome_elf.dll",
-    "$root_out_dir/chrome.exe",
+    "$root_out_dir/thorium.exe",
     "$root_out_dir/locales/en-US.pak",
     "$root_out_dir/setup.exe",
     "//chrome/tools/build/win/makecab.py",
@@ -179,12 +217,12 @@ action("mini_installer_archive") {
     build_timestamp,
 
     # Optional arguments to generate diff installer.
-    #'--last_chrome_installer=C:/Temp/base',
+    #'--last_chrome_installer=C:/src/chromium/src/out/thorium',
     #'--setup_exe_format=DIFF',
     #'--diff_algorithm=ZUCCHINI',
 
     # Optional argument for verbose archiving output.
-    #"--verbose",
+    "--verbose",
   ]
 
   deps = [
@@ -266,6 +304,11 @@ copy("copy_signing") {
   outputs = [ "$root_out_dir/signing/mini_installer/{{source_file_part}}" ]
 }
 
+declare_args() {
+  # Wether to disable linking in CRT for mini_installer
+  no_mini_installer_crt = false
+}
+
 # Generates a mini_installer executable containing the resources provided in the
 # caller's `rc_file`.
 template("generate_mini_installer") {
@@ -290,7 +333,7 @@ template("generate_mini_installer") {
       "/NXCOMPAT",
     ]
 
-    libs = [ "setupapi.lib" ]
+    libs = [ "setupapi.lib", ]
 
     deps = [
       ":copy_signing",
@@ -315,14 +358,73 @@ template("generate_mini_installer") {
     # But in asan and clang profiling builds we need to link against a runtime
     # library, which in turn depends on the standard library and relies on it
     # to run initializers.
-    if (!is_asan && !use_clang_profiling) {
+    if (!is_asan && !use_clang_profiling || no_mini_installer_crt) {
       no_default_deps = true
       ldflags += [ "/ENTRY:MainEntryPoint" ]
+    } else {
+      libs += [ "kernel32.lib", "user32.lib", "comctl32.lib", "shell32.lib", ]
     }
   }
 }
 
-generate_mini_installer("mini_installer") {
+group("mini_installer") {
+  deps = []
+  if (use_sse2 && !use_sse3) {
+    deps += [ ":thorium_WIN32_SSE2_mini_installer" ]
+  } else if (use_sse3 && !use_sse41 && !use_sse42) {
+    if (current_cpu == "x86") {
+      deps += [ ":thorium_WIN32_SSE3_mini_installer"  ]
+    } else if (current_cpu == "x64") {
+      deps += [ ":thorium_SSE3_mini_installer" ]
+    }
+  } else if (use_sse41 && !use_sse42) {
+    deps += [ ":thorium_SSE4_mini_installer" ]
+  } else if (use_sse42 && !use_avx) {
+    deps += [ ":thorium_SSE4.2_mini_installer" ]
+  } else if (use_avx && !use_avx2) {
+    deps += [ ":thorium_AVX_mini_installer" ]
+  } else if (use_avx2 && !use_avx512) {
+    deps += [":thorium_AVX2_mini_installer"  ]
+  } else if (use_avx512) {
+    deps += [ ":thorium_AVX512_mini_installer" ]
+  } else {
+    deps += [ ":thorium_mini_installer" ]
+  }
+}
+
+generate_mini_installer("thorium_WIN32_SSE2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_WIN32_SSE3_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE3_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE4_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE4.2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX512_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_mini_installer") {
   rc_file = packed_files_rc_file
 }
 
@@ -354,14 +456,14 @@ if (!(is_component_build && is_debug && target_cpu == "x86") &&
             root_out_dir)
     inputs = [
       "$root_out_dir/" + alternate_version_generator_rel_path,
-      "$root_out_dir/mini_installer.exe",
+      "$root_out_dir/thorium_mini_installer.exe",
     ]
     outputs = [ "$root_out_dir/$target_name.exe" ]
     args = [
       "--alternate_version_generator",
       alternate_version_generator_rel_path,
       "--mini_installer",
-      "mini_installer.exe",
+      "thorium_mini_installer.exe",
       "--out",
       "$target_name.exe",
       "--path_7za",
@@ -369,6 +471,7 @@ if (!(is_component_build && is_debug && target_cpu == "x86") &&
     ]
     deps = [
       ":mini_installer",
+      ":thorium_mini_installer",
       alternate_version_generator_target,
     ]
   }
diff --git a/chrome/installer/mini_installer/configuration.cc b/chrome/installer/mini_installer/configuration.cc
index a5fdecc832180..f55755e460dac 100644
--- a/chrome/installer/mini_installer/configuration.cc
+++ b/chrome/installer/mini_installer/configuration.cc
@@ -65,6 +65,8 @@ void Configuration::Clear() {
   command_line_ = nullptr;
   argument_count_ = 0;
   is_system_level_ = false;
+  is_silent_install_ = false;
+  enable_logging_ = false;
   has_invalid_switch_ = false;
   should_delete_extracted_files_ = true;
   previous_version_ = nullptr;
@@ -80,20 +82,27 @@ bool Configuration::ParseCommandLine(const wchar_t* command_line) {
     return false;
 
   for (int i = 1; i < argument_count_; ++i) {
-    if (0 == ::lstrcmpi(args_[i], L"--system-level"))
+    if (0 == ::lstrcmpi(args_[i], L"--system-level")) {
       is_system_level_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--silent")) {
+      is_silent_install_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--debug")) {
+      enable_logging_ = true;
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-beta"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-beta")) {
       chrome_app_guid_ = google_update::kBetaAppGuid;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-dev"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-dev")) {
       chrome_app_guid_ = google_update::kDevAppGuid;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-sxs"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-sxs")) {
       chrome_app_guid_ = google_update::kSxSAppGuid;
 #endif
-    else if (0 == ::lstrcmpi(args_[i], L"--cleanup"))
-      has_invalid_switch_ = true;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-frame"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--no-cleanup")) {
+      should_delete_extracted_files_ = false;
+    } else if (0 == ::lstrcmpi(args_[i], L"--cleanup")) {
+      should_delete_extracted_files_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-frame")) {
       has_invalid_switch_ = true;
+    }
   }
 
   if (!is_system_level_)
diff --git a/chrome/installer/mini_installer/configuration.h b/chrome/installer/mini_installer/configuration.h
index b746f68cef51d..5b63aac683d12 100644
--- a/chrome/installer/mini_installer/configuration.h
+++ b/chrome/installer/mini_installer/configuration.h
@@ -38,9 +38,16 @@ class Configuration {
   // GoogleUpdateIsMachine=1 is set in the process's environment.
   bool is_system_level() const { return is_system_level_; }
 
+  // Returns true if --silent is on the command line
+  // Disables the Yes/No Dialog box on install
+  bool is_silent_install() const { return is_silent_install_; }
+
   // Returns true if any invalid switch is found on the command line.
   bool has_invalid_switch() const { return has_invalid_switch_; }
 
+  // Whether to enable console logging in mini_installer (separate from base:logging in setup.exe)
+  bool enable_logging() const { return enable_logging_; }
+
   // Returns the previous version contained in the image's resource.
   const wchar_t* previous_version() const { return previous_version_; }
 
@@ -60,6 +67,8 @@ class Configuration {
   const wchar_t* command_line_;
   int argument_count_;
   bool is_system_level_;
+  bool is_silent_install_;
+  bool enable_logging_;
   bool has_invalid_switch_;
   bool should_delete_extracted_files_;
   const wchar_t* previous_version_;
diff --git a/chrome/installer/mini_installer/mini_installer.cc b/chrome/installer/mini_installer/mini_installer.cc
index b24e4cbef109f..ae202dbf6da4a 100644
--- a/chrome/installer/mini_installer/mini_installer.cc
+++ b/chrome/installer/mini_installer/mini_installer.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -27,6 +27,7 @@
 #include "chrome/installer/mini_installer/mini_installer.h"
 
 #include <windows.h>
+#include <commctrl.h>
 
 // #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
 // "Community Additions" comment on MSDN here:
@@ -44,6 +45,8 @@
 #include <algorithm>
 #include <initializer_list>
 
+#include <iostream>
+
 #include "build/branding_buildflags.h"
 #include "chrome/installer/mini_installer/appid.h"
 #include "chrome/installer/mini_installer/configuration.h"
@@ -53,11 +56,23 @@
 #include "chrome/installer/mini_installer/memory_range.h"
 #include "chrome/installer/mini_installer/mini_file.h"
 #include "chrome/installer/mini_installer/mini_installer_constants.h"
+#include "chrome/installer/mini_installer/mini_installer_version.h"
 #include "chrome/installer/mini_installer/regkey.h"
 #include "chrome/installer/mini_installer/write_to_disk.h"
 
 namespace mini_installer {
 
+HINSTANCE g_hInst;
+HMODULE hModule;
+HWND g_hWnd;
+
+unsigned int current_width;
+unsigned int current_height;
+
+bool should_install_ = false;
+
+static Configuration conf;
+
 // Deletes |path|, updating |max_delete_attempts| if more attempts were taken
 // than indicated in |max_delete_attempts|.
 void DeleteWithRetryAndMetrics(const wchar_t* path, int& max_delete_attempts) {
@@ -851,21 +866,152 @@ bool GetWorkDir(HMODULE module,
          CreateWorkDir(base_path.get(), work_dir, exit_code);
 }
 
-ProcessExitResult WMain(HMODULE module) {
-  ProcessExitResult exit_code = ProcessExitResult(SUCCESS_EXIT_CODE);
+void SetShouldInstall() {
+  should_install_ = true;
+}
+
+bool GetShouldInstall() {
+  const bool retval = should_install_;
+  return retval;
+}
+
+DWORD WINAPI InstallThreadProc(LPVOID lpParam) {
+  HWND hwnd = g_hWnd;
+  bool success = false;
+  // Run the installation
+  if (GetShouldInstall()) {
+    std::wcout << kInstallingMessage << std::endl;
+    ProcessExitResult install_code = WMainImpl(true, hModule, conf);
+    if (install_code.IsSuccess()) {
+      success = true;
+    } else {
+      success = false;
+    }
+  }
+
+  // Stop the marquee after installation
+  SendMessageW(hwnd, TDM_SET_MARQUEE_PROGRESS_BAR, FALSE, 0);
+  SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, FALSE, 0);
+
+  // Update the dialog to show completion
+  if (success) {
+    SendMessageW(hwnd, TDM_SET_ELEMENT_TEXT, TDE_CONTENT, (LPARAM)kInstallingComplete);
+  } else {
+    SendMessageW(hwnd, TDM_SET_ELEMENT_TEXT, TDE_CONTENT, (LPARAM)kInstallingFailed);
+  }
+
+  // Re-enable Cancel button to allow user to close
+  SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDCANCEL, TRUE);
+  if (success) {
+    return 0;
+  } else {
+    return 1;
+  }
+}
+
+HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT uNotification, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData) {
+  g_hWnd = hwnd;
+  switch (uNotification) {
+    case TDN_CREATED:
+      // Set the progress bar to marquee mode but don't start animation yet
+      SendMessageW(hwnd, TDM_SET_MARQUEE_PROGRESS_BAR, TRUE, 0);
+      // Keep marquee stopped initially
+      SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, FALSE, 0);
+      break;
+    case TDN_BUTTON_CLICKED: {
+      if (wParam == IDYES) {
+        // Start the marquee animation (speed in milliseconds)
+        SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, TRUE, 30);
+        SendMessageW(hwnd, TDM_SET_ELEMENT_TEXT, TDE_CONTENT, (LPARAM)kInstallingMessage);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDYES, FALSE);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDNO, FALSE);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDCANCEL, FALSE);
+        SetShouldInstall();
+        // Run the installation on a separate thread
+        CreateThread(nullptr, 0, InstallThreadProc, hwnd, 0, nullptr);
+        return S_FALSE;
+      } else if (wParam == IDNO || wParam == IDCANCEL) {
+        break;
+      }
+    } break;
+  }
+
+  return S_OK;
+}
+
+bool InitWndInstance(HINSTANCE hInstance, int nCmdShow) {
+  bool success = false;
+  const bool is_beta = false; // TODO. Add beta checker
+  // Configure the task dialog
+  TASKDIALOGCONFIG config = { 0 };
+  config.cbSize = sizeof(config);
+  config.dwFlags = TDF_SHOW_MARQUEE_PROGRESS_BAR | TDF_USE_HICON_MAIN | TDF_CAN_BE_MINIMIZED | TDF_SIZE_TO_CONTENT;
+  config.dwCommonButtons = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON | TDCBF_CANCEL_BUTTON;
+  config.nDefaultButton = IDNO;
+  config.hMainIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MINI_INSTALLER));
+  config.pszWindowTitle = is_beta ? kInstallBetaTitle : kInstallTitle;
+  // config.pszMainInstruction = nullptr;
+  config.pszContent = is_beta ? kInstallBetaMessage : kInstallMessage;
+  //config.pButtons = buttons;
+  //config.cButtons = ARRAYSIZE(buttons);
+  config.pfCallback = TaskDialogCallbackProc;
+  config.cxWidth = 0;
+
+  // Create the main window
+  TaskDialogIndirect(&config, NULL, NULL, NULL);
+
+  return success;
+}
+
+ProcessExitResult WMain(HINSTANCE hInstance, LPWSTR pCmdLine, int nCmdShow) {
+  g_hInst = hInstance;
+  hModule = (HMODULE)g_hInst;
 
   // Parse configuration from the command line and resources.
-  Configuration configuration;
-  if (!configuration.Initialize(module)) {
+  if (!conf.Initialize(hModule)) {
     return ProcessExitResult(GENERIC_INITIALIZATION_FAILURE, ::GetLastError());
   }
 
   // Exit early if an invalid switch (e.g., "--chrome-frame") was found on the
   // command line.
-  if (configuration.has_invalid_switch()) {
+  if (conf.has_invalid_switch()) {
     return ProcessExitResult(INVALID_OPTION);
   }
 
+  if (conf.enable_logging()) {
+    if (!AllocConsole()) {
+      return ProcessExitResult(GENERIC_INITIALIZATION_FAILURE, ::GetLastError());
+    }
+    // File handler pointer to a dummy file, possibly an actual logfile
+    FILE* fNonExistFile = fDummyFile;
+    freopen_s(&fNonExistFile, "CONOUT$", "w", stdout); // Standard error
+    freopen_s(&fNonExistFile, "CONOUT$", "w", stderr); // Standard out
+  }
+
+  static constexpr bool force_disable_dialog = false;
+  if (force_disable_dialog) {
+    return WMainImpl(true, hModule, conf);
+  } else {
+    if (conf.is_silent_install()) {
+      std::wcout << L"Running silent install" << std::endl;
+      return WMainImpl(true, hModule, conf);
+    } else {
+        ProcessExitResult wnd_status = ProcessExitResult(SUCCESS_EXIT_CODE);
+        if (!InitWndInstance(hInstance, nCmdShow)) {
+          // Replace with GetError
+          wnd_status = ProcessExitResult(GENERIC_ERROR);
+        }
+        if (!GetShouldInstall()) {
+          std::wcerr << L"Not installing, user declined" << std::endl;
+        }
+        return wnd_status;
+    }
+  }
+}
+
+ProcessExitResult WMainImpl(const bool should_install, HMODULE module, const Configuration& configuration) {
+  ProcessExitResult exit_code = ProcessExitResult(SUCCESS_EXIT_CODE);
+
   // First get a path where we can extract payload
   PathString base_path;
   if (!GetWorkDir(module, &base_path, &exit_code)) {
@@ -940,4 +1086,12 @@ ProcessExitResult WMain(HMODULE module) {
   return exit_code;
 }
 
+int HandleExit(ProcessExitResult result) {
+  if (conf.enable_logging()) {
+    system("pause");
+  }
+  ::ExitProcess(result.exit_code);
+  return result.exit_code;
+}
+
 }  // namespace mini_installer
diff --git a/chrome/installer/mini_installer/mini_installer.h b/chrome/installer/mini_installer/mini_installer.h
index 2b2d38313e429..bef89cdb2637a 100644
--- a/chrome/installer/mini_installer/mini_installer.h
+++ b/chrome/installer/mini_installer/mini_installer.h
@@ -6,13 +6,30 @@
 #define CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_H_
 
 #include <windows.h>
+#include <commctrl.h>
+#include <tchar.h>
+
+#include <string> // Test for libstdc++
 
 #include "chrome/installer/mini_installer/exit_code.h"
+#include "chrome/installer/mini_installer/mini_installer_constants.h"
+#include "chrome/installer/mini_installer/mini_installer_resource.h"
 #include "chrome/installer/mini_installer/mini_string.h"
 #include "chrome/installer/mini_installer/path_string.h"
 
+static FILE* fDummyFile;
+
 namespace mini_installer {
 
+extern HINSTANCE g_hInst;
+extern HMODULE hModule;
+extern HWND g_hWnd;
+
+extern unsigned int current_width;
+extern unsigned int current_height;
+
+extern bool should_install_;
+
 class Configuration;
 
 // A container of a process exit code (eventually passed to ExitProcess) and
@@ -78,11 +95,23 @@ ProcessExitResult UnpackBinaryResources(HMODULE module,
                                         ResourceTypeString& archive_type,
                                         int& max_delete_attempts);
 
+void SetShouldInstall();
+
+bool GetShouldInstall();
+
+HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT uNotification, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData);
+
+bool InitWndInstance(HINSTANCE hInstance, int nCmdShow);
+
 // Main function for Chrome's mini_installer. First gets a working dir, unpacks
 // the resources, and finally executes setup.exe to do the install/update. Also
 // handles invoking a previous version's setup.exe to patch itself in the case
 // of differential updates.
-ProcessExitResult WMain(HMODULE module);
+ProcessExitResult WMain(HINSTANCE hInstance, LPWSTR pCmdLine, int nCmdShow);
+
+ProcessExitResult WMainImpl(const bool should_install, HMODULE module, const Configuration& configuration);
+
+int HandleExit(ProcessExitResult result);
 
 }  // namespace mini_installer
 
diff --git a/chrome/installer/mini_installer/mini_installer_constants.cc b/chrome/installer/mini_installer/mini_installer_constants.cc
index cbcd4cf1a3ef2..0ea333e90571d 100644
--- a/chrome/installer/mini_installer/mini_installer_constants.cc
+++ b/chrome/installer/mini_installer/mini_installer_constants.cc
@@ -1,4 +1,4 @@
-// Copyright 2014 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -24,7 +24,7 @@ const wchar_t kCmdNewSetupExe[] = L"new-setup-exe";
 const wchar_t kCmdPreviousVersion[] = L"previous-version";
 
 // Temp directory prefix that this process creates.
-const wchar_t kTempPrefix[] = L"CR_";
+const wchar_t kTempPrefix[] = L"TH_";
 // ap value suffix to force subsequent updates to use the full rather than
 // differential updater.
 const wchar_t kFullInstallerSuffix[] = L"-full";
@@ -80,12 +80,12 @@ const wchar_t kCleanupRegistryKey[] = L"Software\\Chrome for Testing";
 #else
 // The path to the key containing each app's Clients registry key.
 // No trailing slash on this one because the app's GUID is not appended.
-const wchar_t kClientsKeyBase[] = L"Software\\Chromium";
+const wchar_t kClientsKeyBase[] = L"Software\\Thorium";
 // The path to the key containing each app's Client State registry key.
 // No trailing slash on this one because the app's GUID is not appended.
-const wchar_t kClientStateKeyBase[] = L"Software\\Chromium";
+const wchar_t kClientStateKeyBase[] = L"Software\\Thorium";
 // The path to the key in which kCleanupRegistryValue is found.
-const wchar_t kCleanupRegistryKey[] = L"Software\\Chromium";
+const wchar_t kCleanupRegistryKey[] = L"Software\\Thorium";
 #endif
 
 }  // namespace mini_installer
diff --git a/chrome/installer/mini_installer/mini_installer_constants.h b/chrome/installer/mini_installer/mini_installer_constants.h
index 23de845654342..c6404b4dfd22c 100644
--- a/chrome/installer/mini_installer/mini_installer_constants.h
+++ b/chrome/installer/mini_installer/mini_installer_constants.h
@@ -5,6 +5,15 @@
 #ifndef CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_CONSTANTS_H_
 #define CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_CONSTANTS_H_
 
+#include "chrome/installer/mini_installer/mini_installer_version.h"
+
+static const wchar_t* kInstallMessage = L"Would you like to install Thorium?";
+static const wchar_t* kInstallBetaMessage = L"Would you like to install Thorium Beta?";
+static const wchar_t* kInstallingMessage = L"Installing...";
+static const wchar_t* kInstallingComplete = L"Installation Complete. \nYou may now close this window.";
+static const wchar_t* kInstallingFailed = L"Installation failed!";
+static const wchar_t* kMiniInstallerClass = L"ThMiniInstallerClass";
+
 namespace mini_installer {
 
 // Various filenames and prefixes.
diff --git a/chrome/installer/mini_installer/mini_installer_exe_main.cc b/chrome/installer/mini_installer/mini_installer_exe_main.cc
index aff0370044046..12ef123ac30a5 100644
--- a/chrome/installer/mini_installer/mini_installer_exe_main.cc
+++ b/chrome/installer/mini_installer/mini_installer_exe_main.cc
@@ -1,4 +1,4 @@
-// Copyright 2017 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -16,23 +16,22 @@
 // http://blogs.msdn.com/oldnewthing/archive/2004/10/25/247180.aspx
 extern "C" IMAGE_DOS_HEADER __ImageBase;
 
-extern "C" int __stdcall MainEntryPoint() {
-  mini_installer::ProcessExitResult result =
-      mini_installer::WMain(reinterpret_cast<HMODULE>(&__ImageBase));
-  ::ExitProcess(result.exit_code);
-}
+extern "C" int WINAPI wWinMain(HINSTANCE hInstance,
+                               HINSTANCE hPrevInstance,
+                               LPWSTR pCmdLine,
+                               int nCmdShow) {
+  UNREFERENCED_PARAMETER(hPrevInstance);
+
+  // Initialize common controls
+  INITCOMMONCONTROLSEX icex;
+  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
+  icex.dwICC = ICC_STANDARD_CLASSES | ICC_WIN95_CLASSES | ICC_PROGRESS_CLASS;
+  InitCommonControlsEx(&icex);
 
-#if defined(ADDRESS_SANITIZER) || BUILDFLAG(CLANG_PROFILING)
-// Executables instrumented with ASAN need CRT functions. We do not use
-// the /ENTRY switch for ASAN instrumented executable and a "main" function
-// is required.
-extern "C" int WINAPI wWinMain(HINSTANCE /* instance */,
-                               HINSTANCE /* previous_instance */,
-                               LPWSTR /* command_line */,
-                               int /* command_show */) {
-  return MainEntryPoint();
+  mini_installer::ProcessExitResult result =
+      mini_installer::WMain(hInstance, pCmdLine, nCmdShow);
+  return mini_installer::HandleExit(result);
 }
-#endif
 
 // We don't link with the CRT (this is enforced through use of the /ENTRY linker
 // flag) so we have to implement CRT functions that the compiler generates calls
@@ -59,17 +58,4 @@ void* memset(void* dest, int c, size_t count) {
   return dest;
 }
 
-#if defined(_DEBUG) && defined(ARCH_CPU_ARM64)
-// The compiler generates calls to memcpy for ARM64 debug builds so we need to
-// supply a memcpy implementation in that configuration.
-// See comments above for why we do this incantation.
-__attribute__((used))
-void* memcpy(void* destination, const void* source, size_t count) {
-  auto* dst = reinterpret_cast<uint8_t*>(destination);
-  auto* src = reinterpret_cast<const uint8_t*>(source);
-  while (count--)
-    *dst++ = *src++;
-  return destination;
-}
-#endif
 }  // extern "C"
diff --git a/chrome/installer/mini_installer/mini_installer_exe_version.rc.version b/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
index 2862d6b50a550..567c2bb2d6caa 100644
--- a/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
+++ b/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
@@ -27,7 +27,8 @@ BEGIN
             VALUE "CompanyName", "@COMPANY_FULLNAME@"
             VALUE "FileDescription", "@PRODUCT_INSTALLER_FULLNAME@"
             VALUE "FileVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
-            VALUE "InternalName", "mini_installer"
+            VALUE "InternalName", "thorium_mini_installer"
+            VALUE "OriginalFilename", "mini_installer.exe"
             VALUE "LegalCopyright", "@COPYRIGHT@"
             VALUE "ProductName", "@PRODUCT_INSTALLER_FULLNAME@"
             VALUE "ProductVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
@@ -35,6 +36,7 @@ BEGIN
             VALUE "ProductShortName", "@PRODUCT_INSTALLER_SHORTNAME@"
             VALUE "LastChange", "@LASTCHANGE@"
             VALUE "Official Build", "@OFFICIAL_BUILD@"
+            VALUE "Comments", "https://github.com/Alex313031/Thorium"
         END
     END
     BLOCK "VarFileInfo"
diff --git a/chrome/installer/mini_installer/mini_installer_resource.h b/chrome/installer/mini_installer/mini_installer_resource.h
index 9155eba56943f..c5a6f1d538452 100644
--- a/chrome/installer/mini_installer/mini_installer_resource.h
+++ b/chrome/installer/mini_installer/mini_installer_resource.h
@@ -10,6 +10,15 @@
 // Used by mini_installer.rc
 //
 #define IDI_MINI_INSTALLER 107
+
+#define IDM_ABOUT          201
+#define IDM_HELP           202
+#define IDM_EXIT           203
+
+#define IDC_YES_BUTTON     301
+#define IDC_NO_BUTTON      302
+#define IDC_CANCEL_BUTTON  303
+
 #define IDC_STATIC -1
 
 // The identifier of the RCDATA resource holding the version of Chrome on which
diff --git a/chrome/installer/setup/install_worker.cc b/chrome/installer/setup/install_worker.cc
index 011684089a29e..99eb9871c7e55 100644
--- a/chrome/installer/setup/install_worker.cc
+++ b/chrome/installer/setup/install_worker.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors, Hibiki Tachibana, and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -29,6 +29,8 @@
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
 #include "base/logging.h"
+#include "base/process/kill.h"
+#include "base/process/process_iterator.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/version.h"
@@ -39,6 +41,7 @@
 #include "base/win/win_util.h"
 #include "base/win/windows_version.h"
 #include "build/branding_buildflags.h"
+#include "content/public/common/result_codes.h"
 #include "chrome/install_static/buildflags.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_modes.h"
@@ -79,6 +82,10 @@ namespace installer {
 
 namespace {
 
+// Thorium Application dir files
+const wchar_t kInitPref[] = L"initial_preferences";
+const wchar_t kThorVer[] = L"thor_ver";
+
 void AddInstallerCopyTasks(const InstallParams& install_params,
                            WorkItemList* install_list) {
   DCHECK(install_list);
@@ -218,6 +225,46 @@ void AddDeleteUninstallEntryForMSIWorkItems(
   delete_reg_key->set_best_effort(true);
 }
 
+// Filter for processes whose base name matches and whose path starts with a
+// specified prefix.
+class ProcessPathPrefixFilter : public base::ProcessFilter {
+ public:
+  explicit ProcessPathPrefixFilter(
+      base::FilePath::StringViewType process_path_prefix)
+      : process_path_prefix_(process_path_prefix) {}
+
+  // base::ProcessFilter:
+  bool Includes(const base::ProcessEntry& entry) const override {
+    // Test if |entry|'s file path starts with the prefix we're looking for.
+    base::Process process(::OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,
+                                        FALSE, entry.th32ProcessID));
+    if (!process.IsValid())
+      return false;
+
+    DWORD path_len = MAX_PATH;
+    wchar_t path_string[MAX_PATH];
+    if (::QueryFullProcessImageName(process.Handle(), 0, path_string,
+                                    &path_len)) {
+      base::FilePath file_path(path_string);
+      return base::StartsWith(file_path.value(), process_path_prefix_,
+                              base::CompareCase::INSENSITIVE_ASCII);
+    }
+    PLOG(WARNING) << "QueryFullProcessImageName failed for PID "
+                  << entry.th32ProcessID;
+    return false;
+  }
+
+ private:
+  const base::FilePath::StringViewType process_path_prefix_;
+};
+
+// Gracefully closes previous Chrome process in |target_path|.
+void ClosePreviousChromeProcess(const base::FilePath& target_path) {
+  ProcessPathPrefixFilter target_path_filter(target_path.value());
+  base::CleanupProcesses(installer::kChromeExe, base::TimeDelta(),
+                         content::RESULT_CODE_NORMAL_EXIT, &target_path_filter);
+}
+
 // Adds Chrome specific install work items to |install_list|.
 void AddChromeWorkItems(const InstallParams& install_params,
                         WorkItemList* install_list) {
@@ -230,6 +277,11 @@ void AddChromeWorkItems(const InstallParams& install_params,
 
   const base::FilePath& target_path = installer_state.target_path();
 
+  // patch(Hibbiki): Close previous instance on system-install as we are missing
+  // required GoogleUpdate component to elevate and rename new_chrome.exe on exit.
+  if (installer_state.system_install())
+    ClosePreviousChromeProcess(target_path);
+
   if (current_version.IsValid()) {
     // Delete the archive from an existing install to save some disk space.
     base::FilePath old_installer_dir(
@@ -259,6 +311,14 @@ void AddChromeWorkItems(const InstallParams& install_params,
                                     temp_path, WorkItem::NEW_NAME_IF_IN_USE,
                                     new_chrome_exe);
 
+  // Add Thorium-specific files
+  install_list->AddCopyTreeWorkItem(src_path.Append(kInitPref),
+                                    target_path.Append(kInitPref),
+                                    temp_path, WorkItem::ALWAYS);
+  install_list->AddCopyTreeWorkItem(src_path.Append(kThorVer),
+                                    target_path.Append(kThorVer),
+                                    temp_path, WorkItem::ALWAYS);
+
   // Install kVisualElementsManifest if it is present in |src_path|. No need to
   // make this a conditional work item as if the file is not there now, it will
   // never be.
diff --git a/chrome/installer/setup/installer_state.cc b/chrome/installer/setup/installer_state.cc
index f1e38c0efc160..34b9e96c43cb3 100644
--- a/chrome/installer/setup/installer_state.cc
+++ b/chrome/installer/setup/installer_state.cc
@@ -67,8 +67,13 @@ void InstallerState::Initialize(const base::CommandLine& command_line,
                 ? SYSTEM_LEVEL
                 : USER_LEVEL);
 
+#if defined(_DEBUG)
+  verbose_logging_ =
+      GetMasterPreference(prefs, initial_preferences::kVerboseLogging, true);
+#else
   verbose_logging_ =
       GetMasterPreference(prefs, initial_preferences::kVerboseLogging, false);
+#endif
 
   msi_ = GetMasterPreference(prefs, initial_preferences::kMsi, false);
   if (!msi_) {
diff --git a/chrome/installer/setup/launch_chrome.cc b/chrome/installer/setup/launch_chrome.cc
index 52dfb225ee49d..372b7358c71c7 100644
--- a/chrome/installer/setup/launch_chrome.cc
+++ b/chrome/installer/setup/launch_chrome.cc
@@ -23,19 +23,30 @@ base::CommandLine GetPostInstallLaunchCommand(
 }
 
 bool LaunchChromeBrowser(const base::FilePath& application_path) {
-  if (application_path.empty())
+  if (application_path.empty()) {
+    PLOG(ERROR) << __func__ << " application_path.empty()";
     return false;
+  }
 
-  return base::LaunchProcess(GetPostInstallLaunchCommand(application_path),
-                             base::LaunchOptions())
-      .IsValid();
+  const base::CommandLine cmd = GetPostInstallLaunchCommand(application_path);
+  base::Process chrome_process =
+      base::LaunchProcess(cmd, base::LaunchOptions());
+  if (!chrome_process.IsValid()) {
+    PLOG(ERROR) << "Failed to launch " << cmd.GetCommandLineString();
+    return false;
+  } else {
+    PLOG(ERROR) << "Successfully launched " << cmd.GetCommandLineString();
+    return true;
+  }
 }
 
 bool LaunchChromeAndWait(const base::FilePath& application_path,
                          const base::CommandLine& options,
                          int32_t* exit_code) {
-  if (application_path.empty())
+  if (application_path.empty()) {
+    PLOG(ERROR) << __func__ << " application_path.empty()";
     return false;
+  }
 
   base::CommandLine cmd(application_path.Append(kChromeExe));
   cmd.AppendArguments(options, false);
@@ -44,11 +55,13 @@ bool LaunchChromeAndWait(const base::FilePath& application_path,
   if (!chrome_handle.IsValid()) {
     PLOG(ERROR) << "Failed to launch: " << cmd.GetCommandLineString();
     return false;
+  } else {
+    PLOG(ERROR) << "Successfully launched " << cmd.GetCommandLineString();
   }
 
   int ret = STILL_ACTIVE;
   if (!chrome_handle.WaitForExit(&ret)) {
-    PLOG(ERROR) << "Wait for process exit failed";
+    PLOG(ERROR) << "Waiting for " << kChromeExe << " process exit failed";
     return false;
   }
   DCHECK_NE(ret, static_cast<int>(STILL_ACTIVE));
diff --git a/chrome/installer/setup/setup_util.cc b/chrome/installer/setup/setup_util.cc
index 7ea39a93b45e4..f287621dfb54e 100644
--- a/chrome/installer/setup/setup_util.cc
+++ b/chrome/installer/setup/setup_util.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors, Alex313031, and Shane Fournier
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -308,7 +308,7 @@ bool ContainsUnsupportedSwitch(const base::CommandLine& cmd_line) {
 
 bool IsProcessorSupported() {
 #if defined(ARCH_CPU_X86_FAMILY)
-  return base::CPU().has_sse3();
+  return base::CPU().has_sse2();
 #elif defined(ARCH_CPU_ARM64)
   return true;
 #else
@@ -466,10 +466,15 @@ void DeleteRegistryKeyPartial(
 }
 
 bool IsDowngradeAllowed(const InitialPreferences& prefs) {
+  static constexpr bool force_allow = true;
   bool allow_downgrade = false;
-  return prefs.GetBool(initial_preferences::kAllowDowngrade,
-                       &allow_downgrade) &&
-         allow_downgrade;
+  if (force_allow) {
+    return true;
+  } else {
+    return prefs.GetBool(initial_preferences::kAllowDowngrade,
+                         &allow_downgrade) &&
+           allow_downgrade;
+  }
 }
 
 int GetInstallAge(const InstallerState& installer_state) {
diff --git a/chrome/installer/util/logging_installer.cc b/chrome/installer/util/logging_installer.cc
index 8b606fa040a8f..c64160e8a5279 100644
--- a/chrome/installer/util/logging_installer.cc
+++ b/chrome/installer/util/logging_installer.cc
@@ -99,7 +99,7 @@ void InitInstallerLogging(const installer::InitialPreferences& prefs) {
   TruncateLogFileIfNeeded(log_file_path);
 
   logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_FILE;
+  settings.logging_dest = logging::LOG_TO_FILE | logging::LOG_TO_STDERR;
   settings.log_file_path = log_file_path.value().c_str();
   logging::InitLogging(settings);
 
@@ -130,15 +130,12 @@ base::FilePath GetLogFilePath(const installer::InitialPreferences& prefs) {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       FILE_PATH_LITERAL("chrome_installer.log");
 #else  // BUILDFLAG(CHROMIUM_BRANDING)
-      FILE_PATH_LITERAL("chromium_installer.log");
+      FILE_PATH_LITERAL("thorium_installer.log");
 #endif
 
   // Fallback to current directory if getting the secure or temp directory
   // fails.
   base::FilePath tmp_path;
-  std::ignore = ::IsUserAnAdmin()
-                    ? base::PathService::Get(base::DIR_SYSTEM_TEMP, &tmp_path)
-                    : base::PathService::Get(base::DIR_TEMP, &tmp_path);
   return tmp_path.Append(kLogFilename);
 }
 
