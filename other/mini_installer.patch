diff --git a/chrome/installer/mini_installer/BUILD.gn b/chrome/installer/mini_installer/BUILD.gn
index 7e49b4e449981..4a59d3e73940d 100644
--- a/chrome/installer/mini_installer/BUILD.gn
+++ b/chrome/installer/mini_installer/BUILD.gn
@@ -1,7 +1,8 @@
-# Copyright 2015 The Chromium Authors
+# Copyright 2026 The Chromium Authors and Alex313031
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/compiler_opt.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/features.gni")
 import("//build/config/python.gni")
@@ -36,7 +37,33 @@ declare_args() {
 
 config("mini_installer_compiler_flags") {
   # Disable buffer security checking.
-  cflags = [ "/GS-" ]
+  cflags = [ "/GS-", "/clang:-O3", ]
+
+  if (!use_sse3 && use_sse2) {
+    cflags += [ "/arch:SSE2", ]
+  } else if (use_sse3) {
+    cflags += [ "/clang:-msse3", ]
+  } else if (use_sse41) {
+    cflags += [ "/clang:-mssse3", "/clang:-msse4.1", ]
+  } else if (!use_avx && use_sse42) {
+    if (current_cpu == "x86") {
+      cflags += [ "/clang:-msse4.2", ]
+    } else {
+      cflags += [ "/arch:SSE42", ]
+    }
+  } else if (!use_avx2 && use_avx) {
+    cflags += [ "/arch:AVX", ]
+  } else if (!use_avx512 && use_avx2) {
+    cflags += [ "/arch:AVX2", ]
+  } else if (use_avx512) {
+    cflags += [ "/arch:AVX2", ]
+  } else {
+    print("No SIMD")
+  }
+
+  if (use_fma) {
+    cflags += [ "/fp:fast", ]
+  }
 }
 
 source_set("lib") {
@@ -69,13 +96,24 @@ source_set("lib") {
     "write_to_disk.h",
   ]
 
-  deps = [ "//build:branding_buildflags" ]
+  deps = [
+    ":mini_installer_version",
+    "//build:branding_buildflags"
+  ]
 
   # Initialization may insert unexpected memset calls.
   configs -= [ "//build/config/compiler:default_init_stack_vars" ]
   configs += [ ":mini_installer_compiler_flags" ]
 }
 
+process_version("mini_installer_version") {
+  process_only = true
+  visibility = [ ":*" ]
+  template_file = "mini_installer_version.h.template"
+  sources = [ "//chrome/VERSION" ]
+  output = "$target_gen_dir/mini_installer_version.h"
+}
+
 process_version_rc_template("version") {
   template_file = "mini_installer_exe_version.rc.version"
   output = "$root_out_dir/mini_installer_exe_version.rc"
@@ -145,7 +183,7 @@ action("mini_installer_archive") {
   inputs = [
     "$root_out_dir/chrome.dll",
     "$root_out_dir/chrome_elf.dll",
-    "$root_out_dir/chrome.exe",
+    "$root_out_dir/thorium.exe",
     "$root_out_dir/locales/en-US.pak",
     "$root_out_dir/setup.exe",
     "//chrome/tools/build/win/makecab.py",
@@ -179,12 +217,12 @@ action("mini_installer_archive") {
     build_timestamp,
 
     # Optional arguments to generate diff installer.
-    #'--last_chrome_installer=C:/Temp/base',
+    #'--last_chrome_installer=C:/src/chromium/src/out/thorium',
     #'--setup_exe_format=DIFF',
     #'--diff_algorithm=ZUCCHINI',
 
     # Optional argument for verbose archiving output.
-    #"--verbose",
+    "--verbose",
   ]
 
   deps = [
@@ -266,6 +304,11 @@ copy("copy_signing") {
   outputs = [ "$root_out_dir/signing/mini_installer/{{source_file_part}}" ]
 }
 
+declare_args() {
+  # Wether to disable linking in CRT for mini_installer
+  no_mini_installer_crt = false
+}
+
 # Generates a mini_installer executable containing the resources provided in the
 # caller's `rc_file`.
 template("generate_mini_installer") {
@@ -290,7 +333,7 @@ template("generate_mini_installer") {
       "/NXCOMPAT",
     ]
 
-    libs = [ "setupapi.lib" ]
+    libs = [ "setupapi.lib", ]
 
     deps = [
       ":copy_signing",
@@ -315,14 +358,73 @@ template("generate_mini_installer") {
     # But in asan and clang profiling builds we need to link against a runtime
     # library, which in turn depends on the standard library and relies on it
     # to run initializers.
-    if (!is_asan && !use_clang_profiling) {
+    if (!is_asan && !use_clang_profiling && no_mini_installer_crt) {
       no_default_deps = true
       ldflags += [ "/ENTRY:MainEntryPoint" ]
+    } else {
+      libs += [ "kernel32.lib", "user32.lib", "comctl32.lib", "shell32.lib", ]
     }
   }
 }
 
-generate_mini_installer("mini_installer") {
+group("mini_installer") {
+  deps = []
+  if (use_sse2 && !use_sse3) {
+    deps += [ ":thorium_WIN32_SSE2_mini_installer" ]
+  } else if (use_sse3 && !use_sse41 && !use_sse42) {
+    if (current_cpu == "x86") {
+      deps += [ ":thorium_WIN32_SSE3_mini_installer"  ]
+    } else if (current_cpu == "x64") {
+      deps += [ ":thorium_SSE3_mini_installer" ]
+    }
+  } else if (use_sse41 && !use_sse42) {
+    deps += [ ":thorium_SSE4_mini_installer" ]
+  } else if (use_sse42 && !use_avx) {
+    deps += [ ":thorium_SSE4.2_mini_installer" ]
+  } else if (use_avx && !use_avx2) {
+    deps += [ ":thorium_AVX_mini_installer" ]
+  } else if (use_avx2 && !use_avx512) {
+    deps += [":thorium_AVX2_mini_installer"  ]
+  } else if (use_avx512) {
+    deps += [ ":thorium_AVX512_mini_installer" ]
+  } else {
+    deps += [ ":thorium_mini_installer" ]
+  }
+}
+
+generate_mini_installer("thorium_WIN32_SSE2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_WIN32_SSE3_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE3_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE4_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_SSE4.2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX2_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_AVX512_mini_installer") {
+  rc_file = packed_files_rc_file
+}
+
+generate_mini_installer("thorium_mini_installer") {
   rc_file = packed_files_rc_file
 }
 
@@ -354,14 +456,14 @@ if (!(is_component_build && is_debug && target_cpu == "x86") &&
             root_out_dir)
     inputs = [
       "$root_out_dir/" + alternate_version_generator_rel_path,
-      "$root_out_dir/mini_installer.exe",
+      "$root_out_dir/thorium_mini_installer.exe",
     ]
     outputs = [ "$root_out_dir/$target_name.exe" ]
     args = [
       "--alternate_version_generator",
       alternate_version_generator_rel_path,
       "--mini_installer",
-      "mini_installer.exe",
+      "thorium_mini_installer.exe",
       "--out",
       "$target_name.exe",
       "--path_7za",
@@ -369,6 +471,7 @@ if (!(is_component_build && is_debug && target_cpu == "x86") &&
     ]
     deps = [
       ":mini_installer",
+      ":thorium_mini_installer",
       alternate_version_generator_target,
     ]
   }
diff --git a/chrome/installer/mini_installer/configuration.cc b/chrome/installer/mini_installer/configuration.cc
index a5fdecc832180..f55755e460dac 100644
--- a/chrome/installer/mini_installer/configuration.cc
+++ b/chrome/installer/mini_installer/configuration.cc
@@ -65,6 +65,8 @@ void Configuration::Clear() {
   command_line_ = nullptr;
   argument_count_ = 0;
   is_system_level_ = false;
+  is_silent_install_ = false;
+  enable_logging_ = false;
   has_invalid_switch_ = false;
   should_delete_extracted_files_ = true;
   previous_version_ = nullptr;
@@ -80,20 +82,27 @@ bool Configuration::ParseCommandLine(const wchar_t* command_line) {
     return false;
 
   for (int i = 1; i < argument_count_; ++i) {
-    if (0 == ::lstrcmpi(args_[i], L"--system-level"))
+    if (0 == ::lstrcmpi(args_[i], L"--system-level")) {
       is_system_level_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--silent")) {
+      is_silent_install_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--debug")) {
+      enable_logging_ = true;
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-beta"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-beta")) {
       chrome_app_guid_ = google_update::kBetaAppGuid;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-dev"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-dev")) {
       chrome_app_guid_ = google_update::kDevAppGuid;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-sxs"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-sxs")) {
       chrome_app_guid_ = google_update::kSxSAppGuid;
 #endif
-    else if (0 == ::lstrcmpi(args_[i], L"--cleanup"))
-      has_invalid_switch_ = true;
-    else if (0 == ::lstrcmpi(args_[i], L"--chrome-frame"))
+    } else if (0 == ::lstrcmpi(args_[i], L"--no-cleanup")) {
+      should_delete_extracted_files_ = false;
+    } else if (0 == ::lstrcmpi(args_[i], L"--cleanup")) {
+      should_delete_extracted_files_ = true;
+    } else if (0 == ::lstrcmpi(args_[i], L"--chrome-frame")) {
       has_invalid_switch_ = true;
+    }
   }
 
   if (!is_system_level_)
diff --git a/chrome/installer/mini_installer/configuration.h b/chrome/installer/mini_installer/configuration.h
index b746f68cef51d..5b63aac683d12 100644
--- a/chrome/installer/mini_installer/configuration.h
+++ b/chrome/installer/mini_installer/configuration.h
@@ -38,9 +38,16 @@ class Configuration {
   // GoogleUpdateIsMachine=1 is set in the process's environment.
   bool is_system_level() const { return is_system_level_; }
 
+  // Returns true if --silent is on the command line
+  // Disables the Yes/No Dialog box on install
+  bool is_silent_install() const { return is_silent_install_; }
+
   // Returns true if any invalid switch is found on the command line.
   bool has_invalid_switch() const { return has_invalid_switch_; }
 
+  // Whether to enable console logging in mini_installer (separate from base:logging in setup.exe)
+  bool enable_logging() const { return enable_logging_; }
+
   // Returns the previous version contained in the image's resource.
   const wchar_t* previous_version() const { return previous_version_; }
 
@@ -60,6 +67,8 @@ class Configuration {
   const wchar_t* command_line_;
   int argument_count_;
   bool is_system_level_;
+  bool is_silent_install_;
+  bool enable_logging_;
   bool has_invalid_switch_;
   bool should_delete_extracted_files_;
   const wchar_t* previous_version_;
alex@B450M-DS3H-V2:~/chromium/src$ diff chrome/installer/mini_installer/mini_installer.cc
diff --git a/chrome/installer/mini_installer/mini_installer.cc b/chrome/installer/mini_installer/mini_installer.cc
index b24e4cbef109f..019a617434a39 100644
--- a/chrome/installer/mini_installer/mini_installer.cc
+++ b/chrome/installer/mini_installer/mini_installer.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -27,6 +27,8 @@
 #include "chrome/installer/mini_installer/mini_installer.h"
 
 #include <windows.h>
+#include <commctrl.h>
+#include <io.h>
 
 // #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
 // "Community Additions" comment on MSDN here:
@@ -43,6 +45,8 @@
 
 #include <algorithm>
 #include <initializer_list>
+#include <iostream>
+#include <string>
 
 #include "build/branding_buildflags.h"
 #include "chrome/installer/mini_installer/appid.h"
@@ -53,11 +57,28 @@
 #include "chrome/installer/mini_installer/memory_range.h"
 #include "chrome/installer/mini_installer/mini_file.h"
 #include "chrome/installer/mini_installer/mini_installer_constants.h"
+#include "chrome/installer/mini_installer/mini_installer_version.h"
 #include "chrome/installer/mini_installer/regkey.h"
 #include "chrome/installer/mini_installer/write_to_disk.h"
 
 namespace mini_installer {
 
+HINSTANCE g_hInst;
+HMODULE hModule;
+HWND g_hWnd;
+
+unsigned int current_width;
+unsigned int current_height;
+
+bool should_install_ = false;
+
+static const std::wstring kInstallTitle = std::wstring(kProductName) + std::wstring(kVersionString) + L" Installer";
+static const std::wstring kInstallBetaTitle = std::wstring(kProductName) + L" Beta " + std::wstring(kVersionString) + L" Installer";
+static const std::wstring kInstallMessage = L"Would you like to install " + std::wstring(kProductName) + L"?";
+static const std::wstring kInstallBetaMessage = L"Would you like to install " + std::wstring(kProductName) + L" Beta?";
+
+static Configuration conf;
+
 // Deletes |path|, updating |max_delete_attempts| if more attempts were taken
 // than indicated in |max_delete_attempts|.
 void DeleteWithRetryAndMetrics(const wchar_t* path, int& max_delete_attempts) {
@@ -851,21 +872,236 @@ bool GetWorkDir(HMODULE module,
          CreateWorkDir(base_path.get(), work_dir, exit_code);
 }
 
-ProcessExitResult WMain(HMODULE module) {
-  ProcessExitResult exit_code = ProcessExitResult(SUCCESS_EXIT_CODE);
+void SetShouldInstall() {
+  should_install_ = true;
+}
+
+bool GetShouldInstall() {
+  return should_install_;
+}
+
+DWORD WINAPI InstallThreadProc(LPVOID lpParam) {
+  HWND hwnd = g_hWnd;
+  bool success = false;
+  // Run the installation
+  ProcessExitResult install_code = ProcessExitResult(GENERIC_INITIALIZATION_FAILURE);
+  if (GetShouldInstall()) {
+    std::wcout << kInstallingMessage << std::endl;
+    install_code = WMainImpl(true, hModule, conf);
+    if (install_code.IsSuccess()) {
+      success = true;
+    }
+  }
+  DWORD getError = install_code.windows_error;
+
+  // Stop the marquee after installation
+  SendMessageW(hwnd, TDM_SET_MARQUEE_PROGRESS_BAR, FALSE, 0);
+  SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, FALSE, 0);
+
+  // Update the dialog to show completion status
+  static const std::wstring kInstallingDoneMsg = std::wstring(kProductName) + L" was installed successfully! \nYou may now close this window.";
+  static const std::wstring kInstallingFailedMsg = L"Installing " + std::wstring(kProductName) + L" failed. \nError: ";
+  if (success) {
+    static TASKDIALOGCONFIG DoneDlgConfig = { 0 };
+    DoneDlgConfig.cbSize = sizeof(DoneDlgConfig);
+    DoneDlgConfig.dwFlags = TDF_USE_HICON_MAIN | TDF_CAN_BE_MINIMIZED | TDF_SIZE_TO_CONTENT;
+    DoneDlgConfig.dwCommonButtons = TDCBF_OK_BUTTON;
+    DoneDlgConfig.nDefaultButton = IDOK;
+    DoneDlgConfig.hMainIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SUCCESS));
+    DoneDlgConfig.pszWindowTitle = kInstallingComplete;
+    DoneDlgConfig.pszContent = kInstallingDoneMsg.c_str();
+    DoneDlgConfig.cxWidth = 0;
+    SendMessageW(hwnd, TDM_NAVIGATE_PAGE, 0, reinterpret_cast<LPARAM>(&DoneDlgConfig));
+    return 0;
+  } else {
+    static TASKDIALOGCONFIG FailedDlgConfig = { 0 };
+    FailedDlgConfig.cbSize = sizeof(FailedDlgConfig);
+    FailedDlgConfig.dwFlags = TDF_USE_HICON_MAIN | TDF_CAN_BE_MINIMIZED | TDF_SIZE_TO_CONTENT;
+    FailedDlgConfig.dwCommonButtons = TDCBF_CLOSE_BUTTON;
+    FailedDlgConfig.nDefaultButton = IDCLOSE;
+    FailedDlgConfig.hMainIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_FAILED));
+    FailedDlgConfig.pszWindowTitle = kInstallingFailed;
+    std::wstring kInstallingError = kInstallingFailedMsg + std::to_wstring(getError);
+    FailedDlgConfig.pszContent = kInstallingError.c_str();
+    FailedDlgConfig.cxWidth = 0;
+    SendMessageW(hwnd, TDM_NAVIGATE_PAGE, 0, reinterpret_cast<LPARAM>(&FailedDlgConfig));
+    return 1;
+  }
+}
+
+HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT uNotification, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData) {
+  g_hWnd = hwnd;
+  switch (uNotification) {
+    case TDN_CREATED:
+      // Set the progress bar to marquee mode but don't start animation yet
+      SendMessageW(hwnd, TDM_SET_MARQUEE_PROGRESS_BAR, TRUE, 0);
+      // Keep marquee stopped initially
+      SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, FALSE, 0);
+      break;
+    case TDN_BUTTON_CLICKED: {
+      if (wParam == IDYES) {
+        // Start the marquee animation (speed in milliseconds)
+        SendMessageW(hwnd, TDM_SET_PROGRESS_BAR_MARQUEE, TRUE, 30);
+        SendMessageW(hwnd, TDM_SET_ELEMENT_TEXT, TDE_CONTENT, (LPARAM)kInstallingMessage);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDYES, FALSE);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDNO, FALSE);
+        SendMessageW(hwnd, TDM_ENABLE_BUTTON, IDCANCEL, FALSE);
+        SetShouldInstall();
+        // Run the installation on a separate thread
+        CreateThread(nullptr, 0, InstallThreadProc, hwnd, 0, nullptr);
+        return S_FALSE;
+      } else if (wParam == IDNO || wParam == IDCANCEL || wParam == IDCLOSE) {
+        EndDialog(hwnd, wParam);
+        break;
+      }
+    } break;
+  }
+
+  return S_OK;
+}
+
+bool InitWndInstance(HINSTANCE hInstance, int nCmdShow) {
+  bool success = false;
+  const bool is_beta = false; // TODO. Add beta checker
+  // Configure the task dialog
+  TASKDIALOGCONFIG config = { 0 };
+  config.cbSize = sizeof(config);
+  config.dwFlags = TDF_SHOW_MARQUEE_PROGRESS_BAR | TDF_USE_HICON_MAIN | TDF_CAN_BE_MINIMIZED | TDF_SIZE_TO_CONTENT | TDF_CALLBACK_TIMER;
+  config.dwCommonButtons = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON | TDCBF_CANCEL_BUTTON;
+  config.nDefaultButton = IDNO;
+  config.hMainIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MINI_INSTALLER));
+  config.pszWindowTitle = is_beta ? kInstallBetaTitle.c_str() : kInstallTitle.c_str();
+  // config.pszMainInstruction = nullptr;
+  config.pszContent = is_beta ? kInstallBetaMessage.c_str() : kInstallMessage.c_str();
+  //config.pButtons = buttons;
+  //config.cButtons = ARRAYSIZE(buttons);
+  config.pfCallback = TaskDialogCallbackProc;
+  config.cxWidth = 0;
+
+  // Create the main window
+  HRESULT kTaskDlgIndir = TaskDialogIndirect(&config, nullptr, nullptr, nullptr);
+  success = static_cast<bool>(kTaskDlgIndir == S_OK);
+  return success;
+}
+
+void RouteStdioToConsole(bool create_console_if_not_found) {
+  // Don't change anything if stdout or stderr already point to a
+  // valid stream.
+  //
+  // If we are running under Buildbot or under Cygwin's default
+  // terminal (mintty), stderr and stderr will be pipe handles.  In
+  // that case, we don't want to open CONOUT$, because its output
+  // likely does not go anywhere.
+  //
+  // We don't use GetStdHandle() to check stdout/stderr here because
+  // it can return dangling IDs of handles that were never inherited
+  // by this process.  These IDs could have been reused by the time
+  // this function is called.  The CRT checks the validity of
+  // stdout/stderr on startup (before the handle IDs can be reused).
+  // _fileno(stdout) will return -2 (_NO_CONSOLE_FILENO) if stdout was
+  // invalid.
+  if (_fileno(stdout) >= 0 || _fileno(stderr) >= 0) {
+    // _fileno was broken for SUBSYSTEM:WINDOWS from VS2010 to VS2012/2013.
+    // http://crbug.com/358267. Confirm that the underlying HANDLE is valid
+    // before aborting.
+
+    intptr_t stdout_handle = _get_osfhandle(_fileno(stdout));
+    intptr_t stderr_handle = _get_osfhandle(_fileno(stderr));
+    if (stdout_handle >= 0 || stderr_handle >= 0) {
+      return;
+    }
+  }
+
+  if (!AttachConsole(ATTACH_PARENT_PROCESS)) {
+    unsigned int result = GetLastError();
+    // Was probably already attached.
+    if (result == ERROR_ACCESS_DENIED) {
+      return;
+    }
+    // Don't bother creating a new console for each child process if the
+    // parent process is invalid (eg: crashed).
+    if (result == ERROR_GEN_FAILURE) {
+      return;
+    }
+    if (create_console_if_not_found) {
+      // Make a new console if attaching to parent fails with any other error.
+      // It should be ERROR_INVALID_HANDLE at this point, which means the
+      // browser was likely not started from a console.
+      if (!AllocConsole()) {
+        return;
+      }
+    } else {
+      return;
+    }
+  }
+
+  // Arbitrary byte count to use when buffering output lines.  More
+  // means potential waste, less means more risk of interleaved
+  // log-lines in output.
+  enum { kOutputBufferSize = 64 * 1024 };
+
+  if (freopen("CONOUT$", "w", stdout)) {
+    setvbuf(stdout, nullptr, _IOLBF, kOutputBufferSize);
+    // Overwrite FD 1 for the benefit of any code that uses this FD
+    // directly.  This is safe because the CRT allocates FDs 0, 1 and
+    // 2 at startup even if they don't have valid underlying Windows
+    // handles.  This means we won't be overwriting an FD created by
+    // _open() after startup.
+    _dup2(_fileno(stdout), 1);
+  }
+  if (freopen("CONOUT$", "w", stderr)) {
+    setvbuf(stderr, nullptr, _IOLBF, kOutputBufferSize);
+    _dup2(_fileno(stderr), 2);
+  }
+
+  // Fix all cout, wcout, cin, wcin, cerr, wcerr, clog and wclog.
+  std::ios::sync_with_stdio();
+}
+
+ProcessExitResult WMain(HINSTANCE hInstance, LPWSTR pCmdLine, int nCmdShow) {
+  g_hInst = hInstance;
+  hModule = (HMODULE)g_hInst;
 
   // Parse configuration from the command line and resources.
-  Configuration configuration;
-  if (!configuration.Initialize(module)) {
+  if (!conf.Initialize(hModule)) {
     return ProcessExitResult(GENERIC_INITIALIZATION_FAILURE, ::GetLastError());
   }
 
   // Exit early if an invalid switch (e.g., "--chrome-frame") was found on the
   // command line.
-  if (configuration.has_invalid_switch()) {
+  if (conf.has_invalid_switch()) {
     return ProcessExitResult(INVALID_OPTION);
   }
 
+  if (conf.enable_logging()) {
+    RouteStdioToConsole(false);
+  }
+
+  static constexpr bool force_disable_dialog = false;
+  if (force_disable_dialog) {
+    return WMainImpl(true, hModule, conf);
+  } else {
+    if (conf.is_silent_install()) {
+      std::wcout << L"Running silent install" << std::endl;
+      return WMainImpl(true, hModule, conf);
+    } else {
+        ProcessExitResult wnd_status = ProcessExitResult(SUCCESS_EXIT_CODE);
+        if (!InitWndInstance(hInstance, nCmdShow)) {
+          // Replace with GetError
+          std::wcerr << L"InitWndInstance failed!" << std::endl;
+          wnd_status = ProcessExitResult(GENERIC_ERROR);
+        }
+        if (!GetShouldInstall()) {
+          std::wcerr << L"Not installing, user declined" << std::endl;
+        }
+        return wnd_status;
+    }
+  }
+}
+
+ProcessExitResult WMainImpl(const bool should_install, HMODULE module, const Configuration& configuration) {
+  ProcessExitResult exit_code = ProcessExitResult(SUCCESS_EXIT_CODE);
+
   // First get a path where we can extract payload
   PathString base_path;
   if (!GetWorkDir(module, &base_path, &exit_code)) {
@@ -940,4 +1176,11 @@ ProcessExitResult WMain(HMODULE module) {
   return exit_code;
 }
 
+int HandleExit(ProcessExitResult result) {
+  if (conf.enable_logging()) {
+    //system("pause");
+  }
+  return result.exit_code;
+}
+
 }  // namespace mini_installer
diff --git a/chrome/installer/mini_installer/mini_installer.h b/chrome/installer/mini_installer/mini_installer.h
index 2b2d38313e429..d84dabc4a5ac9 100644
--- a/chrome/installer/mini_installer/mini_installer.h
+++ b/chrome/installer/mini_installer/mini_installer.h
@@ -6,13 +6,28 @@
 #define CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_H_
 
 #include <windows.h>
+#include <commctrl.h>
+#include <tchar.h>
+
+#include <string> // Test for libstdc++
 
 #include "chrome/installer/mini_installer/exit_code.h"
+#include "chrome/installer/mini_installer/mini_installer_constants.h"
+#include "chrome/installer/mini_installer/mini_installer_resource.h"
 #include "chrome/installer/mini_installer/mini_string.h"
 #include "chrome/installer/mini_installer/path_string.h"
 
 namespace mini_installer {
 
+extern HINSTANCE g_hInst;
+extern HMODULE hModule;
+extern HWND g_hWnd;
+
+extern unsigned int current_width;
+extern unsigned int current_height;
+
+extern bool should_install_;
+
 class Configuration;
 
 // A container of a process exit code (eventually passed to ExitProcess) and
@@ -78,11 +93,23 @@ ProcessExitResult UnpackBinaryResources(HMODULE module,
                                         ResourceTypeString& archive_type,
                                         int& max_delete_attempts);
 
+void SetShouldInstall();
+
+bool GetShouldInstall();
+
+HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd, UINT uNotification, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData);
+
+bool InitWndInstance(HINSTANCE hInstance, int nCmdShow);
+
 // Main function for Chrome's mini_installer. First gets a working dir, unpacks
 // the resources, and finally executes setup.exe to do the install/update. Also
 // handles invoking a previous version's setup.exe to patch itself in the case
 // of differential updates.
-ProcessExitResult WMain(HMODULE module);
+ProcessExitResult WMain(HINSTANCE hInstance, LPWSTR pCmdLine, int nCmdShow);
+
+ProcessExitResult WMainImpl(const bool should_install, HMODULE module, const Configuration& configuration);
+
+int HandleExit(ProcessExitResult result);
 
 }  // namespace mini_installer
 
diff --git a/chrome/installer/mini_installer/mini_installer.rc b/chrome/installer/mini_installer/mini_installer.rc
index fff6a53c69130..b0e8f30f9af4e 100644
--- a/chrome/installer/mini_installer/mini_installer.rc
+++ b/chrome/installer/mini_installer/mini_installer.rc
@@ -30,6 +30,8 @@ LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
 // Icon with lowest ID value placed first to ensure application icon
 // remains consistent on all systems.
 IDI_MINI_INSTALLER      ICON                    "mini_installer.ico"
+IDI_SUCCESS             ICON                    "success.ico"
+IDI_FAILED              ICON                    "failed.ico"
 
 #ifdef APSTUDIO_INVOKED
 /////////////////////////////////////////////////////////////////////////////
diff --git a/chrome/installer/mini_installer/mini_installer_constants.cc b/chrome/installer/mini_installer/mini_installer_constants.cc
index cbcd4cf1a3ef2..13ea5306828ce 100644
--- a/chrome/installer/mini_installer/mini_installer_constants.cc
+++ b/chrome/installer/mini_installer/mini_installer_constants.cc
@@ -1,4 +1,4 @@
-// Copyright 2014 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -24,7 +24,7 @@ const wchar_t kCmdNewSetupExe[] = L"new-setup-exe";
 const wchar_t kCmdPreviousVersion[] = L"previous-version";
 
 // Temp directory prefix that this process creates.
-const wchar_t kTempPrefix[] = L"CR_";
+const wchar_t kTempPrefix[] = L"TH_";
 // ap value suffix to force subsequent updates to use the full rather than
 // differential updater.
 const wchar_t kFullInstallerSuffix[] = L"-full";
@@ -80,12 +80,12 @@ const wchar_t kCleanupRegistryKey[] = L"Software\\Chrome for Testing";
 #else
 // The path to the key containing each app's Clients registry key.
 // No trailing slash on this one because the app's GUID is not appended.
-const wchar_t kClientsKeyBase[] = L"Software\\Chromium";
+const wchar_t kClientsKeyBase[] = L"Software\\Thorium";
 // The path to the key containing each app's Client State registry key.
 // No trailing slash on this one because the app's GUID is not appended.
-const wchar_t kClientStateKeyBase[] = L"Software\\Chromium";
+const wchar_t kClientStateKeyBase[] = L"Software\\Thorium";
 // The path to the key in which kCleanupRegistryValue is found.
-const wchar_t kCleanupRegistryKey[] = L"Software\\Chromium";
+const wchar_t kCleanupRegistryKey[] = L"Software\\Thorium";
 #endif
 
 }  // namespace mini_installer
diff --git a/chrome/installer/mini_installer/mini_installer_constants.h b/chrome/installer/mini_installer/mini_installer_constants.h
index 23de845654342..666632cbd5a39 100644
--- a/chrome/installer/mini_installer/mini_installer_constants.h
+++ b/chrome/installer/mini_installer/mini_installer_constants.h
@@ -5,8 +5,16 @@
 #ifndef CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_CONSTANTS_H_
 #define CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_CONSTANTS_H_
 
+#include "chrome/installer/mini_installer/mini_installer_version.h"
+
 namespace mini_installer {
 
+static constexpr wchar_t kInstallingMessage[] = L"Installing...";
+static constexpr wchar_t kInstallingComplete[] = L"Installation Complete";
+static constexpr wchar_t kInstallingFailed[] = L"Installation Failed!";
+
+static const wchar_t* kMiniInstallerClass = L"ThMiniInstallerClass";
+
 // Various filenames and prefixes.
 extern const wchar_t kSetupExe[];
 extern const wchar_t kChromeArchivePrefix[];
diff --git a/chrome/installer/mini_installer/mini_installer_exe_main.cc b/chrome/installer/mini_installer/mini_installer_exe_main.cc
index aff0370044046..c19a6c4d577d0 100644
--- a/chrome/installer/mini_installer/mini_installer_exe_main.cc
+++ b/chrome/installer/mini_installer/mini_installer_exe_main.cc
@@ -1,4 +1,4 @@
-// Copyright 2017 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -16,23 +16,24 @@
 // http://blogs.msdn.com/oldnewthing/archive/2004/10/25/247180.aspx
 extern "C" IMAGE_DOS_HEADER __ImageBase;
 
-extern "C" int __stdcall MainEntryPoint() {
-  mini_installer::ProcessExitResult result =
-      mini_installer::WMain(reinterpret_cast<HMODULE>(&__ImageBase));
-  ::ExitProcess(result.exit_code);
-}
+extern "C" int WINAPI wWinMain(HINSTANCE hInstance,
+                               HINSTANCE hPrevInstance,
+                               LPWSTR pCmdLine,
+                               int nCmdShow) {
+  UNREFERENCED_PARAMETER(hPrevInstance);
+
+  // Initialize common controls
+  INITCOMMONCONTROLSEX icex;
+  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
+  icex.dwICC = ICC_STANDARD_CLASSES | ICC_WIN95_CLASSES | ICC_PROGRESS_CLASS;
+  InitCommonControlsEx(&icex);
 
-#if defined(ADDRESS_SANITIZER) || BUILDFLAG(CLANG_PROFILING)
-// Executables instrumented with ASAN need CRT functions. We do not use
-// the /ENTRY switch for ASAN instrumented executable and a "main" function
-// is required.
-extern "C" int WINAPI wWinMain(HINSTANCE /* instance */,
-                               HINSTANCE /* previous_instance */,
-                               LPWSTR /* command_line */,
-                               int /* command_show */) {
-  return MainEntryPoint();
+  mini_installer::ProcessExitResult result =
+      mini_installer::WMain(hInstance, pCmdLine, nCmdShow);
+  const int return_code = mini_installer::HandleExit(result);
+  ::ExitProcess(return_code);
+  return return_code;
 }
-#endif
 
 // We don't link with the CRT (this is enforced through use of the /ENTRY linker
 // flag) so we have to implement CRT functions that the compiler generates calls
@@ -59,17 +60,4 @@ void* memset(void* dest, int c, size_t count) {
   return dest;
 }
 
-#if defined(_DEBUG) && defined(ARCH_CPU_ARM64)
-// The compiler generates calls to memcpy for ARM64 debug builds so we need to
-// supply a memcpy implementation in that configuration.
-// See comments above for why we do this incantation.
-__attribute__((used))
-void* memcpy(void* destination, const void* source, size_t count) {
-  auto* dst = reinterpret_cast<uint8_t*>(destination);
-  auto* src = reinterpret_cast<const uint8_t*>(source);
-  while (count--)
-    *dst++ = *src++;
-  return destination;
-}
-#endif
 }  // extern "C"
diff --git a/chrome/installer/mini_installer/mini_installer_exe_version.rc.version b/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
index 2862d6b50a550..567c2bb2d6caa 100644
--- a/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
+++ b/chrome/installer/mini_installer/mini_installer_exe_version.rc.version
@@ -27,7 +27,8 @@ BEGIN
             VALUE "CompanyName", "@COMPANY_FULLNAME@"
             VALUE "FileDescription", "@PRODUCT_INSTALLER_FULLNAME@"
             VALUE "FileVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
-            VALUE "InternalName", "mini_installer"
+            VALUE "InternalName", "thorium_mini_installer"
+            VALUE "OriginalFilename", "mini_installer.exe"
             VALUE "LegalCopyright", "@COPYRIGHT@"
             VALUE "ProductName", "@PRODUCT_INSTALLER_FULLNAME@"
             VALUE "ProductVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
@@ -35,6 +36,7 @@ BEGIN
             VALUE "ProductShortName", "@PRODUCT_INSTALLER_SHORTNAME@"
             VALUE "LastChange", "@LASTCHANGE@"
             VALUE "Official Build", "@OFFICIAL_BUILD@"
+            VALUE "Comments", "https://github.com/Alex313031/Thorium"
         END
     END
     BLOCK "VarFileInfo"
diff --git a/chrome/installer/mini_installer/mini_installer_resource.h b/chrome/installer/mini_installer/mini_installer_resource.h
index 9155eba56943f..a498f79a58128 100644
--- a/chrome/installer/mini_installer/mini_installer_resource.h
+++ b/chrome/installer/mini_installer/mini_installer_resource.h
@@ -10,6 +10,19 @@
 // Used by mini_installer.rc
 //
 #define IDI_MINI_INSTALLER 107
+#define IDI_SUCCESS        108
+#define IDI_FAILED         109
+
+#define IDM_ABOUT          201
+#define IDM_HELP           202
+#define IDM_EXIT           203
+
+#define IDC_YES_BUTTON     301
+#define IDC_NO_BUTTON      302
+#define IDC_CANCEL_BUTTON  303
+
+#define IDC_DONE_INSTALLING WM_USER + 2
+
 #define IDC_STATIC -1
 
 // The identifier of the RCDATA resource holding the version of Chrome on which
diff --git a/chrome/installer/mini_installer/mini_installer_version.h.template b/chrome/installer/mini_installer/mini_installer_version.h.template
new file mode 100644
index 0000000000000..edff34daa38a8
--- /dev/null
+++ b/chrome/installer/mini_installer/mini_installer_version.h.template
@@ -0,0 +1,22 @@
+#ifndef CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_VERSION_H_
+#define CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_VERSION_H_
+
+// Copyright 2026 Alex313031
+
+namespace mini_installer {
+
+static constexpr int MAJOR_VERSION = @MAJOR@;
+
+static constexpr int MINOR_VERSION = @MINOR@;
+
+static constexpr int BUILD_VERSION = @BUILD@;
+
+static constexpr int PATCH_VERSION = @PATCH@;
+
+static constexpr wchar_t kVersionString[] = L"@MAJOR@.@MINOR@.@BUILD@.@PATCH@";
+
+static constexpr wchar_t kProductName[] = L"Thorium";
+
+} // namespace mini_installer
+
+#endif // CHROME_INSTALLER_MINI_INSTALLER_MINI_INSTALLER_VERSION_H_
diff --git a/chrome/installer/setup/install_worker.cc b/chrome/installer/setup/install_worker.cc
index 011684089a29e..25e785cd19e0a 100644
--- a/chrome/installer/setup/install_worker.cc
+++ b/chrome/installer/setup/install_worker.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors, Hibiki Tachibana, and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -29,6 +29,8 @@
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
 #include "base/logging.h"
+#include "base/process/kill.h"
+#include "base/process/process_iterator.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/version.h"
@@ -39,6 +41,7 @@
 #include "base/win/win_util.h"
 #include "base/win/windows_version.h"
 #include "build/branding_buildflags.h"
+#include "content/public/common/result_codes.h"
 #include "chrome/install_static/buildflags.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_modes.h"
@@ -79,6 +82,10 @@ namespace installer {
 
 namespace {
 
+// Thorium Application dir files
+const wchar_t kInitPref[] = L"initial_preferences";
+const wchar_t kThorVer[] = L"thor_ver";
+
 void AddInstallerCopyTasks(const InstallParams& install_params,
                            WorkItemList* install_list) {
   DCHECK(install_list);
@@ -218,6 +225,46 @@ void AddDeleteUninstallEntryForMSIWorkItems(
   delete_reg_key->set_best_effort(true);
 }
 
+// Filter for processes whose base name matches and whose path starts with a
+// specified prefix.
+class ProcessPathPrefixFilter : public base::ProcessFilter {
+ public:
+  explicit ProcessPathPrefixFilter(
+      base::FilePath::StringViewType process_path_prefix)
+      : process_path_prefix_(process_path_prefix) {}
+
+  // base::ProcessFilter:
+  bool Includes(const base::ProcessEntry& entry) const override {
+    // Test if |entry|'s file path starts with the prefix we're looking for.
+    base::Process process(::OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,
+                                        FALSE, entry.th32ProcessID));
+    if (!process.IsValid())
+      return false;
+
+    DWORD path_len = MAX_PATH;
+    wchar_t path_string[MAX_PATH];
+    if (::QueryFullProcessImageName(process.Handle(), 0, path_string,
+                                    &path_len)) {
+      base::FilePath file_path(path_string);
+      return base::StartsWith(file_path.value(), process_path_prefix_,
+                              base::CompareCase::INSENSITIVE_ASCII);
+    }
+    PLOG(WARNING) << "QueryFullProcessImageName failed for PID "
+                  << entry.th32ProcessID;
+    return false;
+  }
+
+ private:
+  const base::FilePath::StringViewType process_path_prefix_;
+};
+
+// Gracefully closes previous Chrome process in |target_path|.
+void ClosePreviousChromeProcess(const base::FilePath& target_path) {
+  ProcessPathPrefixFilter target_path_filter(target_path.value());
+  base::CleanupProcesses(installer::kChromeExe, base::TimeDelta(),
+                         content::RESULT_CODE_NORMAL_EXIT, &target_path_filter);
+}
+
 // Adds Chrome specific install work items to |install_list|.
 void AddChromeWorkItems(const InstallParams& install_params,
                         WorkItemList* install_list) {
@@ -230,6 +277,11 @@ void AddChromeWorkItems(const InstallParams& install_params,
 
   const base::FilePath& target_path = installer_state.target_path();
 
+  // patch(Hibbiki): Close previous instance on system-install as we are missing
+  // required GoogleUpdate component to elevate and rename new_chrome.exe on exit.
+  if (installer_state.system_install())
+    ClosePreviousChromeProcess(target_path);
+
   if (current_version.IsValid()) {
     // Delete the archive from an existing install to save some disk space.
     base::FilePath old_installer_dir(
@@ -259,6 +311,14 @@ void AddChromeWorkItems(const InstallParams& install_params,
                                     temp_path, WorkItem::NEW_NAME_IF_IN_USE,
                                     new_chrome_exe);
 
+  // Add Thorium-specific files
+  install_list->AddCopyTreeWorkItem(src_path.Append(kInitPref),
+                                    target_path.Append(kInitPref),
+                                    temp_path, WorkItem::ALWAYS);
+  install_list->AddCopyTreeWorkItem(src_path.Append(kThorVer),
+                                    target_path.Append(kThorVer),
+                                    temp_path, WorkItem::ALWAYS);
+
   // Install kVisualElementsManifest if it is present in |src_path|. No need to
   // make this a conditional work item as if the file is not there now, it will
   // never be.
diff --git a/chrome/installer/setup/installer_state.cc b/chrome/installer/setup/installer_state.cc
index f1e38c0efc160..7334cb587c48b 100644
--- a/chrome/installer/setup/installer_state.cc
+++ b/chrome/installer/setup/installer_state.cc
@@ -44,14 +44,16 @@ InstallerState::InstallerState()
       level_(UNKNOWN_LEVEL),
       root_key_(nullptr),
       msi_(false),
-      verbose_logging_(false) {}
+      verbose_logging_(false),
+      debug_mode_(false) {}
 
 InstallerState::InstallerState(Level level)
     : operation_(UNINITIALIZED),
       level_(UNKNOWN_LEVEL),
       root_key_(nullptr),
       msi_(false),
-      verbose_logging_(false) {
+      verbose_logging_(false),
+      debug_mode_(false) {
   // Use set_level() so that root_key_ is updated properly.
   set_level(level);
 }
@@ -67,8 +69,16 @@ void InstallerState::Initialize(const base::CommandLine& command_line,
                 ? SYSTEM_LEVEL
                 : USER_LEVEL);
 
+  const bool debug_logging =
+#if defined(_DEBUG)
+      true;
+#else
+      false;
+#endif
   verbose_logging_ =
-      GetMasterPreference(prefs, initial_preferences::kVerboseLogging, false);
+      GetMasterPreference(prefs, initial_preferences::kVerboseLogging, debug_logging);
+  debug_mode_ =
+      GetMasterPreference(prefs, initial_preferences::kDebugMode, debug_logging);
 
   msi_ = GetMasterPreference(prefs, initial_preferences::kMsi, false);
   if (!msi_) {
@@ -163,6 +173,7 @@ void InstallerState::Clear() {
   root_key_ = nullptr;
   msi_ = false;
   verbose_logging_ = false;
+  debug_mode_ = false;
 }
 
 void InstallerState::SetStage(InstallerStage stage) const {
diff --git a/chrome/installer/setup/installer_state.h b/chrome/installer/setup/installer_state.h
index d8d444e685734..7a92dbaa9f965 100644
--- a/chrome/installer/setup/installer_state.h
+++ b/chrome/installer/setup/installer_state.h
@@ -72,7 +72,11 @@ class InstallerState {
 
   // True if the --verbose-logging command-line flag is set or if the
   // verbose_logging initial preferences option is true.
-  bool verbose_logging() const { return verbose_logging_; }
+  bool verbose_logging() const { return verbose_logging_ || debug_mode_; }
+
+  // True if the --verbose-logging command-line flag is set or if the
+  // debug_mode initial preferences option is true.
+  bool debug_mode() const { return debug_mode_; }
 
   HKEY root_key() const { return root_key_; }
 
@@ -130,6 +134,7 @@ class InstallerState {
   HKEY root_key_;
   bool msi_;
   bool verbose_logging_;
+  bool debug_mode_;
 };
 
 }  // namespace installer
diff --git a/chrome/installer/setup/launch_chrome.cc b/chrome/installer/setup/launch_chrome.cc
index 52dfb225ee49d..372b7358c71c7 100644
--- a/chrome/installer/setup/launch_chrome.cc
+++ b/chrome/installer/setup/launch_chrome.cc
@@ -23,19 +23,30 @@ base::CommandLine GetPostInstallLaunchCommand(
 }
 
 bool LaunchChromeBrowser(const base::FilePath& application_path) {
-  if (application_path.empty())
+  if (application_path.empty()) {
+    PLOG(ERROR) << __func__ << " application_path.empty()";
     return false;
+  }
 
-  return base::LaunchProcess(GetPostInstallLaunchCommand(application_path),
-                             base::LaunchOptions())
-      .IsValid();
+  const base::CommandLine cmd = GetPostInstallLaunchCommand(application_path);
+  base::Process chrome_process =
+      base::LaunchProcess(cmd, base::LaunchOptions());
+  if (!chrome_process.IsValid()) {
+    PLOG(ERROR) << "Failed to launch " << cmd.GetCommandLineString();
+    return false;
+  } else {
+    PLOG(ERROR) << "Successfully launched " << cmd.GetCommandLineString();
+    return true;
+  }
 }
 
 bool LaunchChromeAndWait(const base::FilePath& application_path,
                          const base::CommandLine& options,
                          int32_t* exit_code) {
-  if (application_path.empty())
+  if (application_path.empty()) {
+    PLOG(ERROR) << __func__ << " application_path.empty()";
     return false;
+  }
 
   base::CommandLine cmd(application_path.Append(kChromeExe));
   cmd.AppendArguments(options, false);
@@ -44,11 +55,13 @@ bool LaunchChromeAndWait(const base::FilePath& application_path,
   if (!chrome_handle.IsValid()) {
     PLOG(ERROR) << "Failed to launch: " << cmd.GetCommandLineString();
     return false;
+  } else {
+    PLOG(ERROR) << "Successfully launched " << cmd.GetCommandLineString();
   }
 
   int ret = STILL_ACTIVE;
   if (!chrome_handle.WaitForExit(&ret)) {
-    PLOG(ERROR) << "Wait for process exit failed";
+    PLOG(ERROR) << "Waiting for " << kChromeExe << " process exit failed";
     return false;
   }
   DCHECK_NE(ret, static_cast<int>(STILL_ACTIVE));
diff --git a/chrome/installer/setup/setup_util.cc b/chrome/installer/setup/setup_util.cc
index 7ea39a93b45e4..296651bcf4eec 100644
--- a/chrome/installer/setup/setup_util.cc
+++ b/chrome/installer/setup/setup_util.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors, Alex313031, and Shane Fournier
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -308,7 +308,7 @@ bool ContainsUnsupportedSwitch(const base::CommandLine& cmd_line) {
 
 bool IsProcessorSupported() {
 #if defined(ARCH_CPU_X86_FAMILY)
-  return base::CPU().has_sse3();
+  return base::CPU().has_sse2();
 #elif defined(ARCH_CPU_ARM64)
   return true;
 #else
@@ -466,10 +466,15 @@ void DeleteRegistryKeyPartial(
 }
 
 bool IsDowngradeAllowed(const InitialPreferences& prefs) {
+  static constexpr bool force_allow = true;
   bool allow_downgrade = false;
-  return prefs.GetBool(initial_preferences::kAllowDowngrade,
-                       &allow_downgrade) &&
-         allow_downgrade;
+  if (force_allow) {
+    return true;
+  } else {
+    return prefs.GetBool(initial_preferences::kAllowDowngrade,
+                         &allow_downgrade) &&
+           allow_downgrade;
+  }
 }
 
 int GetInstallAge(const InstallerState& installer_state) {
diff --git a/chrome/installer/util/initial_preferences.cc b/chrome/installer/util/initial_preferences.cc
index 48ae7b2d6c69e..1fa5f07604adf 100644
--- a/chrome/installer/util/initial_preferences.cc
+++ b/chrome/installer/util/initial_preferences.cc
@@ -4,6 +4,10 @@
 
 #include "chrome/installer/util/initial_preferences.h"
 
+#if BUILDFLAG(IS_WIN)
+ #include <windows.h>
+#endif
+
 #include <stddef.h>
 
 #include <memory>
@@ -145,6 +149,8 @@ void InitialPreferences::InitializeFromCommandLine(
        installer::initial_preferences::kSystemLevel},
       {installer::switches::kVerboseLogging,
        installer::initial_preferences::kVerboseLogging},
+      {installer::switches::kDebugMode,
+       installer::initial_preferences::kDebugMode},
   };
 
   std::string name(installer::initial_preferences::kDistroDict);
@@ -351,4 +357,25 @@ const InitialPreferences& InitialPreferences::ForCurrentProcess() {
   return g_initial_preferences.Get();
 }
 
+#if BUILDFLAG(IS_WIN)
+// Get the dir to setup.exe, then go up one level to get mini_installer dir.
+const base::FilePath GetMiniInstallerDir() {
+  wchar_t exe_path[MAX_PATH];
+  HMODULE this_app = GetModuleHandleW(nullptr);
+  if (!this_app) {
+    return base::FilePath();
+  }
+  DWORD got_path = GetModuleFileNameW(nullptr, exe_path, MAX_PATH);
+  if (got_path == 0 || got_path >= MAX_PATH) {
+    return base::FilePath();
+  }
+
+  base::FilePath full_path(exe_path);
+  // Go up one directory by calling DirName twice.
+  base::FilePath parent_dir = full_path.DirName().DirName();
+
+  return parent_dir;
+}
+#endif
+
 }  // namespace installer
diff --git a/chrome/installer/util/initial_preferences.h b/chrome/installer/util/initial_preferences.h
index c03cb7d5f6c9c..fb0ecc5f3339d 100644
--- a/chrome/installer/util/initial_preferences.h
+++ b/chrome/installer/util/initial_preferences.h
@@ -208,6 +208,9 @@ class InitialPreferences {
   bool preferences_read_from_file_ = false;
 };
 
+// Get the dir to mini_installer, for putting thorium_installer.log if --debug flag is used.
+const base::FilePath GetMiniInstallerDir();
+
 }  // namespace installer
 
 #endif  // CHROME_INSTALLER_UTIL_INITIAL_PREFERENCES_H_
diff --git a/chrome/installer/util/initial_preferences_constants.cc b/chrome/installer/util/initial_preferences_constants.cc
index 2bf39cf67b85a..a49721824410e 100644
--- a/chrome/installer/util/initial_preferences_constants.cc
+++ b/chrome/installer/util/initial_preferences_constants.cc
@@ -31,6 +31,7 @@ const char kSystemLevel[] = "system_level";
 const char kVerboseLogging[] = "verbose_logging";
 const char kExtensionsBlock[] = "extensions.settings";
 const char kAllowDowngrade[] = "allow_downgrade";
+const char kDebugMode[] = "debug_mode";
 
 }  // namespace initial_preferences
 }  // namespace installer
diff --git a/chrome/installer/util/initial_preferences_constants.h b/chrome/installer/util/initial_preferences_constants.h
index df8961eed4cd2..561e86eeecae4 100644
--- a/chrome/installer/util/initial_preferences_constants.h
+++ b/chrome/installer/util/initial_preferences_constants.h
@@ -68,6 +68,8 @@ extern const char kVerboseLogging[];
 extern const char kExtensionsBlock[];
 // Boolean. Allow Chrome to be downgraded to a previous version if true.
 extern const char kAllowDowngrade[];
+// Boolean. Whether to enable debug mode for logging.
+extern const char kDebugMode[];
 
 }  // namespace initial_preferences
 }  // namespace installer
diff --git a/chrome/installer/util/logging_installer.cc b/chrome/installer/util/logging_installer.cc
index 8b606fa040a8f..d08bf6349f896 100644
--- a/chrome/installer/util/logging_installer.cc
+++ b/chrome/installer/util/logging_installer.cc
@@ -10,6 +10,7 @@
 #include "chrome/installer/util/logging_installer.h"
 
 #include <windows.h>
+#include <io.h>
 
 #include <shlobj.h>
 #include <stdint.h>
@@ -83,6 +84,80 @@ TruncateResult TruncateLogFileIfNeeded(const base::FilePath& log_file) {
   return result;
 }
 
+void RouteStdioToConsole(bool create_console_if_not_found) {
+  // Don't change anything if stdout or stderr already point to a
+  // valid stream.
+  //
+  // If we are running under Buildbot or under Cygwin's default
+  // terminal (mintty), stderr and stderr will be pipe handles.  In
+  // that case, we don't want to open CONOUT$, because its output
+  // likely does not go anywhere.
+  //
+  // We don't use GetStdHandle() to check stdout/stderr here because
+  // it can return dangling IDs of handles that were never inherited
+  // by this process.  These IDs could have been reused by the time
+  // this function is called.  The CRT checks the validity of
+  // stdout/stderr on startup (before the handle IDs can be reused).
+  // _fileno(stdout) will return -2 (_NO_CONSOLE_FILENO) if stdout was
+  // invalid.
+  if (_fileno(stdout) >= 0 || _fileno(stderr) >= 0) {
+    // _fileno was broken for SUBSYSTEM:WINDOWS from VS2010 to VS2012/2013.
+    // http://crbug.com/358267. Confirm that the underlying HANDLE is valid
+    // before aborting.
+
+    intptr_t stdout_handle = _get_osfhandle(_fileno(stdout));
+    intptr_t stderr_handle = _get_osfhandle(_fileno(stderr));
+    if (stdout_handle >= 0 || stderr_handle >= 0) {
+      return;
+    }
+  }
+
+  if (!AttachConsole(ATTACH_PARENT_PROCESS)) {
+    unsigned int result = GetLastError();
+    // Was probably already attached.
+    if (result == ERROR_ACCESS_DENIED) {
+      return;
+    }
+    // Don't bother creating a new console for each child process if the
+    // parent process is invalid (eg: crashed).
+    if (result == ERROR_GEN_FAILURE) {
+      return;
+    }
+    if (create_console_if_not_found) {
+      // Make a new console if attaching to parent fails with any other error.
+      // It should be ERROR_INVALID_HANDLE at this point, which means the
+      // browser was likely not started from a console.
+      if (!AllocConsole()) {
+        return;
+      }
+    } else {
+      return;
+    }
+  }
+
+  // Arbitrary byte count to use when buffering output lines.  More
+  // means potential waste, less means more risk of interleaved
+  // log-lines in output.
+  enum { kOutputBufferSize = 64 * 1024 };
+
+  if (freopen("CONOUT$", "w", stdout)) {
+    setvbuf(stdout, nullptr, _IOLBF, kOutputBufferSize);
+    // Overwrite FD 1 for the benefit of any code that uses this FD
+    // directly.  This is safe because the CRT allocates FDs 0, 1 and
+    // 2 at startup even if they don't have valid underlying Windows
+    // handles.  This means we won't be overwriting an FD created by
+    // _open() after startup.
+    _dup2(_fileno(stdout), 1);
+  }
+  if (freopen("CONOUT$", "w", stderr)) {
+    setvbuf(stderr, nullptr, _IOLBF, kOutputBufferSize);
+    _dup2(_fileno(stderr), 2);
+  }
+
+  // Fix all cout, wcout, cin, wcin, cerr, wcerr, clog and wclog.
+  std::ios::sync_with_stdio();
+}
+
 void InitInstallerLogging(const installer::InitialPreferences& prefs) {
   if (installer_logging_)
     return;
@@ -90,21 +165,33 @@ void InitInstallerLogging(const installer::InitialPreferences& prefs) {
   installer_logging_ = true;
 
   bool value = false;
+  bool kDebug = false;
+  bool kVerbose = false;
   if (prefs.GetBool(installer::initial_preferences::kDisableLogging, &value) &&
       value) {
     return;
   }
+  if (prefs.GetBool(installer::initial_preferences::kDebugMode, &value) &&
+      value) {
+    kDebug = true;
+  }
+  if (prefs.GetBool(installer::initial_preferences::kVerboseLogging, &value) &&
+      value) {
+    kVerbose = true;
+  }
+
+  // Only open new console if --debug flag used
+  RouteStdioToConsole(kDebug);
 
   base::FilePath log_file_path(GetLogFilePath(prefs));
   TruncateLogFileIfNeeded(log_file_path);
 
   logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_FILE;
+  settings.logging_dest = logging::LOG_TO_FILE | logging::LOG_TO_STDERR;
   settings.log_file_path = log_file_path.value().c_str();
   logging::InitLogging(settings);
 
-  if (prefs.GetBool(installer::initial_preferences::kVerboseLogging, &value) &&
-      value) {
+  if (kVerbose || kDebug) {
     logging::SetMinLogLevel(logging::LOGGING_VERBOSE);
   } else {
     logging::SetMinLogLevel(logging::LOGGING_ERROR);
@@ -130,15 +217,21 @@ base::FilePath GetLogFilePath(const installer::InitialPreferences& prefs) {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       FILE_PATH_LITERAL("chrome_installer.log");
 #else  // BUILDFLAG(CHROMIUM_BRANDING)
-      FILE_PATH_LITERAL("chromium_installer.log");
+      FILE_PATH_LITERAL("thorium_installer.log");
 #endif
 
   // Fallback to current directory if getting the secure or temp directory
   // fails.
+  bool kDebug = false;
   base::FilePath tmp_path;
-  std::ignore = ::IsUserAnAdmin()
-                    ? base::PathService::Get(base::DIR_SYSTEM_TEMP, &tmp_path)
-                    : base::PathService::Get(base::DIR_TEMP, &tmp_path);
+  if (prefs.GetBool(installer::initial_preferences::kDebugMode, &kDebug) && kDebug) {
+    tmp_path = installer::GetMiniInstallerDir();
+  } else {
+    std::ignore = ::IsUserAnAdmin()
+                      ? base::PathService::Get(base::DIR_SYSTEM_TEMP, &tmp_path)
+                      : base::PathService::Get(base::DIR_TEMP, &tmp_path);
+  }
+
   return tmp_path.Append(kLogFilename);
 }
 
diff --git a/chrome/installer/util/logging_installer.h b/chrome/installer/util/logging_installer.h
index 0e3845d610127..2fd12a4720483 100644
--- a/chrome/installer/util/logging_installer.h
+++ b/chrome/installer/util/logging_installer.h
@@ -43,6 +43,9 @@ enum TruncateResult {
 // run-away log files and guard against full disks.
 TruncateResult TruncateLogFileIfNeeded(const base::FilePath& log_file);
 
+// For allowing logging to console
+void RouteStdioToConsole(bool create_console_if_not_found);
+
 // Call to initialize logging for Chrome installer.
 void InitInstallerLogging(const installer::InitialPreferences& prefs);
 
diff --git a/chrome/installer/util/util_constants.cc b/chrome/installer/util/util_constants.cc
index b0d485e0cc105..85acc9de89848 100644
--- a/chrome/installer/util/util_constants.cc
+++ b/chrome/installer/util/util_constants.cc
@@ -1,4 +1,4 @@
-// Copyright 2012 The Chromium Authors
+// Copyright 2026 The Chromium Authors and Alex313031
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -76,9 +76,10 @@ const char kForceConfigureUserSettings[] = "force-configure-user-settings";
 // confirmation from user.
 const char kForceUninstall[] = "force-uninstall";
 
-// Specify the path to the Chrome archive for install. If not specified,
-// chrome.packed.7z or chrome.7z in the same directory as setup.exe
-// is used.
+// Specify the path to the compressed Chrome archive for install. If not
+// specified, chrome.packed.7z or chrome.7z in the same directory as setup.exe
+// is used (the packed file is preferred; see kUncompressedArchive to force use
+// of an uncompressed archive).
 const char kInstallArchive[] = "install-archive";
 
 // Use the given uncompressed chrome.7z archive as the source of files to
@@ -183,6 +184,9 @@ const char kUpdateSetupExe[] = "update-setup-exe";
 // Enable verbose logging (info level).
 const char kVerboseLogging[] = "verbose-logging";
 
+// Enable debug mode
+const char kDebugMode[] = "debug";
+
 }  // namespace switches
 
 // The Active Setup executable will be an identical copy of setup.exe; this is
@@ -196,9 +200,9 @@ const char kVerboseLogging[] = "verbose-logging";
 // Active Setup.
 const wchar_t kActiveSetupExe[] = L"chrmstp.exe";
 const wchar_t kChromeDll[] = L"chrome.dll";
-const wchar_t kChromeExe[] = L"chrome.exe";
-const wchar_t kChromeNewExe[] = L"new_chrome.exe";
-const wchar_t kChromeOldExe[] = L"old_chrome.exe";
+const wchar_t kChromeExe[] = L"thorium.exe";
+const wchar_t kChromeNewExe[] = L"new_thorium.exe";
+const wchar_t kChromeOldExe[] = L"old_thorium.exe";
 const wchar_t kChromeProxyExe[] = L"chrome_proxy.exe";
 const wchar_t kChromeProxyNewExe[] = L"new_chrome_proxy.exe";
 const wchar_t kChromeProxyOldExe[] = L"old_chrome_proxy.exe";
diff --git a/chrome/installer/util/util_constants.h b/chrome/installer/util/util_constants.h
index 042823db6161e..54a163b5e5858 100644
--- a/chrome/installer/util/util_constants.h
+++ b/chrome/installer/util/util_constants.h
@@ -213,6 +213,7 @@ extern const char kUncompressedArchive[];
 extern const char kUninstall[];
 extern const char kUpdateSetupExe[];
 extern const char kVerboseLogging[];
+extern const char kDebugMode[];
 
 }  // namespace switches
 
